<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/USER_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/USER_GUIDE.md" />
              <option name="updatedContent" value="# 用户使用指南 (User Guide)&#10;&#10;##  文档说明&#10;&#10;本指南详细介绍云计算服务队列仿真系统的界面元素、参数含义和使用方法。&#10;&#10;**相关文档**：&#10;- **SCENARIO_GUIDE.md** - 场景化应用案例指南&#10;- **STATISTICS_IMPLEMENTATION.md** - 技术实现细节（开发者参考）&#10;&#10;---&#10;&#10;##  界面布局概览&#10;&#10;### 顶部控制面板&#10;- ▶️ Start / ⏸ Pause / ▶️ Resume / ⏹ Stop /  Reset 按钮&#10;- ⏱ 仿真时间显示&#10;-  速度控制滑块（0.1x - 100x）&#10;&#10;### 中央可视化区域&#10;- 系统流程可视化画布&#10;- 实时显示任务流动和服务点状态&#10;&#10;### 右侧统计面板&#10;- Overall Statistics (总体统计)&#10;- Queue Statistics (队列统计)&#10;- User Type Statistics (用户类型统计)&#10;- Task Type Statistics (任务类型统计)&#10;&#10;### 底部配置面板&#10;- 仿真参数配置&#10;- 数据库连接状态&#10;- 配置保存/加载功能&#10;- 历史仿真记录表&#10;&#10;---&#10;&#10;##  右侧统计面板详细说明&#10;&#10;### 1. Overall Statistics (总体统计)&#10;&#10;#### **Tasks Arrived (到达任务数)**&#10;**含义**: 系统中已到达的任务总数&#10;&#10;**作用**: 监控系统负载，了解有多少任务进入系统&#10;&#10;---&#10;&#10;#### **Tasks Completed (完成任务数)**&#10;**含义**: 系统已完成处理的任务总数&#10;&#10;**作用**: &#10;- 与到达任务数对比，了解系统处理进度&#10;- 如果完成数远小于到达数，说明系统存在积压&#10;&#10;---&#10;&#10;#### **Avg System Time (平均系统时间)**&#10;**含义**: 每个任务从到达系统到完成服务所经历的平均总时间（单位：秒）&#10;&#10;**计算公式**:&#10;```&#10;平均系统时间 = 所有已完成任务的系统时间总和 ÷ 已完成任务数量&#10;```&#10;&#10;**系统时间包括**:&#10;- 在各个队列中的等待时间&#10;- 在各个服务点的服务时间&#10;- 整个流程的总耗时&#10;&#10;**作用**:&#10;- 衡量系统的响应速度&#10;- 越小说明系统处理速度越快，用户体验越好&#10;- 如果这个值过大，说明系统可能存在瓶颈（队列太长、服务器不够等）&#10;&#10;**示例解读**:&#10;- `15.30s` → 平均每个任务需要15.3秒完成&#10;- `2.50s` → 平均每个任务需要2.5秒完成（系统效率高）&#10;- `45.00s` → 平均每个任务需要45秒完成（系统可能过载）&#10;&#10;---&#10;&#10;#### **Throughput (吞吐量)**&#10;**含义**: 系统每秒钟完成的任务数量（单位：任务/秒）&#10;&#10;**计算公式**:&#10;```&#10;吞吐量 = 已完成任务总数 ÷ 仿真运行时间&#10;```&#10;&#10;**作用**:&#10;- 衡量系统的处理能力&#10;- 越大说明系统在单位时间内处理的任务越多，性能越好&#10;- 这是评估云计算服务容量的关键指标&#10;&#10;**示例解读**:&#10;- `0.500/s` → 每秒完成0.5个任务（每2秒完成1个任务）&#10;- `2.000/s` → 每秒完成2个任务&#10;- `0.050/s` → 每秒完成0.05个任务（每20秒完成1个任务，系统效率很低）&#10;&#10;**影响因素**:&#10;- CPU/GPU节点数量（服务器越多，吞吐量越大）&#10;- 任务到达频率&#10;- 各服务点的处理速度&#10;- 队列管理策略&#10;&#10;---&#10;&#10;### 2. Queue Statistics (队列统计)&#10;&#10;**含义**: 实时显示系统中所有服务点的队列状态和利用率&#10;&#10;**显示内容**:&#10;&#10;####  Data Storage (数据存储)&#10;- **Queue**: 当前队列中等待的任务数量&#10;- **Busy**: 繁忙服务器数 / 总服务器数 (1个服务器)&#10;- **Max**: 仿真过程中队列的最大长度&#10;- **Utilization**: 服务器利用率百分比&#10;&#10;####  Classification (分类服务)&#10;- **Queue**: 当前队列中等待的任务数量&#10;- **Busy**: 繁忙服务器数 / 总服务器数 (1个服务器)&#10;- **Max**: 仿真过程中队列的最大长度&#10;- **Utilization**: 服务器利用率百分比&#10;&#10;####  CPU Queue (CPU等待队列)&#10;- **Waiting**: 当前等待分配到CPU节点的任务数量&#10;- **Max**: 等待队列的历史最大长度&#10;&#10;####  CPU Compute (CPU计算节点)&#10;- **Queue**: 当前队列中的任务数量&#10;- **Busy**: 繁忙节点数 / 总节点数（根据配置）&#10;- **Max**: 队列的历史最大长度&#10;- **Utilization**: CPU节点利用率百分比&#10;- **Served**: 已服务完成的任务总数&#10;&#10;####  GPU Queue (GPU等待队列)&#10;- **Waiting**: 当前等待分配到GPU节点的任务数量&#10;- **Max**: 等待队列的历史最大长度&#10;&#10;####  GPU Compute (GPU计算节点)&#10;- **Queue**: 当前队列中的任务数量&#10;- **Busy**: 繁忙节点数 / 总节点数（根据配置）&#10;- **Max**: 队列的历史最大长度&#10;- **Utilization**: GPU节点利用率百分比&#10;- **Served**: 已服务完成的任务总数&#10;&#10;####  Result Storage (结果存储)&#10;- **Queue**: 当前队列中等待的任务数量&#10;- **Busy**: 繁忙服务器数 / 总服务器数 (1个服务器)&#10;- **Max**: 仿真过程中队列的最大长度&#10;- **Utilization**: 服务器利用率百分比&#10;&#10;**作用**:&#10;-  **识别瓶颈**: 哪个队列最长？哪个服务点利用率最高？&#10;- ⚡ **优化资源**: 根据利用率决定是否需要增加/减少服务器&#10;-  **实时监控**: 观察系统运行状态，发现异常&#10;&#10;**利用率解读**:&#10;- `&lt; 30%` →  资源闲置，可能配置过多&#10;- `30% - 90%` → ✅ 资源利用良好，系统平衡&#10;- `&gt; 90%` → ⚠️ 资源过载，建议增加服务器&#10;&#10;---&#10;&#10;### 3. User Type Statistics (用户类型统计)&#10;&#10;**含义**: 按用户类型分析任务完成情况和服务质量&#10;&#10;**用户类型说明**:&#10;1. ** NORMAL (普通用户)** - 优先级最低&#10;2. **⭐ PERSONAL_VIP (个人VIP)** - 优先级中等&#10;3. **⭐⭐ ENTERPRISE_VIP (企业VIP)** - 优先级最高&#10;&#10;**显示内容**:&#10;&#10;####  NORMAL Users&#10;- **Completed**: 完成的任务数量&#10;- **百分比**: 占总完成任务的比例&#10;- **Avg System Time**: 该类型用户的平均系统时间&#10;&#10;#### ⭐ PERSONAL VIP&#10;- **Completed**: 完成的任务数量&#10;- **百分比**: 占总完成任务的比例&#10;- **Avg System Time**: 该类型用户的平均系统时间&#10;&#10;#### ⭐⭐ ENTERPRISE VIP&#10;- **Completed**: 完成的任务数量&#10;- **百分比**: 占总完成任务的比例&#10;- **Avg System Time**: 该类型用户的平均系统时间&#10;&#10;####  Priority Effect (优先级效果)&#10;- 显示企业VIP相比普通用户的速度提升百分比&#10;- 验证优先级策略是否有效&#10;&#10;**作用**:&#10;- ✅ 验证VIP优先级策略效果&#10;-  分析不同用户群体的服务质量差异&#10;-  评估差异化定价策略的合理性&#10;-  向客户展示VIP服务的价值&#10;&#10;**示例输出**:&#10;```&#10; NORMAL Users:&#10;   Completed: 150 (50.0%)&#10;   Avg System Time: 18.45s&#10;&#10;⭐ PERSONAL VIP:&#10;   Completed: 90 (30.0%)&#10;   Avg System Time: 12.23s&#10;&#10;⭐⭐ ENTERPRISE VIP:&#10;   Completed: 60 (20.0%)&#10;   Avg System Time: 8.76s&#10;&#10; Priority Effect:&#10;   Enterprise VIP is 52.5% faster&#10;```&#10;&#10;---&#10;&#10;### 4. Task Type Statistics (任务类型统计)&#10;&#10;**含义**: 按任务类型分析处理情况和资源使用&#10;&#10;**任务类型说明**:&#10;1. ** CPU Tasks** - 需要CPU节点处理的计算任务&#10;2. ** GPU Tasks** - 需要GPU节点处理的图形/深度学习任务&#10;&#10;**显示内容**:&#10;&#10;####  CPU Tasks&#10;- **Completed**: 完成的CPU任务数量&#10;- **百分比**: 占总完成任务的比例&#10;- **Avg System Time**: CPU任务的平均系统时间&#10;- **Node Utilization**: CPU节点的利用率百分比&#10;&#10;####  GPU Tasks&#10;- **Completed**: 完成的GPU任务数量&#10;- **百分比**: 占总完成任务的比例&#10;- **Avg System Time**: GPU任务的平均系统时间&#10;- **Node Utilization**: GPU节点的利用率百分比&#10;&#10;#### ⚡ Resource Efficiency (资源效率分析)&#10;自动分析资源使用效率并给出建议：&#10;- ✅ **节点平衡** (30%-90% 利用率) - 资源配置合理&#10;- ⚠️ **节点过载** (&gt;90% 利用率) - 建议增加节点数量&#10;-  **节点闲置** (&lt;30% 利用率) - 建议减少节点或增加负载&#10;&#10;**作用**:&#10;-  评估CPU/GPU资源使用效率&#10;-  优化硬件配置和成本&#10;-  指导资源调整决策&#10;-  平衡不同类型任务的处理能力&#10;&#10;**示例输出**:&#10;```&#10; CPU Tasks:&#10;   Completed: 210 (70.0%)&#10;   Avg System Time: 15.23s&#10;   Node Utilization: 85.3%&#10;&#10; GPU Tasks:&#10;   Completed: 90 (30.0%)&#10;   Avg System Time: 16.45s&#10;   Node Utilization: 45.7%&#10;&#10;⚡ Resource Efficiency:&#10;   ✅ CPU nodes balanced&#10;    GPU nodes underutilized&#10;```&#10;&#10;---&#10;&#10;## ⚙️ 底部配置面板详细说明&#10;&#10;### Mean Arrival Interval (平均到达间隔)&#10;&#10;**范围**: 通常 0.1 - 10.0 秒&#10;&#10;**含义**: 任务到达系统的平均时间间隔&#10;&#10;**调整效果**:&#10;- **减小** (例如 2.0 → 0.5)&#10;  - 任务到达更频繁&#10;  - 系统负载增加&#10;  - 队列会变长&#10;  - 平均系统时间会增加&#10;  - 可能观察到系统过载现象&#10;  &#10;- **增大** (例如 2.0 → 5.0)&#10;  - 任务到达更稀疏&#10;  - 系统负载降低&#10;  - 队列较短或为空&#10;  - 平均系统时间减少&#10;  - 服务器可能闲置&#10;&#10;**实际意义**: 模拟不同时段的用户访问量（高峰期 vs 低谷期）&#10;&#10;**建议值**: &#10;- 高负载测试：0.5 - 1.0s&#10;- 正常负载：1.5 - 3.0s&#10;- 轻负载：4.0 - 10.0s&#10;&#10;---&#10;&#10;### Simulation Time (仿真时间)&#10;&#10;**范围**: 100 - 10000 秒&#10;&#10;**含义**: 仿真运行的总时长&#10;&#10;**调整效果**:&#10;- **短时间** (例如 100s)&#10;  - 快速获得结果&#10;  - 但可能样本不足，统计不稳定&#10;  &#10;- **长时间** (例如 5000s)&#10;  - 更准确的统计结果&#10;  - 可以观察系统的长期行为&#10;  - 但运行时间更长&#10;&#10;**实际意义**: 平衡仿真精度和运行时间&#10;&#10;**建议值**:&#10;- 快速测试：100 - 500s&#10;- 标准仿真：1000 - 2000s&#10;- 详细分析：3000 - 5000s&#10;&#10;---&#10;&#10;### CPU Nodes (CPU节点数)&#10;&#10;**范围**: 通常 1 - 10&#10;&#10;**含义**: 系统中CPU服务器的数量&#10;&#10;**调整效果**:&#10;- **增加** (例如 2 → 4)&#10;  - CPU任务处理能力提升&#10;  - CPU队列等待时间减少&#10;  - 整体吞吐量增加（如果CPU是瓶颈）&#10;  - 但增加硬件成本&#10;  &#10;- **减少** (例如 2 → 1)&#10;  - CPU任务处理能力下降&#10;  - CPU队列变长&#10;  - 可能成为系统瓶颈&#10;&#10;**实际意义**: 评估硬件投资（增加服务器）对性能提升的效果&#10;&#10;**建议**:&#10;- 观察CPU Compute的利用率&#10;- 如果 &gt;90%，考虑增加节点&#10;- 如果 &lt;30%，考虑减少节点&#10;&#10;---&#10;&#10;### GPU Nodes (GPU节点数)&#10;&#10;**范围**: 通常 1 - 5&#10;&#10;**含义**: 系统中GPU服务器的数量&#10;&#10;**调整效果**: 与CPU Nodes类似，但针对GPU任务&#10;&#10;**实际意义**: &#10;- GPU硬件成本通常更高&#10;- 需要更谨慎地评估配置需求&#10;&#10;**建议**:&#10;- 观察GPU Compute的利用率&#10;- 根据GPU任务比例调整&#10;- 考虑成本-性能平衡&#10;&#10;---&#10;&#10;### CPU Task Probability (CPU任务概率)&#10;&#10;**范围**: 0.0 - 1.0（例如 0.7 = 70%）&#10;&#10;**含义**: 新到达任务是CPU任务的概率&#10;&#10;**调整效果**:&#10;- **0.7** = 70% CPU任务，30% GPU任务&#10;- **0.9** = 90% CPU任务，10% GPU任务&#10;  - CPU队列压力大&#10;  - GPU资源可能闲置&#10;  - 需要更多CPU节点&#10;  &#10;- **0.3** = 30% CPU任务，70% GPU任务&#10;  - GPU队列压力大&#10;  - CPU资源可能闲置&#10;  - 需要更多GPU节点&#10;&#10;**实际意义**: &#10;- 模拟不同应用场景的任务分布&#10;- 普通Web服务：高CPU概率 (0.8-0.9)&#10;- AI/机器学习：低CPU概率 (0.2-0.4)&#10;- 混合场景：中等概率 (0.5-0.7)&#10;&#10;**建议**:&#10;- 根据实际业务场景设置&#10;- 观察两种资源的利用率平衡&#10;&#10;---&#10;&#10;### Database连接和功能&#10;&#10;#### Database Status (数据库状态)&#10;&#10;**显示内容**:&#10;- ✅ **Connected** - 数据库连接成功&#10;- ❌ **Not Connected** - 数据库未连接&#10;&#10;#### Test 按钮&#10;&#10;**功能**: 测试数据库连接&#10;&#10;**点击后的效果**:&#10;1. 尝试连接到MariaDB数据库&#10;2. 测试数据库中的表是否存在&#10;3. 更新连接状态标签&#10;&#10;**成功时**:&#10;- 标签变为：`✅ Connected` (绿色)&#10;- 弹出信息框：`Database connection successful!`&#10;- 可以使用数据库功能&#10;&#10;**失败时**:&#10;- 标签保持：`❌ Not Connected` (红色)&#10;- 弹出错误框：显示具体错误信息&#10;- 数据库相关功能不可用&#10;&#10;#### 数据库功能（需要连接成功）&#10;&#10;** Save Config (保存配置)**&#10;- 将当前仿真配置保存到数据库&#10;- 可以为配置命名&#10;- 方便后续重复使用&#10;&#10;** Load Config (加载配置)**&#10;- 从数据库加载已保存的配置&#10;- 选择配置名称&#10;- 自动填充所有参数&#10;&#10;** View History (查看历史)**&#10;- 在底部表格中显示历史仿真记录&#10;- 包含运行时间、完成任务数、吞吐量等&#10;- 可以对比不同配置的效果&#10;&#10;---&#10;&#10;##  控制按钮说明&#10;&#10;### ▶️ Start (开始)&#10;- 使用当前配置开始新的仿真&#10;- 初始化所有统计数据&#10;- 创建数据库记录（如果连接）&#10;&#10;### ⏸ Pause (暂停)&#10;- 暂停仿真运行&#10;- 保持当前状态&#10;- 可以观察统计数据&#10;&#10;### ▶️ Resume (继续)&#10;- 从暂停状态继续运行&#10;- 保持之前的统计数据&#10;&#10;### ⏹ Stop (停止)&#10;- 停止仿真运行&#10;- 保存结果到数据库（如果连接）&#10;- 显示最终统计结果&#10;&#10;###  Reset (重置)&#10;- 重置仿真到初始状态&#10;- 清空所有统计数据&#10;- 保持当前配置参数&#10;&#10;###  Speed Control (速度控制)&#10;- 滑块范围：0.1x - 100x&#10;- 调整仿真运行速度&#10;- 1x = 实时速度&#10;- 100x = 快速仿真（用于快速获得结果）&#10;- 0.1x = 慢速仿真（用于详细观察）&#10;&#10;---&#10;&#10;##  基本使用流程&#10;&#10;### 1. 配置参数&#10;1. 在底部面板设置仿真参数：&#10;   - Mean Arrival Interval&#10;   - Simulation Time&#10;   - CPU/GPU Nodes&#10;   - CPU Task Probability&#10;&#10;### 2. 开始仿真&#10;1. 点击 ▶️ Start 按钮&#10;2. 观察中央可视化区域的动画&#10;3. 观察右侧统计面板的实时数据&#10;&#10;### 3. 控制仿真&#10;- 使用 ⏸ Pause 暂停观察&#10;- 使用 ▶️ Resume 继续&#10;- 调整  Speed 控制速度&#10;&#10;### 4. 分析结果&#10;1. 查看 Overall Statistics - 了解整体性能&#10;2. 查看 Queue Statistics - 识别瓶颈&#10;3. 查看 User Type Statistics - 验证优先级策略&#10;4. 查看 Task Type Statistics - 评估资源使用&#10;&#10;### 5. 优化配置&#10;1. 根据统计结果调整参数&#10;2. 重新运行仿真&#10;3. 对比不同配置的效果&#10;&#10;### 6. 保存结果（可选）&#10;1. 确保数据库连接&#10;2. 使用  Save Config 保存优秀配置&#10;3. 查看  History 对比历史数据&#10;&#10;---&#10;&#10;##  使用技巧&#10;&#10;### 快速测试&#10;1. 设置较短的 Simulation Time (100-500s)&#10;2. 提高 Speed 到 10x - 50x&#10;3. 快速获得初步结果&#10;&#10;### 详细分析&#10;1. 设置较长的 Simulation Time (2000-5000s)&#10;2. 使用正常 Speed (1x - 5x)&#10;3. 仔细观察各项指标变化&#10;&#10;### 识别瓶颈&#10;1. 运行仿真&#10;2. 观察 Queue Statistics&#10;3. 找到利用率 &gt;90% 或队列最长的服务点&#10;4. 调整相应资源配置&#10;&#10;### 参数优化&#10;1. **每次只改变一个参数**&#10;2. 记录每次的关键指标&#10;3. 对比找出最优配置&#10;4. 使用 Save Config 保存&#10;&#10;### 对比实验&#10;1. 保存多个不同配置&#10;2. 依次运行&#10;3. 记录关键指标&#10;4. 制作对比表格&#10;&#10;---&#10;&#10;## ⚠️ 常见问题&#10;&#10;### Q1: 统计面板没有数据？&#10;**A**: 需要点击 Start 开始仿真后才会有数据更新&#10;&#10;### Q2: 数据库连接失败？&#10;**A**: 检查 `database.properties` 文件，确保用户名密码正确，MariaDB服务正在运行&#10;&#10;### Q3: 仿真运行很慢？&#10;**A**: 调高 Speed 滑块，或者减少 Simulation Time&#10;&#10;### Q4: 如何判断系统性能好坏？&#10;**A**: 主要看两个指标：&#10;- Avg System Time - 越小越好&#10;- Throughput - 越大越好&#10;&#10;### Q5: 利用率多少算合理？&#10;**A**: 30%-90% 为合理范围，&gt;90% 过载，&lt;30% 浪费&#10;&#10;---&#10;&#10;##  下一步&#10;&#10;查看 **SCENARIO_GUIDE.md** 了解具体应用场景和实战案例！&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/simulation/model/ServicePoint.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/simulation/model/ServicePoint.java" />
              <option name="originalContent" value="package com.simulation.model;&#10;import com.simulation.util.RandomGenerator;&#10;import java.util.*;&#10;public class ServicePoint {&#10;    private final String name;&#10;    private final int numServers;&#10;    private final double meanServiceTime;&#10;    private final Queue&lt;Task&gt; queue;&#10;    private int busyServers, tasksServed, maxQueueLength;&#10;    private double totalServiceTime;&#10;    public ServicePoint(String name, int numServers, double meanServiceTime, boolean usePriorityQueue) {&#10;        this.name = name;&#10;        this.numServers = numServers;&#10;        this.meanServiceTime = meanServiceTime;&#10;        this.queue = usePriorityQueue ? new PriorityQueue&lt;&gt;() : new LinkedList&lt;&gt;();&#10;    }&#10;    public void addToQueue(Task task) {&#10;        queue.add(task);&#10;        if (queue.size() &gt; maxQueueLength) maxQueueLength = queue.size();&#10;    }&#10;    public boolean isAvailable() { return busyServers &lt; numServers; }&#10;    public boolean isQueueEmpty() { return queue.isEmpty(); }&#10;    public Task beginService(double currentTime) {&#10;        if (queue.isEmpty() || !isAvailable()) return null;&#10;        busyServers++;&#10;        return queue.poll();&#10;    }&#10;    public double getServiceTime() {&#10;        double serviceTime = RandomGenerator.exponential(meanServiceTime);&#10;        totalServiceTime += serviceTime;&#10;        return serviceTime;&#10;    }&#10;    public void endService() {&#10;        if (busyServers &gt; 0) { busyServers--; tasksServed++; }&#10;    }&#10;    public String getName() { return name; }&#10;    public int getQueueLength() { return queue.size(); }&#10;    public int getBusyServers() { return busyServers; }&#10;    public int getTasksServed() { return tasksServed; }&#10;    public int getMaxQueueLength() { return maxQueueLength; }&#10;    public double getUtilization(double totalTime) {&#10;        return (totalTime &gt; 0 &amp;&amp; numServers &gt; 0) ? totalServiceTime / (totalTime * numServers) : 0;&#10;    }&#10;    public double getAverageServiceTime() { return tasksServed &gt; 0 ? totalServiceTime / tasksServed : 0; }&#10;    public double getAverageQueueTime() { return 0; }&#10;    public void reset() {&#10;        queue.clear();&#10;        busyServers = 0;&#10;        tasksServed = 0;&#10;        totalServiceTime = 0;&#10;        maxQueueLength = 0;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.simulation.model;&#10;import com.simulation.util.RandomGenerator;&#10;import java.util.*;&#10;&#10;/**&#10; * Represents a service point or queue in the simulation system.&#10; * Can function as either:&#10; * 1. Pure Queue: Just holds tasks waiting (e.g., CPU Queue, GPU Queue)&#10; * 2. Service Point: Processes tasks with servers (e.g., Data Storage, CPU Compute)&#10; */&#10;public class ServicePoint {&#10;    private final String name;&#10;    private final int numServers;&#10;    private final double meanServiceTime;&#10;    private final Queue&lt;Task&gt; queue;&#10;    private final boolean isPureQueue; // True for queues without service processing&#10;&#10;    private int busyServers;&#10;    private int tasksServed;&#10;    private int maxQueueLength;&#10;    private double totalBusyTime; // Total time servers have been busy&#10;    private double lastUpdateTime; // Last time utilization was updated&#10;&#10;    /**&#10;     * Constructor for service points with processing capability&#10;     */&#10;    public ServicePoint(String name, int numServers, double meanServiceTime, boolean usePriorityQueue) {&#10;        this.name = name;&#10;        this.numServers = numServers;&#10;        this.meanServiceTime = meanServiceTime;&#10;        this.queue = usePriorityQueue ? new PriorityQueue&lt;&gt;() : new LinkedList&lt;&gt;();&#10;        this.isPureQueue = (meanServiceTime == 0); // If service time is 0, it's a pure queue&#10;        this.lastUpdateTime = 0;&#10;    }&#10;&#10;    public void addToQueue(Task task) {&#10;        queue.add(task);&#10;        if (queue.size() &gt; maxQueueLength) maxQueueLength = queue.size();&#10;    }&#10;&#10;    /**&#10;     * Remove task from queue without starting service (for pure queues)&#10;     */&#10;    public Task removeFromQueue() {&#10;        return queue.isEmpty() ? null : queue.poll();&#10;    }&#10;&#10;    public boolean isAvailable() {&#10;        return busyServers &lt; numServers;&#10;    }&#10;&#10;    public boolean isQueueEmpty() {&#10;        return queue.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Start service by marking a server as busy (for service points without their own queue)&#10;     */&#10;    public void startService(double currentTime) {&#10;        if (busyServers &lt; numServers) {&#10;            updateUtilizationTracking(currentTime);&#10;            busyServers++;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Begin service by taking task from own queue (for service points with queue)&#10;     */&#10;    public Task beginService(double currentTime) {&#10;        if (queue.isEmpty() || !isAvailable()) return null;&#10;        updateUtilizationTracking(currentTime);&#10;        busyServers++;&#10;        return queue.poll();&#10;    }&#10;&#10;    /**&#10;     * Generate service time and track it for utilization calculation&#10;     */&#10;    public double getServiceTime() {&#10;        return RandomGenerator.exponential(meanServiceTime);&#10;    }&#10;&#10;    /**&#10;     * End service and update statistics&#10;     */&#10;    public void endService(double currentTime) {&#10;        if (busyServers &gt; 0) {&#10;            updateUtilizationTracking(currentTime);&#10;            busyServers--;&#10;            tasksServed++;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update the busy time tracking for accurate utilization calculation&#10;     */&#10;    private void updateUtilizationTracking(double currentTime) {&#10;        if (!isPureQueue &amp;&amp; currentTime &gt; lastUpdateTime) {&#10;            totalBusyTime += busyServers * (currentTime - lastUpdateTime);&#10;            lastUpdateTime = currentTime;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Calculate utilization based on actual busy time&#10;     */&#10;    public double getUtilization(double currentTime) {&#10;        if (isPureQueue || numServers == 0 || currentTime &lt;= 0) {&#10;            return 0.0;&#10;        }&#10;&#10;        // Update to current time before calculating&#10;        updateUtilizationTracking(currentTime);&#10;&#10;        // Utilization = total busy time / (simulation time * number of servers)&#10;        double totalCapacityTime = currentTime * numServers;&#10;        return totalCapacityTime &gt; 0 ? totalBusyTime / totalCapacityTime : 0.0;&#10;    }&#10;&#10;    public String getName() { return name; }&#10;    public int getQueueLength() { return queue.size(); }&#10;    public int getBusyServers() { return busyServers; }&#10;    public int getTasksServed() { return tasksServed; }&#10;    public int getMaxQueueLength() { return maxQueueLength; }&#10;    public boolean isPureQueue() { return isPureQueue; }&#10;&#10;    public double getAverageServiceTime() { &#10;        return tasksServed &gt; 0 ? (totalBusyTime / tasksServed) : 0; &#10;    }&#10;    &#10;    /**&#10;     * Get average queue time (not yet implemented, returns 0)&#10;     * TODO: Implement proper queue time tracking&#10;     */&#10;    public double getAverageQueueTime() {&#10;        return 0.0;&#10;    }&#10;    &#10;    public void reset() {&#10;        queue.clear();&#10;        busyServers = 0;&#10;        tasksServed = 0;&#10;        totalBusyTime = 0;&#10;        maxQueueLength = 0;&#10;        lastUpdateTime = 0;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/simulation/model/SimulationEngine.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/simulation/model/SimulationEngine.java" />
              <option name="originalContent" value="package com.simulation.model;&#10;import com.simulation.util.RandomGenerator;&#10;public class SimulationEngine extends Thread {&#10;    private final SimulationConfig config;&#10;    private final SimulationResults results;&#10;    private final EventList eventList;&#10;    private final Clock clock;&#10;    private ServicePoint dataStorage, classification, cpuQueue, gpuQueue, cpuCompute, gpuCompute, resultStorage;&#10;    private volatile boolean running, paused;&#10;    private volatile double speedMultiplier = 1.0;&#10;    private final Object pauseLock = new Object();&#10;    private SimulationListener listener;&#10;    /**&#10;     * Listener interface for simulation events&#10;     */&#10;    public interface SimulationListener {&#10;        void onTimeUpdate(double time);&#10;        void onSimulationComplete();&#10;        default void onSimulationUpdate() {&#10;            onTimeUpdate(Clock.getInstance().getTime());&#10;        }&#10;    }&#10;    public SimulationEngine(SimulationConfig config) {&#10;        this.config = config;&#10;        this.results = new SimulationResults();&#10;        this.eventList = new EventList();&#10;        this.clock = Clock.getInstance();&#10;        initializeServicePoints();&#10;    }&#10;    private void initializeServicePoints() {&#10;        dataStorage = new ServicePoint(&quot;Data Storage&quot;, 1, config.getDataStorageServiceTime(), false);&#10;        classification = new ServicePoint(&quot;Classification&quot;, 1, config.getClassificationServiceTime(), false);&#10;        cpuQueue = new ServicePoint(&quot;CPU Queue&quot;, Integer.MAX_VALUE, 0, true);&#10;        gpuQueue = new ServicePoint(&quot;GPU Queue&quot;, Integer.MAX_VALUE, 0, true);&#10;        cpuCompute = new ServicePoint(&quot;CPU Compute&quot;, config.getNumCpuNodes(), config.getCpuComputeServiceTime(), false);&#10;        gpuCompute = new ServicePoint(&quot;GPU Compute&quot;, config.getNumGpuNodes(), config.getGpuComputeServiceTime(), false);&#10;        resultStorage = new ServicePoint(&quot;Result Storage&quot;, 1, config.getResultStorageServiceTime(), false);&#10;    }&#10;    public void setListener(SimulationListener listener) {&#10;        this.listener = listener;&#10;    }&#10;    public void setSpeed(double speed) {&#10;        this.speedMultiplier = Math.max(0.1, Math.min(100.0, speed));&#10;    }&#10;    public void initialize() {&#10;        clock.reset();&#10;        eventList.clear();&#10;        results.reset();&#10;        dataStorage.reset(); classification.reset(); cpuQueue.reset(); gpuQueue.reset();&#10;        cpuCompute.reset(); gpuCompute.reset(); resultStorage.reset();&#10;        scheduleNextArrival();&#10;    }&#10;    private void scheduleNextArrival() {&#10;        double arrivalTime = clock.getTime() + RandomGenerator.exponential(config.getMeanArrivalInterval());&#10;        if (arrivalTime &lt;= config.getSimulationTime()) {&#10;            TaskType taskType = RandomGenerator.bernoulli(config.getCpuTaskProbability()) ? TaskType.CPU : TaskType.GPU;&#10;            UserType userType = generateUserType();&#10;            Task task = new Task(taskType, userType, arrivalTime);&#10;            eventList.addEvent(new Event(EventType.ARRIVAL, arrivalTime, task));&#10;        }&#10;    }&#10;    private UserType generateUserType() {&#10;        double rand = Math.random();&#10;        if (rand &lt; config.getNormalUserProbability()) return UserType.NORMAL;&#10;        else if (rand &lt; config.getNormalUserProbability() + config.getPersonalVipProbability()) return UserType.PERSONAL_VIP;&#10;        else return UserType.ENTERPRISE_VIP;&#10;    }&#10;    @Override&#10;    public void run() {&#10;        running = true;&#10;        double previousTime = 0.0;&#10;&#10;        while (running &amp;&amp; eventList.hasEvents() &amp;&amp; clock.getTime() &lt;= config.getSimulationTime()) {&#10;            synchronized (pauseLock) {&#10;                while (paused &amp;&amp; running) {&#10;                    try { pauseLock.wait(); } catch (InterruptedException e) { return; }&#10;                }&#10;            }&#10;            if (!running) break;&#10;            Event event = eventList.getNextEvent();&#10;            if (event != null) {&#10;                double targetTime = event.getTime();&#10;                double timeElapsed = targetTime - previousTime;&#10;&#10;                // Sleep proportional to simulated time elapsed, but break into small chunks&#10;                // for smooth time display updates&#10;                // At 1x speed: 1 simulated second = 1 real second (1000ms)&#10;                // At 2x speed: 1 simulated second = 0.5 real seconds (500ms)&#10;                if (timeElapsed &gt; 0) {&#10;                    // Capture current speed to avoid inconsistency if slider is adjusted during sleep&#10;                    double currentSpeed = speedMultiplier;&#10;                    long totalSleepTime = (long)(timeElapsed * 1000.0 / currentSpeed);&#10;                    long sleepChunk = 50; // Update UI every 50ms for smooth display&#10;                    long initialSleepTime = totalSleepTime;&#10;&#10;                    // Break the sleep into small chunks and update time progressively&#10;                    while (totalSleepTime &gt; 0 &amp;&amp; running &amp;&amp; !paused) {&#10;                        long currentSleep = Math.min(sleepChunk, totalSleepTime);&#10;                        try {&#10;                            Thread.sleep(currentSleep);&#10;                        } catch (InterruptedException e) {&#10;                            return;&#10;                        }&#10;&#10;                        // Update clock progressively for smooth display&#10;                        // Use initial sleep time to calculate consistent progress&#10;                        double progress = (double)(initialSleepTime - totalSleepTime + currentSleep) / initialSleepTime;&#10;                        double intermediateTime = previousTime + (timeElapsed * progress);&#10;                        clock.setTime(intermediateTime);&#10;&#10;                        if (listener != null) listener.onTimeUpdate(clock.getTime());&#10;&#10;                        totalSleepTime -= currentSleep;&#10;                    }&#10;                }&#10;&#10;                clock.setTime(targetTime);&#10;                processEvent(event);&#10;                previousTime = targetTime;&#10;&#10;                if (listener != null) listener.onTimeUpdate(clock.getTime());&#10;            }&#10;        }&#10;        running = false;&#10;        results.setTotalSimulationTime(clock.getTime());&#10;        if (listener != null) listener.onSimulationComplete();&#10;    }&#10;    private void processEvent(Event event) {&#10;        Task task = event.getTask();&#10;        switch (event.getType()) {&#10;            case ARRIVAL: handleArrival(task); break;&#10;            case DEP_DATA_STORAGE: handleDepartureDataStorage(task); break;&#10;            case DEP_CLASSIFICATION: handleDepartureClassification(task); break;&#10;            case DEP_CPU_COMPUTE: handleDepartureCpuCompute(task); break;&#10;            case DEP_GPU_COMPUTE: handleDepartureGpuCompute(task); break;&#10;            case DEP_RESULT_STORAGE: handleDepartureResultStorage(task); break;&#10;        }&#10;    }&#10;    private void handleArrival(Task task) {&#10;        results.recordArrival();&#10;        dataStorage.addToQueue(task);&#10;        if (dataStorage.isAvailable()) startServiceDataStorage();&#10;        scheduleNextArrival();&#10;    }&#10;    private void startServiceDataStorage() {&#10;        Task task = dataStorage.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = dataStorage.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_DATA_STORAGE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureDataStorage(Task task) {&#10;        dataStorage.endService();&#10;        classification.addToQueue(task);&#10;        if (classification.isAvailable()) startServiceClassification();&#10;        if (dataStorage.isAvailable() &amp;&amp; !dataStorage.isQueueEmpty()) startServiceDataStorage();&#10;    }&#10;    private void startServiceClassification() {&#10;        Task task = classification.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = classification.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_CLASSIFICATION, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureClassification(Task task) {&#10;        classification.endService();&#10;        if (task.getTaskType() == TaskType.CPU) {&#10;            cpuQueue.addToQueue(task);&#10;            if (cpuCompute.isAvailable()) startServiceCpuCompute();&#10;        } else {&#10;            gpuQueue.addToQueue(task);&#10;            if (gpuCompute.isAvailable()) startServiceGpuCompute();&#10;        }&#10;        if (classification.isAvailable() &amp;&amp; !classification.isQueueEmpty()) startServiceClassification();&#10;    }&#10;    private void startServiceCpuCompute() {&#10;        Task task = cpuQueue.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = cpuCompute.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_CPU_COMPUTE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void startServiceGpuCompute() {&#10;        Task task = gpuQueue.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = gpuCompute.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_GPU_COMPUTE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureCpuCompute(Task task) {&#10;        cpuCompute.endService();&#10;        resultStorage.addToQueue(task);&#10;        if (resultStorage.isAvailable()) startServiceResultStorage();&#10;        if (cpuCompute.isAvailable() &amp;&amp; !cpuQueue.isQueueEmpty()) startServiceCpuCompute();&#10;    }&#10;    private void handleDepartureGpuCompute(Task task) {&#10;        gpuCompute.endService();&#10;        resultStorage.addToQueue(task);&#10;        if (resultStorage.isAvailable()) startServiceResultStorage();&#10;        if (gpuCompute.isAvailable() &amp;&amp; !gpuQueue.isQueueEmpty()) startServiceGpuCompute();&#10;    }&#10;    private void startServiceResultStorage() {&#10;        Task task = resultStorage.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = resultStorage.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_RESULT_STORAGE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureResultStorage(Task task) {&#10;        resultStorage.endService();&#10;        task.setCompletionTime(clock.getTime());&#10;        results.recordCompletion(task);&#10;        if (resultStorage.isAvailable() &amp;&amp; !resultStorage.isQueueEmpty()) startServiceResultStorage();&#10;    }&#10;    public boolean isRunning() {&#10;        return running;&#10;    }&#10;&#10;    public boolean isPaused() {&#10;        return paused;&#10;    }&#10;&#10;    public void pauseSimulation() {&#10;        paused = true;&#10;    }&#10;&#10;    public void resumeSimulation() {&#10;        synchronized (pauseLock) {&#10;            paused = false;&#10;            pauseLock.notifyAll();&#10;        }&#10;    }&#10;&#10;    public void stopSimulation() {&#10;        running = false;&#10;        synchronized (pauseLock) {&#10;            pauseLock.notifyAll();&#10;        }&#10;    }&#10;&#10;    public void stepForward() {&#10;        if (paused &amp;&amp; eventList.hasEvents()) {&#10;            Event event = eventList.getNextEvent();&#10;            if (event != null) {&#10;                clock.setTime(event.getTime());&#10;                processEvent(event);&#10;                if (listener != null) listener.onTimeUpdate(clock.getTime());&#10;            }&#10;        }&#10;    }&#10;&#10;    public SimulationResults getResults() {&#10;        return results;&#10;    }&#10;    public ServicePoint getDataStorage() { return dataStorage; }&#10;    public ServicePoint getClassification() { return classification; }&#10;    public ServicePoint getCpuQueue() { return cpuQueue; }&#10;    public ServicePoint getGpuQueue() { return gpuQueue; }&#10;    public ServicePoint getCpuCompute() { return cpuCompute; }&#10;    public ServicePoint getGpuCompute() { return gpuCompute; }&#10;    public ServicePoint getResultStorage() { return resultStorage; }&#10;}&#10;" />
              <option name="updatedContent" value="package com.simulation.model;&#10;import com.simulation.util.RandomGenerator;&#10;public class SimulationEngine extends Thread {&#10;    private final SimulationConfig config;&#10;    private final SimulationResults results;&#10;    private final EventList eventList;&#10;    private final Clock clock;&#10;    private ServicePoint dataStorage, classification, cpuQueue, gpuQueue, cpuCompute, gpuCompute, resultStorage;&#10;    private volatile boolean running, paused;&#10;    private volatile double speedMultiplier = 1.0;&#10;    private final Object pauseLock = new Object();&#10;    private SimulationListener listener;&#10;    /**&#10;     * Listener interface for simulation events&#10;     */&#10;    public interface SimulationListener {&#10;        void onTimeUpdate(double time);&#10;        void onSimulationComplete();&#10;        default void onSimulationUpdate() {&#10;            onTimeUpdate(Clock.getInstance().getTime());&#10;        }&#10;    }&#10;    public SimulationEngine(SimulationConfig config) {&#10;        this.config = config;&#10;        this.results = new SimulationResults();&#10;        this.eventList = new EventList();&#10;        this.clock = Clock.getInstance();&#10;        initializeServicePoints();&#10;    }&#10;    private void initializeServicePoints() {&#10;        dataStorage = new ServicePoint(&quot;Data Storage&quot;, 1, config.getDataStorageServiceTime(), false);&#10;        classification = new ServicePoint(&quot;Classification&quot;, 1, config.getClassificationServiceTime(), false);&#10;        cpuQueue = new ServicePoint(&quot;CPU Queue&quot;, Integer.MAX_VALUE, 0, true);&#10;        gpuQueue = new ServicePoint(&quot;GPU Queue&quot;, Integer.MAX_VALUE, 0, true);&#10;        cpuCompute = new ServicePoint(&quot;CPU Compute&quot;, config.getNumCpuNodes(), config.getCpuComputeServiceTime(), false);&#10;        gpuCompute = new ServicePoint(&quot;GPU Compute&quot;, config.getNumGpuNodes(), config.getGpuComputeServiceTime(), false);&#10;        resultStorage = new ServicePoint(&quot;Result Storage&quot;, 1, config.getResultStorageServiceTime(), false);&#10;    }&#10;    public void setListener(SimulationListener listener) {&#10;        this.listener = listener;&#10;    }&#10;    public void setSpeed(double speed) {&#10;        this.speedMultiplier = Math.max(0.1, Math.min(100.0, speed));&#10;    }&#10;    public void initialize() {&#10;        clock.reset();&#10;        eventList.clear();&#10;        results.reset();&#10;        dataStorage.reset(); classification.reset(); cpuQueue.reset(); gpuQueue.reset();&#10;        cpuCompute.reset(); gpuCompute.reset(); resultStorage.reset();&#10;        scheduleNextArrival();&#10;    }&#10;    private void scheduleNextArrival() {&#10;        double arrivalTime = clock.getTime() + RandomGenerator.exponential(config.getMeanArrivalInterval());&#10;        if (arrivalTime &lt;= config.getSimulationTime()) {&#10;            TaskType taskType = RandomGenerator.bernoulli(config.getCpuTaskProbability()) ? TaskType.CPU : TaskType.GPU;&#10;            UserType userType = generateUserType();&#10;            Task task = new Task(taskType, userType, arrivalTime);&#10;            eventList.addEvent(new Event(EventType.ARRIVAL, arrivalTime, task));&#10;        }&#10;    }&#10;    private UserType generateUserType() {&#10;        double rand = Math.random();&#10;        if (rand &lt; config.getNormalUserProbability()) return UserType.NORMAL;&#10;        else if (rand &lt; config.getNormalUserProbability() + config.getPersonalVipProbability()) return UserType.PERSONAL_VIP;&#10;        else return UserType.ENTERPRISE_VIP;&#10;    }&#10;    @Override&#10;    public void run() {&#10;        running = true;&#10;        double previousTime = 0.0;&#10;&#10;        while (running &amp;&amp; eventList.hasEvents() &amp;&amp; clock.getTime() &lt;= config.getSimulationTime()) {&#10;            synchronized (pauseLock) {&#10;                while (paused &amp;&amp; running) {&#10;                    try { pauseLock.wait(); } catch (InterruptedException e) { return; }&#10;                }&#10;            }&#10;            if (!running) break;&#10;            Event event = eventList.getNextEvent();&#10;            if (event != null) {&#10;                double targetTime = event.getTime();&#10;                double timeElapsed = targetTime - previousTime;&#10;&#10;                // Sleep proportional to simulated time elapsed, but break into small chunks&#10;                // for smooth time display updates&#10;                // At 1x speed: 1 simulated second = 1 real second (1000ms)&#10;                // At 2x speed: 1 simulated second = 0.5 real seconds (500ms)&#10;                if (timeElapsed &gt; 0) {&#10;                    // Capture current speed to avoid inconsistency if slider is adjusted during sleep&#10;                    double currentSpeed = speedMultiplier;&#10;                    long totalSleepTime = (long)(timeElapsed * 1000.0 / currentSpeed);&#10;                    long sleepChunk = 50; // Update UI every 50ms for smooth display&#10;                    long initialSleepTime = totalSleepTime;&#10;&#10;                    // Break the sleep into small chunks and update time progressively&#10;                    while (totalSleepTime &gt; 0 &amp;&amp; running &amp;&amp; !paused) {&#10;                        long currentSleep = Math.min(sleepChunk, totalSleepTime);&#10;                        try {&#10;                            Thread.sleep(currentSleep);&#10;                        } catch (InterruptedException e) {&#10;                            return;&#10;                        }&#10;&#10;                        // Update clock progressively for smooth display&#10;                        // Use initial sleep time to calculate consistent progress&#10;                        double progress = (double)(initialSleepTime - totalSleepTime + currentSleep) / initialSleepTime;&#10;                        double intermediateTime = previousTime + (timeElapsed * progress);&#10;                        clock.setTime(intermediateTime);&#10;&#10;                        if (listener != null) listener.onTimeUpdate(clock.getTime());&#10;&#10;                        totalSleepTime -= currentSleep;&#10;                    }&#10;                }&#10;&#10;                clock.setTime(targetTime);&#10;                processEvent(event);&#10;                previousTime = targetTime;&#10;&#10;                if (listener != null) listener.onTimeUpdate(clock.getTime());&#10;            }&#10;        }&#10;        running = false;&#10;        results.setTotalSimulationTime(clock.getTime());&#10;        if (listener != null) listener.onSimulationComplete();&#10;    }&#10;    private void processEvent(Event event) {&#10;        Task task = event.getTask();&#10;        switch (event.getType()) {&#10;            case ARRIVAL: handleArrival(task); break;&#10;            case DEP_DATA_STORAGE: handleDepartureDataStorage(task); break;&#10;            case DEP_CLASSIFICATION: handleDepartureClassification(task); break;&#10;            case DEP_CPU_COMPUTE: handleDepartureCpuCompute(task); break;&#10;            case DEP_GPU_COMPUTE: handleDepartureGpuCompute(task); break;&#10;            case DEP_RESULT_STORAGE: handleDepartureResultStorage(task); break;&#10;        }&#10;    }&#10;    private void handleArrival(Task task) {&#10;        results.recordArrival();&#10;        dataStorage.addToQueue(task);&#10;        if (dataStorage.isAvailable()) startServiceDataStorage();&#10;        scheduleNextArrival();&#10;    }&#10;    private void startServiceDataStorage() {&#10;        Task task = dataStorage.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = dataStorage.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_DATA_STORAGE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureDataStorage(Task task) {&#10;        dataStorage.endService(clock.getTime());&#10;        classification.addToQueue(task);&#10;        if (classification.isAvailable()) startServiceClassification();&#10;        if (dataStorage.isAvailable() &amp;&amp; !dataStorage.isQueueEmpty()) startServiceDataStorage();&#10;    }&#10;    private void startServiceClassification() {&#10;        Task task = classification.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = classification.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_CLASSIFICATION, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureClassification(Task task) {&#10;        classification.endService(clock.getTime());&#10;        if (task.getTaskType() == TaskType.CPU) {&#10;            cpuQueue.addToQueue(task);&#10;            if (cpuCompute.isAvailable()) startServiceCpuCompute();&#10;        } else {&#10;            gpuQueue.addToQueue(task);&#10;            if (gpuCompute.isAvailable()) startServiceGpuCompute();&#10;        }&#10;        if (classification.isAvailable() &amp;&amp; !classification.isQueueEmpty()) startServiceClassification();&#10;    }&#10;    private void startServiceCpuCompute() {&#10;        Task task = cpuQueue.removeFromQueue();  // Remove from queue&#10;        if (task != null &amp;&amp; cpuCompute.isAvailable()) {&#10;            cpuCompute.startService(clock.getTime());  // Mark compute node as busy&#10;            double serviceTime = cpuCompute.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_CPU_COMPUTE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void startServiceGpuCompute() {&#10;        Task task = gpuQueue.removeFromQueue();  // Remove from queue&#10;        if (task != null &amp;&amp; gpuCompute.isAvailable()) {&#10;            gpuCompute.startService(clock.getTime());  // Mark compute node as busy&#10;            double serviceTime = gpuCompute.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_GPU_COMPUTE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureCpuCompute(Task task) {&#10;        cpuCompute.endService(clock.getTime());&#10;        resultStorage.addToQueue(task);&#10;        if (resultStorage.isAvailable()) startServiceResultStorage();&#10;        if (cpuCompute.isAvailable() &amp;&amp; !cpuQueue.isQueueEmpty()) startServiceCpuCompute();&#10;    }&#10;    private void handleDepartureGpuCompute(Task task) {&#10;        gpuCompute.endService(clock.getTime());&#10;        resultStorage.addToQueue(task);&#10;        if (resultStorage.isAvailable()) startServiceResultStorage();&#10;        if (gpuCompute.isAvailable() &amp;&amp; !gpuQueue.isQueueEmpty()) startServiceGpuCompute();&#10;    }&#10;    private void startServiceResultStorage() {&#10;        Task task = resultStorage.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = resultStorage.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_RESULT_STORAGE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureResultStorage(Task task) {&#10;        resultStorage.endService(clock.getTime());&#10;        task.setCompletionTime(clock.getTime());&#10;        results.recordCompletion(task);&#10;        if (resultStorage.isAvailable() &amp;&amp; !resultStorage.isQueueEmpty()) startServiceResultStorage();&#10;    }&#10;    public boolean isRunning() {&#10;        return running;&#10;    }&#10;&#10;    public boolean isPaused() {&#10;        return paused;&#10;    }&#10;&#10;    public void pauseSimulation() {&#10;        paused = true;&#10;    }&#10;&#10;    public void resumeSimulation() {&#10;        synchronized (pauseLock) {&#10;            paused = false;&#10;            pauseLock.notifyAll();&#10;        }&#10;    }&#10;&#10;    public void stopSimulation() {&#10;        running = false;&#10;        synchronized (pauseLock) {&#10;            pauseLock.notifyAll();&#10;        }&#10;    }&#10;&#10;    public void stepForward() {&#10;        if (paused &amp;&amp; eventList.hasEvents()) {&#10;            Event event = eventList.getNextEvent();&#10;            if (event != null) {&#10;                clock.setTime(event.getTime());&#10;                processEvent(event);&#10;                if (listener != null) listener.onTimeUpdate(clock.getTime());&#10;            }&#10;        }&#10;    }&#10;&#10;    public SimulationResults getResults() {&#10;        return results;&#10;    }&#10;    public ServicePoint getDataStorage() { return dataStorage; }&#10;    public ServicePoint getClassification() { return classification; }&#10;    public ServicePoint getCpuQueue() { return cpuQueue; }&#10;    public ServicePoint getGpuQueue() { return gpuQueue; }&#10;    public ServicePoint getCpuCompute() { return cpuCompute; }&#10;    public ServicePoint getGpuCompute() { return gpuCompute; }&#10;    public ServicePoint getResultStorage() { return resultStorage; }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>