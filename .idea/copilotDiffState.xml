<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/simulation/controller/SimulationController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/simulation/controller/SimulationController.java" />
              <option name="originalContent" value="package com.simulation.controller;&#10;&#10;import com.simulation.database.DatabaseManager;&#10;import com.simulation.database.SimulationConfigDAO;&#10;import com.simulation.database.SimulationResultsDAO;&#10;import com.simulation.model.*;&#10;import javafx.application.Platform;&#10;import javafx.beans.property.SimpleStringProperty;&#10;import javafx.collections.FXCollections;&#10;import javafx.fxml.FXML;&#10;import javafx.scene.canvas.Canvas;&#10;import javafx.scene.canvas.GraphicsContext;&#10;import javafx.scene.control.*;&#10;import javafx.scene.paint.Color;&#10;import javafx.stage.Stage;&#10;&#10;import java.sql.SQLException;&#10;import java.util.*;&#10;&#10;/**&#10; * FXML Controller that mediates between View and Model&#10; * Handles UI events and database operations&#10; */&#10;public class SimulationController {&#10;    // FXML Components&#10;    @FXML private Button startButton;&#10;    @FXML private Button pauseButton;&#10;    @FXML private Button resumeButton;&#10;    @FXML private Button stopButton;&#10;    @FXML private Button resetButton;&#10;&#10;    @FXML private Label timeLabel;&#10;    @FXML private Label speedLabel;&#10;    @FXML private Label arrivedTasksLabel;&#10;    @FXML private Label completedTasksLabel;&#10;    @FXML private Label avgSystemTimeLabel;&#10;    @FXML private Label throughputLabel;&#10;    @FXML private Label queueStatsLabel;&#10;    @FXML private Label userTypeStatsLabel;&#10;    @FXML private Label taskTypeStatsLabel;&#10;    @FXML private Label dbStatusLabel;&#10;&#10;    @FXML private TextField arrivalIntervalField;&#10;    @FXML private TextField simulationTimeField;&#10;    @FXML private TextField cpuNodesField;&#10;    @FXML private TextField gpuNodesField;&#10;    @FXML private TextField cpuProbabilityField;&#10;    @FXML private TextField resultStorageServiceTimeField;&#10;&#10;    @FXML private Slider speedSlider;&#10;    @FXML private Canvas visualizationCanvas;&#10;&#10;    @FXML private TableView&lt;Map&lt;String,Object&gt;&gt; historyTable;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; runIdColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; runNameColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; startTimeColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; endTimeColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; completedTasksColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; avgSystemTimeColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; throughputColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; statusColumn;&#10;&#10;&#10;&#10;    // Model components&#10;    private SimulationEngine engine;&#10;    private final SimulationConfig config;&#10;&#10;    // Database components&#10;    private final DatabaseManager dbManager;&#10;    private final SimulationConfigDAO configDAO;&#10;    private final SimulationResultsDAO resultsDAO;&#10;    private Integer currentRunId;&#10;&#10;    // UI update throttling&#10;    private long lastUpdateTime = 0;&#10;    private static final long UPDATE_INTERVAL_MS = 100; // Update UI every 100ms&#10;&#10;    public SimulationController() {&#10;        this.config = new SimulationConfig();&#10;        this.dbManager = DatabaseManager.getInstance();&#10;&#10;        // Initialize DAO objects, but they will handle database unavailability internally&#10;        SimulationConfigDAO tempConfigDAO = null;&#10;        SimulationResultsDAO tempResultsDAO = null;&#10;        try {&#10;            tempConfigDAO = new SimulationConfigDAO();&#10;            tempResultsDAO = new SimulationResultsDAO();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;⚠️  Could not initialize database DAOs: &quot; + e.getMessage());&#10;        }&#10;        this.configDAO = tempConfigDAO;&#10;        this.resultsDAO = tempResultsDAO;&#10;    }&#10;&#10;    /**&#10;     * Initialize method called after FXML loading&#10;     */&#10;    @FXML&#10;    public void initialize() {&#10;        // Setup speed slider listener&#10;        if (speedSlider != null) {&#10;            speedSlider.valueProperty().addListener((obs, oldVal, newVal) -&gt; {&#10;                double speed = newVal.doubleValue();&#10;                // Format speed display: show 1 decimal for &lt; 10x, integer for &gt;= 10x&#10;                if (speed &gt;= 10.0) {&#10;                    speedLabel.setText(String.format(&quot;%.0fx&quot;, speed));&#10;                } else {&#10;                    speedLabel.setText(String.format(&quot;%.1fx&quot;, speed));&#10;                }&#10;                if (engine != null) {&#10;                    engine.setSpeed(speed);&#10;                }&#10;            });&#10;        }&#10;&#10;        // Test database connection&#10;        testDatabaseConnection();&#10;&#10;        // Initialize canvas&#10;        if (visualizationCanvas != null) {&#10;            drawInitialCanvas();&#10;        }&#10;        // === Table column bindings ===&#10;        runIdColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;runId&quot;)))&#10;        );&#10;&#10;        runNameColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;runName&quot;)))&#10;        );&#10;&#10;        startTimeColumn.setCellValueFactory(cell -&gt; {&#10;            Object ts = cell.getValue().get(&quot;startTime&quot;);&#10;            return new SimpleStringProperty(ts == null ? &quot;&quot; : ts.toString());&#10;        });&#10;&#10;        endTimeColumn.setCellValueFactory(cell -&gt; {&#10;            Object ts = cell.getValue().get(&quot;endTime&quot;);&#10;            return new SimpleStringProperty(ts == null ? &quot;&quot; : ts.toString());&#10;        });&#10;&#10;        completedTasksColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;totalTasks&quot;)))&#10;        );&#10;&#10;        avgSystemTimeColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(&#10;                        String.format(&quot;%.3f&quot;,&#10;                                (double) cell.getValue().get(&quot;avgSystemTime&quot;))&#10;                )&#10;        );&#10;&#10;        throughputColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(&#10;                        String.format(&quot;%.3f&quot;,&#10;                                (double) cell.getValue().get(&quot;throughput&quot;))&#10;                )&#10;        );&#10;&#10;        statusColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;status&quot;)))&#10;        );&#10;&#10;        // Auto-load history on startup&#10;        loadHistoryData();&#10;    }&#10;&#10;&#10;        // ========== FXML Event Handlers ==========&#10;&#10;    @FXML&#10;    private void handleStart() {&#10;        updateConfigFromUI();&#10;        initializeSimulation();&#10;&#10;        // Apply current speed from slider to the new engine&#10;        if (engine != null &amp;&amp; speedSlider != null) {&#10;            engine.setSpeed(speedSlider.getValue());&#10;        }&#10;&#10;        // Create database run record&#10;        try {&#10;            currentRunId = resultsDAO.createSimulationRun(null,&#10;                &quot;Simulation Run &quot; + System.currentTimeMillis());&#10;        } catch (SQLException e) {&#10;            showError(&quot;Database Error&quot;, &quot;Failed to create run record: &quot; + e.getMessage());&#10;        }&#10;&#10;        startSimulation();&#10;        updateButtonStates(true);&#10;    }&#10;&#10;    @FXML&#10;    private void handlePause() {&#10;        pauseSimulation();&#10;        pauseButton.setDisable(true);&#10;        resumeButton.setDisable(false);&#10;    }&#10;&#10;    @FXML&#10;    private void handleResume() {&#10;        resumeSimulation();&#10;        pauseButton.setDisable(false);&#10;        resumeButton.setDisable(true);&#10;    }&#10;&#10;    @FXML&#10;    private void handleStop() {&#10;        stopSimulation();&#10;&#10;        // Save results to database&#10;        if (currentRunId != null) {&#10;            saveResultsToDatabase();&#10;        }&#10;&#10;        updateButtonStates(false);&#10;    }&#10;&#10;    @FXML&#10;    private void handleReset() {&#10;        stopSimulation();&#10;        initializeSimulation();&#10;&#10;        // Apply current speed from slider to the reset engine&#10;        if (engine != null &amp;&amp; speedSlider != null) {&#10;            engine.setSpeed(speedSlider.getValue());&#10;        }&#10;&#10;        updateStatistics();&#10;        updateButtonStates(false);&#10;    }&#10;&#10;    @FXML&#10;    private void handleSaveConfig() {&#10;        TextInputDialog dialog = new TextInputDialog(&quot;My Configuration&quot;);&#10;        dialog.setTitle(&quot;Save Configuration&quot;);&#10;        dialog.setHeaderText(&quot;Save current configuration to database&quot;);&#10;        dialog.setContentText(&quot;Configuration Name:&quot;);&#10;&#10;        Optional&lt;String&gt; result = dialog.showAndWait();&#10;        result.ifPresent(name -&gt; {&#10;            try {&#10;                updateConfigFromUI();&#10;                configDAO.saveConfig(config, name);&#10;                showInfo(&quot;Success&quot;, &quot;Configuration saved: &quot; + name);&#10;            } catch (SQLException e) {&#10;                showError(&quot;Error&quot;, &quot;Failed to save configuration: &quot; + e.getMessage());&#10;            }&#10;        });&#10;    }&#10;&#10;    @FXML&#10;    private void handleLoadConfig() {&#10;        try {&#10;            List&lt;String&gt; configNames = configDAO.getAllConfigNames();&#10;&#10;            ChoiceDialog&lt;String&gt; dialog = new ChoiceDialog&lt;&gt;(&#10;                configNames.isEmpty() ? null : configNames.get(0), configNames);&#10;            dialog.setTitle(&quot;Load Configuration&quot;);&#10;            dialog.setHeaderText(&quot;Load configuration from database&quot;);&#10;            dialog.setContentText(&quot;Select Configuration:&quot;);&#10;&#10;            Optional&lt;String&gt; result = dialog.showAndWait();&#10;            result.ifPresent(name -&gt; {&#10;                try {&#10;                    SimulationConfig loadedConfig = configDAO.loadConfigByName(name);&#10;                    if (loadedConfig != null) {&#10;                        copyConfig(loadedConfig, config);&#10;                        updateUIFromConfig();&#10;                        showInfo(&quot;Success&quot;, &quot;Configuration loaded: &quot; + name);&#10;                    }&#10;                } catch (SQLException e) {&#10;                    showError(&quot;Error&quot;, &quot;Failed to load configuration: &quot; + e.getMessage());&#10;                }&#10;            });&#10;        } catch (SQLException e) {&#10;            showError(&quot;Error&quot;, &quot;Failed to get configuration list: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Load history data from database and display in table&#10;     */&#10;    private void loadHistoryData() {&#10;        if (resultsDAO == null) {&#10;            System.out.println(&quot;⚠️  Database not available - cannot load history&quot;);&#10;            return;&#10;        }&#10;&#10;        try {&#10;            List&lt;Map&lt;String,Object&gt;&gt; runs = resultsDAO.getAllSimulationRuns();&#10;            System.out.println(&quot;✅ History loaded: &quot; + runs.size() + &quot; simulation runs found&quot;);&#10;&#10;            if (historyTable != null) {&#10;                historyTable.setItems(FXCollections.observableArrayList(runs));&#10;                historyTable.refresh();&#10;                System.out.println(&quot;✅ History table updated in UI&quot;);&#10;            } else {&#10;                System.err.println(&quot;⚠️  History table is null!&quot;);&#10;            }&#10;        } catch (SQLException e) {&#10;            System.err.println(&quot;❌ Failed to load history: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;❌ Unexpected error loading history: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    @FXML&#10;    private void handleViewHistory() {&#10;        System.out.println(&quot; View History button clicked!&quot;);&#10;        loadHistoryData();&#10;    }&#10;&#10;&#10;    @FXML&#10;    private void handleTestDatabase() {&#10;        testDatabaseConnection();&#10;    }&#10;&#10;    // ========== Simulation Control Methods ==========&#10;&#10;    public void initializeSimulation() {&#10;        if (engine != null &amp;&amp; engine.isAlive()) {&#10;            engine.stopSimulation();&#10;            try {&#10;                engine.join(1000);&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;&#10;        engine = new SimulationEngine(config);&#10;        engine.initialize();&#10;        setupSimulationListener();&#10;    }&#10;&#10;    public void startSimulation() {&#10;        if (engine != null &amp;&amp; !engine.isRunning()) {&#10;            engine.start();&#10;        }&#10;    }&#10;&#10;    public void pauseSimulation() {&#10;        if (engine != null) {&#10;            engine.pauseSimulation();&#10;        }&#10;    }&#10;&#10;    public void resumeSimulation() {&#10;        if (engine != null) {&#10;            engine.resumeSimulation();&#10;        }&#10;    }&#10;&#10;    public void stopSimulation() {&#10;        if (engine != null) {&#10;            engine.stopSimulation();&#10;        }&#10;    }&#10;&#10;    public void stepSimulation() {&#10;        if (engine != null) {&#10;            engine.stepForward();&#10;        }&#10;    }&#10;&#10;    public void setSimulationListener(SimulationEngine.SimulationListener listener) {&#10;        if (engine != null) {&#10;            engine.setListener(listener);&#10;        }&#10;    }&#10;&#10;    // ========== Database Methods ==========&#10;&#10;    private void testDatabaseConnection() {&#10;        boolean connected = dbManager.testConnection();&#10;        Platform.runLater(() -&gt; {&#10;            if (connected) {&#10;                dbStatusLabel.setText(&quot;✅ Connected&quot;);&#10;                dbStatusLabel.setStyle(&quot;-fx-text-fill: green;&quot;);&#10;            } else {&#10;                dbStatusLabel.setText(&quot;❌ Not Connected&quot;);&#10;                dbStatusLabel.setStyle(&quot;-fx-text-fill: red;&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void saveResultsToDatabase() {&#10;        if (currentRunId == null || engine == null) return;&#10;&#10;        try {&#10;            SimulationResults results = engine.getResults();&#10;            resultsDAO.updateSimulationRun(currentRunId, results, &quot;COMPLETED&quot;);&#10;&#10;            // Save completed tasks&#10;            if (!results.getCompletedTasks().isEmpty()) {&#10;                resultsDAO.saveTasks(currentRunId, results.getCompletedTasks());&#10;            }&#10;&#10;            showInfo(&quot;Success&quot;, &quot;Simulation results saved to database&quot;);&#10;        } catch (SQLException e) {&#10;            showError(&quot;Database Error&quot;, &quot;Failed to save results: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    // ========== UI Update Methods ==========&#10;&#10;    private void setupSimulationListener() {&#10;        if (engine != null) {&#10;            engine.setListener(new SimulationEngine.SimulationListener() {&#10;                @Override&#10;                public void onTimeUpdate(double time) {&#10;                    // Throttle UI updates to prevent stuttering&#10;                    long currentTime = System.currentTimeMillis();&#10;                    if (currentTime - lastUpdateTime &gt;= UPDATE_INTERVAL_MS) {&#10;                        lastUpdateTime = currentTime;&#10;                        Platform.runLater(() -&gt; {&#10;                            timeLabel.setText(String.format(&quot;%.2fs&quot;, time));&#10;                            updateStatistics();&#10;                            updateVisualization();&#10;                        });&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onSimulationComplete() {&#10;                    Platform.runLater(() -&gt; {&#10;                        // Final update to show accurate completion state&#10;                        updateStatistics();&#10;                        updateVisualization();&#10;                        updateButtonStates(false);&#10;                        if (currentRunId != null) {&#10;                            saveResultsToDatabase();&#10;                        }&#10;                        showInfo(&quot;Complete&quot;, &quot;Simulation completed!&quot;);&#10;                    });&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    private void updateStatistics() {&#10;        if (engine == null) return;&#10;&#10;        SimulationResults results = engine.getResults();&#10;        arrivedTasksLabel.setText(String.valueOf(results.getTotalArrivedTasks()));&#10;        completedTasksLabel.setText(String.valueOf(results.getTotalCompletedTasks()));&#10;        avgSystemTimeLabel.setText(String.format(&quot;%.2fs&quot;, results.getAverageSystemTime()));&#10;        // Use current clock time for real-time throughput calculation&#10;        double currentTime = Clock.getInstance().getTime();&#10;        throughputLabel.setText(String.format(&quot;%.3f/s&quot;, results.getThroughput(currentTime)));&#10;&#10;        // Update queue stats&#10;        updateQueueStatistics();&#10;&#10;        // Update user type stats&#10;        updateUserTypeStatistics();&#10;&#10;        // Update task type stats&#10;        updateTaskTypeStatistics();&#10;    }&#10;&#10;    /**&#10;     * Update Queue Statistics display&#10;     */&#10;    private void updateQueueStatistics() {&#10;        if (engine == null || queueStatsLabel == null) return;&#10;&#10;        ServicePoint dataStorage = engine.getDataStorage();&#10;        ServicePoint classification = engine.getClassification();&#10;        ServicePoint cpuCompute = engine.getCpuCompute();&#10;        ServicePoint gpuCompute = engine.getGpuCompute();&#10;        ServicePoint resultStorage = engine.getResultStorage();&#10;&#10;        double currentTime = Clock.getInstance().getTime();&#10;&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot; Data Storage:\n&quot;);&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#10;            dataStorage.getQueueLength(), dataStorage.getBusyServers(), 1, dataStorage.getMaxQueueLength()));&#10;        sb.append(String.format(&quot;   Utilization: %.1f%%\n\n&quot;, dataStorage.getUtilization(currentTime) * 100));&#10;&#10;        sb.append(&quot; Classification:\n&quot;);&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#10;            classification.getQueueLength(), classification.getBusyServers(), 1, classification.getMaxQueueLength()));&#10;        sb.append(String.format(&quot;   Utilization: %.1f%%\n\n&quot;, classification.getUtilization(currentTime) * 100));&#10;&#10;        sb.append(&quot; CPU Compute:\n&quot;);&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#10;            cpuCompute.getQueueLength(), cpuCompute.getBusyServers(),&#10;            config.getNumCpuNodes(), cpuCompute.getMaxQueueLength()));&#10;        sb.append(String.format(&quot;   Utilization: %.1f%% | Served: %d\n\n&quot;,&#10;            cpuCompute.getUtilization(currentTime) * 100, cpuCompute.getTasksServed()));&#10;&#10;&#10;        sb.append(&quot; GPU Compute:\n&quot;);&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#10;            gpuCompute.getQueueLength(), gpuCompute.getBusyServers(),&#10;            config.getNumGpuNodes(), gpuCompute.getMaxQueueLength()));&#10;        sb.append(String.format(&quot;   Utilization: %.1f%% | Served: %d\n\n&quot;,&#10;            gpuCompute.getUtilization(currentTime) * 100, gpuCompute.getTasksServed()));&#10;&#10;        sb.append(&quot; Result Storage:\n&quot;);&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#10;            resultStorage.getQueueLength(), resultStorage.getBusyServers(), 1, resultStorage.getMaxQueueLength()));&#10;        sb.append(String.format(&quot;   Utilization: %.1f%%&quot;, resultStorage.getUtilization(currentTime) * 100));&#10;&#10;        queueStatsLabel.setText(sb.toString());&#10;    }&#10;&#10;    /**&#10;     * Update User Type Statistics display&#10;     */&#10;    private void updateUserTypeStatistics() {&#10;        if (engine == null || userTypeStatsLabel == null) return;&#10;&#10;        SimulationResults results = engine.getResults();&#10;        int totalCompleted = results.getTotalCompletedTasks();&#10;&#10;        if (totalCompleted == 0) {&#10;            userTypeStatsLabel.setText(&quot;No tasks completed yet...&quot;);&#10;            return;&#10;        }&#10;&#10;        int normalCompleted = results.getNormalUserTasksCompleted();&#10;        int personalVipCompleted = results.getPersonalVipTasksCompleted();&#10;        int enterpriseVipCompleted = results.getEnterpriseVipTasksCompleted();&#10;&#10;        // Calculate average system time for each user type&#10;        Map&lt;UserType, Double&gt; avgSystemTimeByUser = calculateAverageSystemTimeByUserType();&#10;&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot; NORMAL Users:\n&quot;);&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#10;            normalCompleted, (normalCompleted * 100.0 / totalCompleted)));&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n\n&quot;,&#10;            avgSystemTimeByUser.getOrDefault(UserType.NORMAL, 0.0)));&#10;&#10;        sb.append(&quot;⭐ PERSONAL VIP:\n&quot;);&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#10;            personalVipCompleted, (personalVipCompleted * 100.0 / totalCompleted)));&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n\n&quot;,&#10;            avgSystemTimeByUser.getOrDefault(UserType.PERSONAL_VIP, 0.0)));&#10;&#10;        sb.append(&quot;⭐⭐ ENTERPRISE VIP:\n&quot;);&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#10;            enterpriseVipCompleted, (enterpriseVipCompleted * 100.0 / totalCompleted)));&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n\n&quot;,&#10;            avgSystemTimeByUser.getOrDefault(UserType.ENTERPRISE_VIP, 0.0)));&#10;&#10;        // Add comparison&#10;        sb.append(&quot; Priority Effect:\n&quot;);&#10;        double normalTime = avgSystemTimeByUser.getOrDefault(UserType.NORMAL, 0.0);&#10;        double enterpriseTime = avgSystemTimeByUser.getOrDefault(UserType.ENTERPRISE_VIP, 0.0);&#10;        if (normalTime &gt; 0 &amp;&amp; enterpriseTime &gt; 0) {&#10;            double improvement = ((normalTime - enterpriseTime) / normalTime) * 100;&#10;            sb.append(String.format(&quot;   Enterprise VIP is %.1f%% faster&quot;, improvement));&#10;        } else {&#10;            sb.append(&quot;   Insufficient data&quot;);&#10;        }&#10;&#10;        userTypeStatsLabel.setText(sb.toString());&#10;    }&#10;&#10;    /**&#10;     * Update Task Type Statistics display&#10;     */&#10;    private void updateTaskTypeStatistics() {&#10;        if (engine == null || taskTypeStatsLabel == null) return;&#10;&#10;        SimulationResults results = engine.getResults();&#10;        int totalCompleted = results.getTotalCompletedTasks();&#10;&#10;        if (totalCompleted == 0) {&#10;            taskTypeStatsLabel.setText(&quot;No tasks completed yet...&quot;);&#10;            return;&#10;        }&#10;&#10;        int cpuCompleted = results.getCpuTasksCompleted();&#10;        int gpuCompleted = results.getGpuTasksCompleted();&#10;&#10;        // Calculate average system time for each task type&#10;        Map&lt;TaskType, Double&gt; avgSystemTimeByTask = calculateAverageSystemTimeByTaskType();&#10;&#10;        ServicePoint cpuCompute = engine.getCpuCompute();&#10;        ServicePoint gpuCompute = engine.getGpuCompute();&#10;        double currentTime = Clock.getInstance().getTime();&#10;&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot; CPU Tasks:\n&quot;);&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#10;            cpuCompleted, (cpuCompleted * 100.0 / totalCompleted)));&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n&quot;,&#10;            avgSystemTimeByTask.getOrDefault(TaskType.CPU, 0.0)));&#10;        sb.append(String.format(&quot;   Node Utilization: %.1f%%\n\n&quot;,&#10;            cpuCompute.getUtilization(currentTime) * 100));&#10;&#10;        sb.append(&quot; GPU Tasks:\n&quot;);&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#10;            gpuCompleted, (gpuCompleted * 100.0 / totalCompleted)));&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n&quot;,&#10;            avgSystemTimeByTask.getOrDefault(TaskType.GPU, 0.0)));&#10;        sb.append(String.format(&quot;   Node Utilization: %.1f%%\n\n&quot;,&#10;            gpuCompute.getUtilization(currentTime) * 100));&#10;&#10;        // Add resource efficiency analysis&#10;        sb.append(&quot;⚡ Resource Efficiency:\n&quot;);&#10;        double cpuUtil = cpuCompute.getUtilization(currentTime) * 100;&#10;        double gpuUtil = gpuCompute.getUtilization(currentTime) * 100;&#10;&#10;        if (cpuUtil &gt; 90) {&#10;            sb.append(&quot;   ⚠️ CPU nodes overloaded\n&quot;);&#10;        } else if (cpuUtil &lt; 30) {&#10;            sb.append(&quot;    CPU nodes underutilized\n&quot;);&#10;        } else {&#10;            sb.append(&quot;   ✅ CPU nodes balanced\n&quot;);&#10;        }&#10;&#10;        if (gpuUtil &gt; 90) {&#10;            sb.append(&quot;   ⚠️ GPU nodes overloaded&quot;);&#10;        } else if (gpuUtil &lt; 30) {&#10;            sb.append(&quot;    GPU nodes underutilized&quot;);&#10;        } else {&#10;            sb.append(&quot;   ✅ GPU nodes balanced&quot;);&#10;        }&#10;&#10;        taskTypeStatsLabel.setText(sb.toString());&#10;    }&#10;&#10;    /**&#10;     * Calculate average system time grouped by user type&#10;     */&#10;    private Map&lt;UserType, Double&gt; calculateAverageSystemTimeByUserType() {&#10;        Map&lt;UserType, Double&gt; result = new HashMap&lt;&gt;();&#10;        Map&lt;UserType, Integer&gt; counts = new HashMap&lt;&gt;();&#10;&#10;        if (engine == null) return result;&#10;&#10;        SimulationResults results = engine.getResults();&#10;        List&lt;Task&gt; completedTasks = results.getCompletedTasks();&#10;&#10;        for (Task task : completedTasks) {&#10;            UserType type = task.getUserType();&#10;            double systemTime = task.getTotalSystemTime();&#10;            result.put(type, result.getOrDefault(type, 0.0) + systemTime);&#10;            counts.put(type, counts.getOrDefault(type, 0) + 1);&#10;        }&#10;&#10;        // Calculate averages&#10;        for (UserType type : result.keySet()) {&#10;            int count = counts.get(type);&#10;            if (count &gt; 0) {&#10;                result.put(type, result.get(type) / count);&#10;            }&#10;        }&#10;&#10;        return result;&#10;    }&#10;&#10;    /**&#10;     * Calculate average system time grouped by task type&#10;     */&#10;    private Map&lt;TaskType, Double&gt; calculateAverageSystemTimeByTaskType() {&#10;        Map&lt;TaskType, Double&gt; result = new HashMap&lt;&gt;();&#10;        Map&lt;TaskType, Integer&gt; counts = new HashMap&lt;&gt;();&#10;&#10;        if (engine == null) return result;&#10;&#10;        SimulationResults results = engine.getResults();&#10;        List&lt;Task&gt; completedTasks = results.getCompletedTasks();&#10;&#10;        for (Task task : completedTasks) {&#10;            TaskType type = task.getTaskType();&#10;            double systemTime = task.getTotalSystemTime();&#10;            result.put(type, result.getOrDefault(type, 0.0) + systemTime);&#10;            counts.put(type, counts.getOrDefault(type, 0) + 1);&#10;        }&#10;&#10;        // Calculate averages&#10;        for (TaskType type : result.keySet()) {&#10;            int count = counts.get(type);&#10;            if (count &gt; 0) {&#10;                result.put(type, result.get(type) / count);&#10;            }&#10;        }&#10;&#10;        return result;&#10;    }&#10;&#10;    private void updateVisualization() {&#10;        if (visualizationCanvas == null || engine == null) return;&#10;&#10;        GraphicsContext gc = visualizationCanvas.getGraphicsContext2D();&#10;        gc.clearRect(0, 0, visualizationCanvas.getWidth(), visualizationCanvas.getHeight());&#10;        gc.setFill(Color.WHITE);&#10;        gc.fillRect(0, 0, visualizationCanvas.getWidth(), visualizationCanvas.getHeight());&#10;&#10;        // Draw system with current state&#10;        drawSystemWithState(gc);&#10;    }&#10;&#10;    private void drawInitialCanvas() {&#10;        if (visualizationCanvas == null) return;&#10;&#10;        GraphicsContext gc = visualizationCanvas.getGraphicsContext2D();&#10;        gc.setFill(Color.WHITE);&#10;        gc.fillRect(0, 0, visualizationCanvas.getWidth(), visualizationCanvas.getHeight());&#10;&#10;        gc.setFill(Color.BLACK);&#10;        gc.setFont(javafx.scene.text.Font.font(16));&#10;        gc.fillText(&quot;System Visualization Area&quot;, visualizationCanvas.getWidth() / 2 - 90,&#10;                    visualizationCanvas.getHeight() / 2);&#10;    }&#10;&#10;    private void drawSystemWithState(GraphicsContext gc) {&#10;        gc.setStroke(Color.BLACK);&#10;        gc.setLineWidth(2);&#10;&#10;        double startX = 50;&#10;        double startY = 200;  // Reduced from 300 to 200 to fit in smaller canvas&#10;        double spacing = 100;&#10;&#10;        // Draw service points with current state&#10;        drawServicePoint(gc, startX, startY, &quot;Arrival&quot;, Color.LIGHTGREEN, 0, 0);&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#10;&#10;        startX += spacing;&#10;        ServicePoint dataStorage = engine.getDataStorage();&#10;        drawServicePoint(gc, startX, startY, &quot;Data\nStorage&quot;, Color.LIGHTBLUE,&#10;            dataStorage.getQueueLength(), dataStorage.getBusyServers());&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#10;&#10;        startX += spacing;&#10;        ServicePoint classification = engine.getClassification();&#10;        drawServicePoint(gc, startX, startY, &quot;Classification&quot;, Color.LIGHTYELLOW,&#10;            classification.getQueueLength(), classification.getBusyServers());&#10;&#10;        // CPU and GPU paths - now compute service points include their own queues&#10;        double cpuY = startY - 80;  // Reduced from 100 to 80 for more compact layout&#10;        double gpuY = startY + 80;  // Reduced from 100 to 80 for more compact layout&#10;&#10;        drawArrow(gc, startX + 30, startY - 30, startX + 30, cpuY + 30);&#10;        double cpuComputeX = startX;&#10;        ServicePoint cpuCompute = engine.getCpuCompute();&#10;        drawServicePoint(gc, cpuComputeX, cpuY, &quot;CPU\nCompute&quot;, Color.CORAL,&#10;            cpuCompute.getQueueLength(), cpuCompute.getBusyServers());&#10;&#10;        drawArrow(gc, startX + 30, startY + 30, startX + 30, gpuY - 30);&#10;        double gpuComputeX = startX;&#10;        ServicePoint gpuCompute = engine.getGpuCompute();&#10;        drawServicePoint(gc, gpuComputeX, gpuY, &quot;GPU\nCompute&quot;, Color.PLUM,&#10;            gpuCompute.getQueueLength(), gpuCompute.getBusyServers());&#10;&#10;        double resultX = cpuComputeX + spacing;&#10;        drawArrow(gc, cpuComputeX + 60, cpuY, resultX, startY);&#10;        drawArrow(gc, gpuComputeX + 60, gpuY, resultX, startY);&#10;&#10;        ServicePoint resultStorage = engine.getResultStorage();&#10;        drawServicePoint(gc, resultX, startY, &quot;Result\nStorage&quot;, Color.LIGHTGREEN,&#10;            resultStorage.getQueueLength(), resultStorage.getBusyServers());&#10;        drawArrow(gc, resultX + 60, startY, resultX + 80, startY);&#10;&#10;        gc.fillText(&quot;Exit&quot;, resultX + 85, startY + 5);&#10;    }&#10;&#10;    private void drawServicePoint(GraphicsContext gc, double x, double y, String name,&#10;                                   Color color, int queueLength, int busyServers) {&#10;        // Draw box&#10;        gc.setFill(color);&#10;        gc.fillRect(x, y - 30, 60, 60);&#10;        gc.setStroke(Color.BLACK);&#10;        gc.strokeRect(x, y - 30, 60, 60);&#10;&#10;        // Draw name&#10;        gc.setFill(Color.BLACK);&#10;        gc.setFont(javafx.scene.text.Font.font(&quot;Arial&quot;, 10));&#10;        String[] lines = name.split(&quot;\n&quot;);&#10;        for (int i = 0; i &lt; lines.length; i++) {&#10;            gc.fillText(lines[i], x + 5, y - 10 + i * 12);&#10;        }&#10;&#10;        // Draw queue length if &gt; 0&#10;        if (queueLength &gt; 0) {&#10;            gc.setFill(Color.RED);&#10;            gc.fillText(&quot;Q:&quot; + queueLength, x + 5, y + 20);&#10;        }&#10;&#10;        // Draw busy servers if &gt; 0&#10;        if (busyServers &gt; 0) {&#10;            gc.setFill(Color.BLUE);&#10;            gc.fillText(&quot;B:&quot; + busyServers, x + 35, y + 20);&#10;        }&#10;    }&#10;&#10;    private void drawArrow(GraphicsContext gc, double x1, double y1, double x2, double y2) {&#10;        gc.strokeLine(x1, y1, x2, y2);&#10;&#10;        // Draw arrowhead&#10;        double angle = Math.atan2(y2 - y1, x2 - x1);&#10;        double arrowLength = 10;&#10;        double arrowAngle = Math.PI / 6;&#10;&#10;        double x3 = x2 - arrowLength * Math.cos(angle - arrowAngle);&#10;        double y3 = y2 - arrowLength * Math.sin(angle - arrowAngle);&#10;        double x4 = x2 - arrowLength * Math.cos(angle + arrowAngle);&#10;        double y4 = y2 - arrowLength * Math.sin(angle + arrowAngle);&#10;&#10;        gc.strokeLine(x2, y2, x3, y3);&#10;        gc.strokeLine(x2, y2, x4, y4);&#10;    }&#10;&#10;    private void updateButtonStates(boolean running) {&#10;        startButton.setDisable(running);&#10;        pauseButton.setDisable(!running);&#10;        resumeButton.setDisable(true);&#10;        stopButton.setDisable(!running);&#10;    }&#10;&#10;    private void updateConfigFromUI() {&#10;        try {&#10;            config.setMeanArrivalInterval(Double.parseDouble(arrivalIntervalField.getText()));&#10;            config.setSimulationTime(Double.parseDouble(simulationTimeField.getText()));&#10;            config.setNumCpuNodes(Integer.parseInt(cpuNodesField.getText()));&#10;            config.setNumGpuNodes(Integer.parseInt(gpuNodesField.getText()));&#10;            config.setCpuTaskProbability(Double.parseDouble(cpuProbabilityField.getText()));&#10;            config.setResultStorageServiceTime(Double.parseDouble(resultStorageServiceTimeField.getText()));&#10;        } catch (NumberFormatException e) {&#10;            showError(&quot;Input Error&quot;, &quot;Please check configuration parameter format&quot;);&#10;        }&#10;    }&#10;&#10;    private void updateUIFromConfig() {&#10;        arrivalIntervalField.setText(String.valueOf(config.getMeanArrivalInterval()));&#10;        simulationTimeField.setText(String.valueOf(config.getSimulationTime()));&#10;        cpuNodesField.setText(String.valueOf(config.getNumCpuNodes()));&#10;        gpuNodesField.setText(String.valueOf(config.getNumGpuNodes()));&#10;        cpuProbabilityField.setText(String.valueOf(config.getCpuTaskProbability()));&#10;        resultStorageServiceTimeField.setText(String.valueOf(config.getResultStorageServiceTime()));&#10;    }&#10;&#10;    private void copyConfig(SimulationConfig source, SimulationConfig dest) {&#10;        dest.setMeanArrivalInterval(source.getMeanArrivalInterval());&#10;        dest.setSimulationTime(source.getSimulationTime());&#10;        dest.setNumCpuNodes(source.getNumCpuNodes());&#10;        dest.setNumGpuNodes(source.getNumGpuNodes());&#10;        dest.setCpuTaskProbability(source.getCpuTaskProbability());&#10;        dest.setNormalUserProbability(source.getNormalUserProbability());&#10;        dest.setPersonalVipProbability(source.getPersonalVipProbability());&#10;        dest.setEnterpriseVipProbability(source.getEnterpriseVipProbability());&#10;    }&#10;&#10;    // ========== Utility Methods ==========&#10;&#10;    private void showInfo(String title, String message) {&#10;        Alert alert = new Alert(Alert.AlertType.INFORMATION);&#10;        alert.setTitle(title);&#10;        alert.setHeaderText(null);&#10;        alert.setContentText(message);&#10;        alert.showAndWait();&#10;    }&#10;&#10;    private void showError(String title, String message) {&#10;        Alert alert = new Alert(Alert.AlertType.ERROR);&#10;        alert.setTitle(title);&#10;        alert.setHeaderText(null);&#10;        alert.setContentText(message);&#10;        alert.showAndWait();&#10;    }&#10;&#10;    // ========== Getters ==========&#10;&#10;    public SimulationEngine getEngine() {&#10;        return engine;&#10;    }&#10;&#10;    public SimulationConfig getConfig() {&#10;        return config;&#10;    }&#10;&#10;    public SimulationResults getResults() {&#10;        return engine != null ? engine.getResults() : null;&#10;    }&#10;&#10;    public double getCurrentTime() {&#10;        return Clock.getInstance().getTime();&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.simulation.controller;&#13;&#10;&#13;&#10;import com.simulation.database.DatabaseManager;&#13;&#10;import com.simulation.database.SimulationConfigDAO;&#13;&#10;import com.simulation.database.SimulationResultsDAO;&#13;&#10;import com.simulation.model.*;&#13;&#10;import javafx.application.Platform;&#13;&#10;import javafx.beans.property.SimpleStringProperty;&#13;&#10;import javafx.collections.FXCollections;&#13;&#10;import javafx.fxml.FXML;&#13;&#10;import javafx.scene.canvas.Canvas;&#13;&#10;import javafx.scene.canvas.GraphicsContext;&#13;&#10;import javafx.scene.control.*;&#13;&#10;import javafx.scene.paint.Color;&#13;&#10;import javafx.stage.Stage;&#13;&#10;&#13;&#10;import java.sql.SQLException;&#13;&#10;import java.util.*;&#13;&#10;&#13;&#10;/**&#13;&#10; * FXML Controller that mediates between View and Model&#13;&#10; * Handles UI events and database operations&#13;&#10; */&#13;&#10;public class SimulationController {&#13;&#10;    // FXML Components&#13;&#10;    @FXML private Button startButton;&#13;&#10;    @FXML private Button pauseButton;&#13;&#10;    @FXML private Button resumeButton;&#13;&#10;    @FXML private Button stopButton;&#13;&#10;    @FXML private Button resetButton;&#13;&#10;&#13;&#10;    @FXML private Label timeLabel;&#13;&#10;    @FXML private Label speedLabel;&#13;&#10;    @FXML private Label arrivedTasksLabel;&#13;&#10;    @FXML private Label completedTasksLabel;&#13;&#10;    @FXML private Label avgSystemTimeLabel;&#13;&#10;    @FXML private Label throughputLabel;&#13;&#10;    @FXML private Label queueStatsLabel;&#13;&#10;    @FXML private Label userTypeStatsLabel;&#13;&#10;    @FXML private Label taskTypeStatsLabel;&#13;&#10;    @FXML private Label dbStatusLabel;&#13;&#10;&#13;&#10;    @FXML private TextField arrivalIntervalField;&#13;&#10;    @FXML private TextField simulationTimeField;&#13;&#10;    @FXML private TextField cpuNodesField;&#13;&#10;    @FXML private TextField gpuNodesField;&#13;&#10;    @FXML private TextField cpuProbabilityField;&#13;&#10;    @FXML private TextField resultStorageServiceTimeField;&#13;&#10;&#13;&#10;    @FXML private Slider speedSlider;&#13;&#10;    @FXML private Canvas visualizationCanvas;&#13;&#10;&#13;&#10;    @FXML private TableView&lt;Map&lt;String,Object&gt;&gt; historyTable;&#13;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; runIdColumn;&#13;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; runNameColumn;&#13;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; startTimeColumn;&#13;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; endTimeColumn;&#13;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; completedTasksColumn;&#13;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; avgSystemTimeColumn;&#13;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; throughputColumn;&#13;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; statusColumn;&#13;&#10;&#13;&#10;&#13;&#10;&#13;&#10;    // Model components&#13;&#10;    private SimulationEngine engine;&#13;&#10;    private final SimulationConfig config;&#13;&#10;&#13;&#10;    // Database components&#13;&#10;    private final DatabaseManager dbManager;&#13;&#10;    private final SimulationConfigDAO configDAO;&#13;&#10;    private final SimulationResultsDAO resultsDAO;&#13;&#10;    private Integer currentRunId;&#13;&#10;&#13;&#10;    // UI update throttling&#13;&#10;    private long lastUpdateTime = 0;&#13;&#10;    private static final long UPDATE_INTERVAL_MS = 100; // Update UI every 100ms&#13;&#10;&#13;&#10;    public SimulationController() {&#13;&#10;        this.config = new SimulationConfig();&#13;&#10;        this.dbManager = DatabaseManager.getInstance();&#13;&#10;&#13;&#10;        // Initialize DAO objects, but they will handle database unavailability internally&#13;&#10;        SimulationConfigDAO tempConfigDAO = null;&#13;&#10;        SimulationResultsDAO tempResultsDAO = null;&#13;&#10;        try {&#13;&#10;            tempConfigDAO = new SimulationConfigDAO();&#13;&#10;            tempResultsDAO = new SimulationResultsDAO();&#13;&#10;        } catch (Exception e) {&#13;&#10;            System.err.println(&quot;⚠️  Could not initialize database DAOs: &quot; + e.getMessage());&#13;&#10;        }&#13;&#10;        this.configDAO = tempConfigDAO;&#13;&#10;        this.resultsDAO = tempResultsDAO;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Initialize method called after FXML loading&#13;&#10;     */&#13;&#10;    @FXML&#13;&#10;    public void initialize() {&#13;&#10;        // Setup speed slider listener&#13;&#10;        if (speedSlider != null) {&#13;&#10;            speedSlider.valueProperty().addListener((obs, oldVal, newVal) -&gt; {&#13;&#10;                double speed = newVal.doubleValue();&#13;&#10;                // Format speed display: show 1 decimal for &lt; 10x, integer for &gt;= 10x&#13;&#10;                if (speed &gt;= 10.0) {&#13;&#10;                    speedLabel.setText(String.format(&quot;%.0fx&quot;, speed));&#13;&#10;                } else {&#13;&#10;                    speedLabel.setText(String.format(&quot;%.1fx&quot;, speed));&#13;&#10;                }&#13;&#10;                if (engine != null) {&#13;&#10;                    engine.setSpeed(speed);&#13;&#10;                }&#13;&#10;            });&#13;&#10;        }&#13;&#10;&#13;&#10;        // Test database connection&#13;&#10;        testDatabaseConnection();&#13;&#10;&#13;&#10;        // Initialize canvas&#13;&#10;        if (visualizationCanvas != null) {&#13;&#10;            drawInitialCanvas();&#13;&#10;        }&#13;&#10;        // === Table column bindings ===&#13;&#10;        runIdColumn.setCellValueFactory(cell -&gt;&#13;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;runId&quot;)))&#13;&#10;        );&#13;&#10;&#13;&#10;        runNameColumn.setCellValueFactory(cell -&gt;&#13;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;runName&quot;)))&#13;&#10;        );&#13;&#10;&#13;&#10;        startTimeColumn.setCellValueFactory(cell -&gt; {&#13;&#10;            Object ts = cell.getValue().get(&quot;startTime&quot;);&#13;&#10;            return new SimpleStringProperty(ts == null ? &quot;&quot; : ts.toString());&#13;&#10;        });&#13;&#10;&#13;&#10;        endTimeColumn.setCellValueFactory(cell -&gt; {&#13;&#10;            Object ts = cell.getValue().get(&quot;endTime&quot;);&#13;&#10;            return new SimpleStringProperty(ts == null ? &quot;&quot; : ts.toString());&#13;&#10;        });&#13;&#10;&#13;&#10;        completedTasksColumn.setCellValueFactory(cell -&gt;&#13;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;totalTasks&quot;)))&#13;&#10;        );&#13;&#10;&#13;&#10;        avgSystemTimeColumn.setCellValueFactory(cell -&gt;&#13;&#10;                new SimpleStringProperty(&#13;&#10;                        String.format(&quot;%.3f&quot;,&#13;&#10;                                (double) cell.getValue().get(&quot;avgSystemTime&quot;))&#13;&#10;                )&#13;&#10;        );&#13;&#10;&#13;&#10;        throughputColumn.setCellValueFactory(cell -&gt;&#13;&#10;                new SimpleStringProperty(&#13;&#10;                        String.format(&quot;%.3f&quot;,&#13;&#10;                                (double) cell.getValue().get(&quot;throughput&quot;))&#13;&#10;                )&#13;&#10;        );&#13;&#10;&#13;&#10;        statusColumn.setCellValueFactory(cell -&gt;&#13;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;status&quot;)))&#13;&#10;        );&#13;&#10;&#13;&#10;        // Auto-load history on startup&#13;&#10;        loadHistoryData();&#13;&#10;    }&#13;&#10;&#13;&#10;&#13;&#10;        // ========== FXML Event Handlers ==========&#13;&#10;&#13;&#10;    @FXML&#13;&#10;    private void handleStart() {&#13;&#10;        updateConfigFromUI();&#13;&#10;        initializeSimulation();&#13;&#10;&#13;&#10;        // Apply current speed from slider to the new engine&#13;&#10;        if (engine != null &amp;&amp; speedSlider != null) {&#13;&#10;            engine.setSpeed(speedSlider.getValue());&#13;&#10;        }&#13;&#10;&#13;&#10;        // Create database run record&#13;&#10;        try {&#13;&#10;            currentRunId = resultsDAO.createSimulationRun(null,&#13;&#10;                &quot;Simulation Run &quot; + System.currentTimeMillis());&#13;&#10;        } catch (SQLException e) {&#13;&#10;            showError(&quot;Database Error&quot;, &quot;Failed to create run record: &quot; + e.getMessage());&#13;&#10;        }&#13;&#10;&#13;&#10;        startSimulation();&#13;&#10;        updateButtonStates(true);&#13;&#10;    }&#13;&#10;&#13;&#10;    @FXML&#13;&#10;    private void handlePause() {&#13;&#10;        pauseSimulation();&#13;&#10;        pauseButton.setDisable(true);&#13;&#10;        resumeButton.setDisable(false);&#13;&#10;    }&#13;&#10;&#13;&#10;    @FXML&#13;&#10;    private void handleResume() {&#13;&#10;        resumeSimulation();&#13;&#10;        pauseButton.setDisable(false);&#13;&#10;        resumeButton.setDisable(true);&#13;&#10;    }&#13;&#10;&#13;&#10;    @FXML&#13;&#10;    private void handleStop() {&#13;&#10;        stopSimulation();&#13;&#10;&#13;&#10;        // Save results to database&#13;&#10;        if (currentRunId != null) {&#13;&#10;            saveResultsToDatabase();&#13;&#10;        }&#13;&#10;&#13;&#10;        updateButtonStates(false);&#13;&#10;    }&#13;&#10;&#13;&#10;    @FXML&#13;&#10;    private void handleReset() {&#13;&#10;        stopSimulation();&#13;&#10;        initializeSimulation();&#13;&#10;&#13;&#10;        // Apply current speed from slider to the reset engine&#13;&#10;        if (engine != null &amp;&amp; speedSlider != null) {&#13;&#10;            engine.setSpeed(speedSlider.getValue());&#13;&#10;        }&#13;&#10;&#13;&#10;        updateStatistics();&#13;&#10;        updateButtonStates(false);&#13;&#10;    }&#13;&#10;&#13;&#10;    @FXML&#13;&#10;    private void handleSaveConfig() {&#13;&#10;        TextInputDialog dialog = new TextInputDialog(&quot;My Configuration&quot;);&#13;&#10;        dialog.setTitle(&quot;Save Configuration&quot;);&#13;&#10;        dialog.setHeaderText(&quot;Save current configuration to database&quot;);&#13;&#10;        dialog.setContentText(&quot;Configuration Name:&quot;);&#13;&#10;&#13;&#10;        Optional&lt;String&gt; result = dialog.showAndWait();&#13;&#10;        result.ifPresent(name -&gt; {&#13;&#10;            try {&#13;&#10;                updateConfigFromUI();&#13;&#10;                configDAO.saveConfig(config, name);&#13;&#10;                showInfo(&quot;Success&quot;, &quot;Configuration saved: &quot; + name);&#13;&#10;            } catch (SQLException e) {&#13;&#10;                showError(&quot;Error&quot;, &quot;Failed to save configuration: &quot; + e.getMessage());&#13;&#10;            }&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    @FXML&#13;&#10;    private void handleLoadConfig() {&#13;&#10;        try {&#13;&#10;            List&lt;String&gt; configNames = configDAO.getAllConfigNames();&#13;&#10;&#13;&#10;            ChoiceDialog&lt;String&gt; dialog = new ChoiceDialog&lt;&gt;(&#13;&#10;                configNames.isEmpty() ? null : configNames.get(0), configNames);&#13;&#10;            dialog.setTitle(&quot;Load Configuration&quot;);&#13;&#10;            dialog.setHeaderText(&quot;Load configuration from database&quot;);&#13;&#10;            dialog.setContentText(&quot;Select Configuration:&quot;);&#13;&#10;&#13;&#10;            Optional&lt;String&gt; result = dialog.showAndWait();&#13;&#10;            result.ifPresent(name -&gt; {&#13;&#10;                try {&#13;&#10;                    SimulationConfig loadedConfig = configDAO.loadConfigByName(name);&#13;&#10;                    if (loadedConfig != null) {&#13;&#10;                        copyConfig(loadedConfig, config);&#13;&#10;                        updateUIFromConfig();&#13;&#10;                        showInfo(&quot;Success&quot;, &quot;Configuration loaded: &quot; + name);&#13;&#10;                    }&#13;&#10;                } catch (SQLException e) {&#13;&#10;                    showError(&quot;Error&quot;, &quot;Failed to load configuration: &quot; + e.getMessage());&#13;&#10;                }&#13;&#10;            });&#13;&#10;        } catch (SQLException e) {&#13;&#10;            showError(&quot;Error&quot;, &quot;Failed to get configuration list: &quot; + e.getMessage());&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Load history data from database and display in table&#13;&#10;     */&#13;&#10;    private void loadHistoryData() {&#13;&#10;        if (resultsDAO == null) {&#13;&#10;            System.out.println(&quot;⚠️  Database not available - cannot load history&quot;);&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        try {&#13;&#10;            List&lt;Map&lt;String,Object&gt;&gt; runs = resultsDAO.getAllSimulationRuns();&#13;&#10;            System.out.println(&quot;✅ History loaded: &quot; + runs.size() + &quot; simulation runs found&quot;);&#13;&#10;&#13;&#10;            if (historyTable != null) {&#13;&#10;                historyTable.setItems(FXCollections.observableArrayList(runs));&#13;&#10;                historyTable.refresh();&#13;&#10;                System.out.println(&quot;✅ History table updated in UI&quot;);&#13;&#10;            } else {&#13;&#10;                System.err.println(&quot;⚠️  History table is null!&quot;);&#13;&#10;            }&#13;&#10;        } catch (SQLException e) {&#13;&#10;            System.err.println(&quot;❌ Failed to load history: &quot; + e.getMessage());&#13;&#10;            e.printStackTrace();&#13;&#10;        } catch (Exception e) {&#13;&#10;            System.err.println(&quot;❌ Unexpected error loading history: &quot; + e.getMessage());&#13;&#10;            e.printStackTrace();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @FXML&#13;&#10;    private void handleViewHistory() {&#13;&#10;        System.out.println(&quot; View History button clicked!&quot;);&#13;&#10;        loadHistoryData();&#13;&#10;    }&#13;&#10;&#13;&#10;&#13;&#10;    @FXML&#13;&#10;    private void handleTestDatabase() {&#13;&#10;        testDatabaseConnection();&#13;&#10;    }&#13;&#10;&#13;&#10;    // ========== Simulation Control Methods ==========&#13;&#10;&#13;&#10;    public void initializeSimulation() {&#13;&#10;        if (engine != null &amp;&amp; engine.isAlive()) {&#13;&#10;            engine.stopSimulation();&#13;&#10;            try {&#13;&#10;                engine.join(1000);&#13;&#10;            } catch (InterruptedException e) {&#13;&#10;                Thread.currentThread().interrupt();&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        engine = new SimulationEngine(config);&#13;&#10;        engine.initialize();&#13;&#10;        setupSimulationListener();&#13;&#10;    }&#13;&#10;&#13;&#10;    public void startSimulation() {&#13;&#10;        if (engine != null &amp;&amp; !engine.isRunning()) {&#13;&#10;            engine.start();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public void pauseSimulation() {&#13;&#10;        if (engine != null) {&#13;&#10;            engine.pauseSimulation();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public void resumeSimulation() {&#13;&#10;        if (engine != null) {&#13;&#10;            engine.resumeSimulation();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public void stopSimulation() {&#13;&#10;        if (engine != null) {&#13;&#10;            engine.stopSimulation();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public void stepSimulation() {&#13;&#10;        if (engine != null) {&#13;&#10;            engine.stepForward();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    public void setSimulationListener(SimulationEngine.SimulationListener listener) {&#13;&#10;        if (engine != null) {&#13;&#10;            engine.setListener(listener);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // ========== Database Methods ==========&#13;&#10;&#13;&#10;    private void testDatabaseConnection() {&#13;&#10;        boolean connected = dbManager.testConnection();&#13;&#10;        Platform.runLater(() -&gt; {&#13;&#10;            if (connected) {&#13;&#10;                dbStatusLabel.setText(&quot;✅ Connected&quot;);&#13;&#10;                dbStatusLabel.setStyle(&quot;-fx-text-fill: green;&quot;);&#13;&#10;            } else {&#13;&#10;                dbStatusLabel.setText(&quot;❌ Not Connected&quot;);&#13;&#10;                dbStatusLabel.setStyle(&quot;-fx-text-fill: red;&quot;);&#13;&#10;            }&#13;&#10;        });&#13;&#10;    }&#13;&#10;&#13;&#10;    private void saveResultsToDatabase() {&#13;&#10;        if (currentRunId == null || engine == null) return;&#13;&#10;&#13;&#10;        try {&#13;&#10;            SimulationResults results = engine.getResults();&#13;&#10;            resultsDAO.updateSimulationRun(currentRunId, results, &quot;COMPLETED&quot;);&#13;&#10;&#13;&#10;            // Save completed tasks&#13;&#10;            if (!results.getCompletedTasks().isEmpty()) {&#13;&#10;                resultsDAO.saveTasks(currentRunId, results.getCompletedTasks());&#13;&#10;            }&#13;&#10;&#13;&#10;            showInfo(&quot;Success&quot;, &quot;Simulation results saved to database&quot;);&#13;&#10;        } catch (SQLException e) {&#13;&#10;            showError(&quot;Database Error&quot;, &quot;Failed to save results: &quot; + e.getMessage());&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // ========== UI Update Methods ==========&#13;&#10;&#13;&#10;    private void setupSimulationListener() {&#13;&#10;        if (engine != null) {&#13;&#10;            engine.setListener(new SimulationEngine.SimulationListener() {&#13;&#10;                @Override&#13;&#10;                public void onTimeUpdate(double time) {&#13;&#10;                    // Throttle UI updates to prevent stuttering&#13;&#10;                    long currentTime = System.currentTimeMillis();&#13;&#10;                    if (currentTime - lastUpdateTime &gt;= UPDATE_INTERVAL_MS) {&#13;&#10;                        lastUpdateTime = currentTime;&#13;&#10;                        Platform.runLater(() -&gt; {&#13;&#10;                            timeLabel.setText(String.format(&quot;%.2fs&quot;, time));&#13;&#10;                            updateStatistics();&#13;&#10;                            updateVisualization();&#13;&#10;                        });&#13;&#10;                    }&#13;&#10;                }&#13;&#10;&#13;&#10;                @Override&#13;&#10;                public void onSimulationComplete() {&#13;&#10;                    Platform.runLater(() -&gt; {&#13;&#10;                        // Final update to show accurate completion state&#13;&#10;                        updateStatistics();&#13;&#10;                        updateVisualization();&#13;&#10;                        updateButtonStates(false);&#13;&#10;                        if (currentRunId != null) {&#13;&#10;                            saveResultsToDatabase();&#13;&#10;                        }&#13;&#10;                        showInfo(&quot;Complete&quot;, &quot;Simulation completed!&quot;);&#13;&#10;                    });&#13;&#10;                }&#13;&#10;            });&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void updateStatistics() {&#13;&#10;        if (engine == null) return;&#13;&#10;&#13;&#10;        SimulationResults results = engine.getResults();&#13;&#10;        arrivedTasksLabel.setText(String.valueOf(results.getTotalArrivedTasks()));&#13;&#10;        completedTasksLabel.setText(String.valueOf(results.getTotalCompletedTasks()));&#13;&#10;        avgSystemTimeLabel.setText(String.format(&quot;%.2fs&quot;, results.getAverageSystemTime()));&#13;&#10;        // Use current clock time for real-time throughput calculation&#13;&#10;        double currentTime = Clock.getInstance().getTime();&#13;&#10;        throughputLabel.setText(String.format(&quot;%.3f/s&quot;, results.getThroughput(currentTime)));&#13;&#10;&#13;&#10;        // Update queue stats&#13;&#10;        updateQueueStatistics();&#13;&#10;&#13;&#10;        // Update user type stats&#13;&#10;        updateUserTypeStatistics();&#13;&#10;&#13;&#10;        // Update task type stats&#13;&#10;        updateTaskTypeStatistics();&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update Queue Statistics display&#13;&#10;     */&#13;&#10;    private void updateQueueStatistics() {&#13;&#10;        if (engine == null || queueStatsLabel == null) return;&#13;&#10;&#13;&#10;        ServicePoint dataStorage = engine.getDataStorage();&#13;&#10;        ServicePoint classification = engine.getClassification();&#13;&#10;        ServicePoint cpuCompute = engine.getCpuCompute();&#13;&#10;        ServicePoint gpuCompute = engine.getGpuCompute();&#13;&#10;        ServicePoint resultStorage = engine.getResultStorage();&#13;&#10;&#13;&#10;        double currentTime = Clock.getInstance().getTime();&#13;&#10;&#13;&#10;        StringBuilder sb = new StringBuilder();&#13;&#10;        sb.append(&quot; Data Storage:\n&quot;);&#13;&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#13;&#10;            dataStorage.getQueueLength(), dataStorage.getBusyServers(), 1, dataStorage.getMaxQueueLength()));&#13;&#10;        sb.append(String.format(&quot;   Utilization: %.1f%%\n\n&quot;, dataStorage.getUtilization(currentTime) * 100));&#13;&#10;&#13;&#10;        sb.append(&quot; Classification:\n&quot;);&#13;&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#13;&#10;            classification.getQueueLength(), classification.getBusyServers(), 1, classification.getMaxQueueLength()));&#13;&#10;        sb.append(String.format(&quot;   Utilization: %.1f%%\n\n&quot;, classification.getUtilization(currentTime) * 100));&#13;&#10;&#13;&#10;        sb.append(&quot; CPU Compute:\n&quot;);&#13;&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#13;&#10;            cpuCompute.getQueueLength(), cpuCompute.getBusyServers(),&#13;&#10;            config.getNumCpuNodes(), cpuCompute.getMaxQueueLength()));&#13;&#10;        sb.append(String.format(&quot;   Utilization: %.1f%% | Served: %d\n\n&quot;,&#13;&#10;            cpuCompute.getUtilization(currentTime) * 100, cpuCompute.getTasksServed()));&#13;&#10;&#13;&#10;&#13;&#10;        sb.append(&quot; GPU Compute:\n&quot;);&#13;&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#13;&#10;            gpuCompute.getQueueLength(), gpuCompute.getBusyServers(),&#13;&#10;            config.getNumGpuNodes(), gpuCompute.getMaxQueueLength()));&#13;&#10;        sb.append(String.format(&quot;   Utilization: %.1f%% | Served: %d\n\n&quot;,&#13;&#10;            gpuCompute.getUtilization(currentTime) * 100, gpuCompute.getTasksServed()));&#13;&#10;&#13;&#10;        sb.append(&quot; Result Storage:\n&quot;);&#13;&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#13;&#10;            resultStorage.getQueueLength(), resultStorage.getBusyServers(), 1, resultStorage.getMaxQueueLength()));&#13;&#10;        sb.append(String.format(&quot;   Utilization: %.1f%%&quot;, resultStorage.getUtilization(currentTime) * 100));&#13;&#10;&#13;&#10;        queueStatsLabel.setText(sb.toString());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update User Type Statistics display&#13;&#10;     */&#13;&#10;    private void updateUserTypeStatistics() {&#13;&#10;        if (engine == null || userTypeStatsLabel == null) return;&#13;&#10;&#13;&#10;        SimulationResults results = engine.getResults();&#13;&#10;        int totalCompleted = results.getTotalCompletedTasks();&#13;&#10;&#13;&#10;        if (totalCompleted == 0) {&#13;&#10;            userTypeStatsLabel.setText(&quot;No tasks completed yet...&quot;);&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        int normalCompleted = results.getNormalUserTasksCompleted();&#13;&#10;        int personalVipCompleted = results.getPersonalVipTasksCompleted();&#13;&#10;        int enterpriseVipCompleted = results.getEnterpriseVipTasksCompleted();&#13;&#10;&#13;&#10;        // Calculate average system time for each user type&#13;&#10;        Map&lt;UserType, Double&gt; avgSystemTimeByUser = calculateAverageSystemTimeByUserType();&#13;&#10;&#13;&#10;        StringBuilder sb = new StringBuilder();&#13;&#10;        sb.append(&quot; NORMAL Users:\n&quot;);&#13;&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#13;&#10;            normalCompleted, (normalCompleted * 100.0 / totalCompleted)));&#13;&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n\n&quot;,&#13;&#10;            avgSystemTimeByUser.getOrDefault(UserType.NORMAL, 0.0)));&#13;&#10;&#13;&#10;        sb.append(&quot;⭐ PERSONAL VIP:\n&quot;);&#13;&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#13;&#10;            personalVipCompleted, (personalVipCompleted * 100.0 / totalCompleted)));&#13;&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n\n&quot;,&#13;&#10;            avgSystemTimeByUser.getOrDefault(UserType.PERSONAL_VIP, 0.0)));&#13;&#10;&#13;&#10;        sb.append(&quot;⭐⭐ ENTERPRISE VIP:\n&quot;);&#13;&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#13;&#10;            enterpriseVipCompleted, (enterpriseVipCompleted * 100.0 / totalCompleted)));&#13;&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n\n&quot;,&#13;&#10;            avgSystemTimeByUser.getOrDefault(UserType.ENTERPRISE_VIP, 0.0)));&#13;&#10;&#13;&#10;        // Add comparison&#10;        sb.append(&quot; Priority Effect:\n&quot;);&#10;        double normalTime = avgSystemTimeByUser.getOrDefault(UserType.NORMAL, 0.0);&#10;        double personalVipTime = avgSystemTimeByUser.getOrDefault(UserType.PERSONAL_VIP, 0.0);&#10;        double enterpriseTime = avgSystemTimeByUser.getOrDefault(UserType.ENTERPRISE_VIP, 0.0);&#10;        &#10;        if (normalTime &gt; 0 &amp;&amp; enterpriseTime &gt; 0) {&#10;            double improvement = ((normalTime - enterpriseTime) / normalTime) * 100;&#10;            if (improvement &gt; 0) {&#10;                sb.append(String.format(&quot;   Enterprise VIP is %.1f%% faster than Normal\n&quot;, improvement));&#10;            } else {&#10;                sb.append(String.format(&quot;   Enterprise VIP is %.1f%% slower than Normal\n&quot;, -improvement));&#10;                sb.append(&quot;   (May occur with small samples or low load)\n&quot;);&#10;            }&#10;        } else {&#10;            sb.append(&quot;   Insufficient data for comparison\n&quot;);&#10;        }&#10;        &#10;        // Add Personal VIP comparison&#10;        if (normalTime &gt; 0 &amp;&amp; personalVipTime &gt; 0) {&#10;            double personalImprovement = ((normalTime - personalVipTime) / normalTime) * 100;&#10;            if (personalImprovement &gt; 0) {&#10;                sb.append(String.format(&quot;   Personal VIP is %.1f%% faster than Normal&quot;, personalImprovement));&#10;            } else {&#10;                sb.append(String.format(&quot;   Personal VIP is %.1f%% slower than Normal&quot;, -personalImprovement));&#10;            }&#10;        }&#13;&#10;&#13;&#10;        userTypeStatsLabel.setText(sb.toString());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Update Task Type Statistics display&#13;&#10;     */&#13;&#10;    private void updateTaskTypeStatistics() {&#13;&#10;        if (engine == null || taskTypeStatsLabel == null) return;&#13;&#10;&#13;&#10;        SimulationResults results = engine.getResults();&#13;&#10;        int totalCompleted = results.getTotalCompletedTasks();&#13;&#10;&#13;&#10;        if (totalCompleted == 0) {&#13;&#10;            taskTypeStatsLabel.setText(&quot;No tasks completed yet...&quot;);&#13;&#10;            return;&#13;&#10;        }&#13;&#10;&#13;&#10;        int cpuCompleted = results.getCpuTasksCompleted();&#13;&#10;        int gpuCompleted = results.getGpuTasksCompleted();&#13;&#10;&#13;&#10;        // Calculate average system time for each task type&#13;&#10;        Map&lt;TaskType, Double&gt; avgSystemTimeByTask = calculateAverageSystemTimeByTaskType();&#13;&#10;&#13;&#10;        ServicePoint cpuCompute = engine.getCpuCompute();&#13;&#10;        ServicePoint gpuCompute = engine.getGpuCompute();&#13;&#10;        double currentTime = Clock.getInstance().getTime();&#13;&#10;&#13;&#10;        StringBuilder sb = new StringBuilder();&#13;&#10;        sb.append(&quot; CPU Tasks:\n&quot;);&#13;&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#13;&#10;            cpuCompleted, (cpuCompleted * 100.0 / totalCompleted)));&#13;&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n&quot;,&#13;&#10;            avgSystemTimeByTask.getOrDefault(TaskType.CPU, 0.0)));&#13;&#10;        sb.append(String.format(&quot;   Node Utilization: %.1f%%\n\n&quot;,&#13;&#10;            cpuCompute.getUtilization(currentTime) * 100));&#13;&#10;&#13;&#10;        sb.append(&quot; GPU Tasks:\n&quot;);&#13;&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#13;&#10;            gpuCompleted, (gpuCompleted * 100.0 / totalCompleted)));&#13;&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n&quot;,&#13;&#10;            avgSystemTimeByTask.getOrDefault(TaskType.GPU, 0.0)));&#13;&#10;        sb.append(String.format(&quot;   Node Utilization: %.1f%%\n\n&quot;,&#13;&#10;            gpuCompute.getUtilization(currentTime) * 100));&#13;&#10;&#13;&#10;        // Add resource efficiency analysis&#13;&#10;        sb.append(&quot;⚡ Resource Efficiency:\n&quot;);&#13;&#10;        double cpuUtil = cpuCompute.getUtilization(currentTime) * 100;&#13;&#10;        double gpuUtil = gpuCompute.getUtilization(currentTime) * 100;&#13;&#10;&#13;&#10;        if (cpuUtil &gt; 90) {&#13;&#10;            sb.append(&quot;   ⚠️ CPU nodes overloaded\n&quot;);&#13;&#10;        } else if (cpuUtil &lt; 30) {&#13;&#10;            sb.append(&quot;    CPU nodes underutilized\n&quot;);&#13;&#10;        } else {&#13;&#10;            sb.append(&quot;   ✅ CPU nodes balanced\n&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        if (gpuUtil &gt; 90) {&#13;&#10;            sb.append(&quot;   ⚠️ GPU nodes overloaded&quot;);&#13;&#10;        } else if (gpuUtil &lt; 30) {&#13;&#10;            sb.append(&quot;    GPU nodes underutilized&quot;);&#13;&#10;        } else {&#13;&#10;            sb.append(&quot;   ✅ GPU nodes balanced&quot;);&#13;&#10;        }&#13;&#10;&#13;&#10;        taskTypeStatsLabel.setText(sb.toString());&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Calculate average system time grouped by user type&#13;&#10;     */&#13;&#10;    private Map&lt;UserType, Double&gt; calculateAverageSystemTimeByUserType() {&#13;&#10;        Map&lt;UserType, Double&gt; result = new HashMap&lt;&gt;();&#13;&#10;        Map&lt;UserType, Integer&gt; counts = new HashMap&lt;&gt;();&#13;&#10;&#13;&#10;        if (engine == null) return result;&#13;&#10;&#13;&#10;        SimulationResults results = engine.getResults();&#13;&#10;        List&lt;Task&gt; completedTasks = results.getCompletedTasks();&#13;&#10;&#13;&#10;        for (Task task : completedTasks) {&#13;&#10;            UserType type = task.getUserType();&#13;&#10;            double systemTime = task.getTotalSystemTime();&#13;&#10;            result.put(type, result.getOrDefault(type, 0.0) + systemTime);&#13;&#10;            counts.put(type, counts.getOrDefault(type, 0) + 1);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Calculate averages&#13;&#10;        for (UserType type : result.keySet()) {&#13;&#10;            int count = counts.get(type);&#13;&#10;            if (count &gt; 0) {&#13;&#10;                result.put(type, result.get(type) / count);&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        return result;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Calculate average system time grouped by task type&#13;&#10;     */&#13;&#10;    private Map&lt;TaskType, Double&gt; calculateAverageSystemTimeByTaskType() {&#13;&#10;        Map&lt;TaskType, Double&gt; result = new HashMap&lt;&gt;();&#13;&#10;        Map&lt;TaskType, Integer&gt; counts = new HashMap&lt;&gt;();&#13;&#10;&#13;&#10;        if (engine == null) return result;&#13;&#10;&#13;&#10;        SimulationResults results = engine.getResults();&#13;&#10;        List&lt;Task&gt; completedTasks = results.getCompletedTasks();&#13;&#10;&#13;&#10;        for (Task task : completedTasks) {&#13;&#10;            TaskType type = task.getTaskType();&#13;&#10;            double systemTime = task.getTotalSystemTime();&#13;&#10;            result.put(type, result.getOrDefault(type, 0.0) + systemTime);&#13;&#10;            counts.put(type, counts.getOrDefault(type, 0) + 1);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Calculate averages&#13;&#10;        for (TaskType type : result.keySet()) {&#13;&#10;            int count = counts.get(type);&#13;&#10;            if (count &gt; 0) {&#13;&#10;                result.put(type, result.get(type) / count);&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        return result;&#13;&#10;    }&#13;&#10;&#13;&#10;    private void updateVisualization() {&#13;&#10;        if (visualizationCanvas == null || engine == null) return;&#13;&#10;&#13;&#10;        GraphicsContext gc = visualizationCanvas.getGraphicsContext2D();&#13;&#10;        gc.clearRect(0, 0, visualizationCanvas.getWidth(), visualizationCanvas.getHeight());&#13;&#10;        gc.setFill(Color.WHITE);&#13;&#10;        gc.fillRect(0, 0, visualizationCanvas.getWidth(), visualizationCanvas.getHeight());&#13;&#10;&#13;&#10;        // Draw system with current state&#13;&#10;        drawSystemWithState(gc);&#13;&#10;    }&#13;&#10;&#13;&#10;    private void drawInitialCanvas() {&#13;&#10;        if (visualizationCanvas == null) return;&#13;&#10;&#13;&#10;        GraphicsContext gc = visualizationCanvas.getGraphicsContext2D();&#13;&#10;        gc.setFill(Color.WHITE);&#13;&#10;        gc.fillRect(0, 0, visualizationCanvas.getWidth(), visualizationCanvas.getHeight());&#13;&#10;&#13;&#10;        gc.setFill(Color.BLACK);&#13;&#10;        gc.setFont(javafx.scene.text.Font.font(16));&#13;&#10;        gc.fillText(&quot;System Visualization Area&quot;, visualizationCanvas.getWidth() / 2 - 90,&#13;&#10;                    visualizationCanvas.getHeight() / 2);&#13;&#10;    }&#13;&#10;&#13;&#10;    private void drawSystemWithState(GraphicsContext gc) {&#13;&#10;        gc.setStroke(Color.BLACK);&#13;&#10;        gc.setLineWidth(2);&#13;&#10;&#13;&#10;        double startX = 50;&#13;&#10;        double startY = 200;  // Reduced from 300 to 200 to fit in smaller canvas&#13;&#10;        double spacing = 100;&#13;&#10;&#13;&#10;        // Draw service points with current state&#13;&#10;        drawServicePoint(gc, startX, startY, &quot;Arrival&quot;, Color.LIGHTGREEN, 0, 0);&#13;&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#13;&#10;&#13;&#10;        startX += spacing;&#13;&#10;        ServicePoint dataStorage = engine.getDataStorage();&#13;&#10;        drawServicePoint(gc, startX, startY, &quot;Data\nStorage&quot;, Color.LIGHTBLUE,&#13;&#10;            dataStorage.getQueueLength(), dataStorage.getBusyServers());&#13;&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#13;&#10;&#13;&#10;        startX += spacing;&#13;&#10;        ServicePoint classification = engine.getClassification();&#13;&#10;        drawServicePoint(gc, startX, startY, &quot;Classification&quot;, Color.LIGHTYELLOW,&#13;&#10;            classification.getQueueLength(), classification.getBusyServers());&#13;&#10;&#13;&#10;        // CPU and GPU paths - now compute service points include their own queues&#13;&#10;        double cpuY = startY - 80;  // Reduced from 100 to 80 for more compact layout&#13;&#10;        double gpuY = startY + 80;  // Reduced from 100 to 80 for more compact layout&#13;&#10;&#13;&#10;        drawArrow(gc, startX + 30, startY - 30, startX + 30, cpuY + 30);&#13;&#10;        double cpuComputeX = startX;&#13;&#10;        ServicePoint cpuCompute = engine.getCpuCompute();&#13;&#10;        drawServicePoint(gc, cpuComputeX, cpuY, &quot;CPU\nCompute&quot;, Color.CORAL,&#13;&#10;            cpuCompute.getQueueLength(), cpuCompute.getBusyServers());&#13;&#10;&#13;&#10;        drawArrow(gc, startX + 30, startY + 30, startX + 30, gpuY - 30);&#13;&#10;        double gpuComputeX = startX;&#13;&#10;        ServicePoint gpuCompute = engine.getGpuCompute();&#13;&#10;        drawServicePoint(gc, gpuComputeX, gpuY, &quot;GPU\nCompute&quot;, Color.PLUM,&#13;&#10;            gpuCompute.getQueueLength(), gpuCompute.getBusyServers());&#13;&#10;&#13;&#10;        double resultX = cpuComputeX + spacing;&#13;&#10;        drawArrow(gc, cpuComputeX + 60, cpuY, resultX, startY);&#13;&#10;        drawArrow(gc, gpuComputeX + 60, gpuY, resultX, startY);&#13;&#10;&#13;&#10;        ServicePoint resultStorage = engine.getResultStorage();&#13;&#10;        drawServicePoint(gc, resultX, startY, &quot;Result\nStorage&quot;, Color.LIGHTGREEN,&#13;&#10;            resultStorage.getQueueLength(), resultStorage.getBusyServers());&#13;&#10;        drawArrow(gc, resultX + 60, startY, resultX + 80, startY);&#13;&#10;&#13;&#10;        gc.fillText(&quot;Exit&quot;, resultX + 85, startY + 5);&#13;&#10;    }&#13;&#10;&#13;&#10;    private void drawServicePoint(GraphicsContext gc, double x, double y, String name,&#13;&#10;                                   Color color, int queueLength, int busyServers) {&#13;&#10;        // Draw box&#13;&#10;        gc.setFill(color);&#13;&#10;        gc.fillRect(x, y - 30, 60, 60);&#13;&#10;        gc.setStroke(Color.BLACK);&#13;&#10;        gc.strokeRect(x, y - 30, 60, 60);&#13;&#10;&#13;&#10;        // Draw name&#13;&#10;        gc.setFill(Color.BLACK);&#13;&#10;        gc.setFont(javafx.scene.text.Font.font(&quot;Arial&quot;, 10));&#13;&#10;        String[] lines = name.split(&quot;\n&quot;);&#13;&#10;        for (int i = 0; i &lt; lines.length; i++) {&#13;&#10;            gc.fillText(lines[i], x + 5, y - 10 + i * 12);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Draw queue length if &gt; 0&#13;&#10;        if (queueLength &gt; 0) {&#13;&#10;            gc.setFill(Color.RED);&#13;&#10;            gc.fillText(&quot;Q:&quot; + queueLength, x + 5, y + 20);&#13;&#10;        }&#13;&#10;&#13;&#10;        // Draw busy servers if &gt; 0&#13;&#10;        if (busyServers &gt; 0) {&#13;&#10;            gc.setFill(Color.BLUE);&#13;&#10;            gc.fillText(&quot;B:&quot; + busyServers, x + 35, y + 20);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void drawArrow(GraphicsContext gc, double x1, double y1, double x2, double y2) {&#13;&#10;        gc.strokeLine(x1, y1, x2, y2);&#13;&#10;&#13;&#10;        // Draw arrowhead&#13;&#10;        double angle = Math.atan2(y2 - y1, x2 - x1);&#13;&#10;        double arrowLength = 10;&#13;&#10;        double arrowAngle = Math.PI / 6;&#13;&#10;&#13;&#10;        double x3 = x2 - arrowLength * Math.cos(angle - arrowAngle);&#13;&#10;        double y3 = y2 - arrowLength * Math.sin(angle - arrowAngle);&#13;&#10;        double x4 = x2 - arrowLength * Math.cos(angle + arrowAngle);&#13;&#10;        double y4 = y2 - arrowLength * Math.sin(angle + arrowAngle);&#13;&#10;&#13;&#10;        gc.strokeLine(x2, y2, x3, y3);&#13;&#10;        gc.strokeLine(x2, y2, x4, y4);&#13;&#10;    }&#13;&#10;&#13;&#10;    private void updateButtonStates(boolean running) {&#13;&#10;        startButton.setDisable(running);&#13;&#10;        pauseButton.setDisable(!running);&#13;&#10;        resumeButton.setDisable(true);&#13;&#10;        stopButton.setDisable(!running);&#13;&#10;    }&#13;&#10;&#13;&#10;    private void updateConfigFromUI() {&#13;&#10;        try {&#13;&#10;            config.setMeanArrivalInterval(Double.parseDouble(arrivalIntervalField.getText()));&#13;&#10;            config.setSimulationTime(Double.parseDouble(simulationTimeField.getText()));&#13;&#10;            config.setNumCpuNodes(Integer.parseInt(cpuNodesField.getText()));&#13;&#10;            config.setNumGpuNodes(Integer.parseInt(gpuNodesField.getText()));&#13;&#10;            config.setCpuTaskProbability(Double.parseDouble(cpuProbabilityField.getText()));&#13;&#10;            config.setResultStorageServiceTime(Double.parseDouble(resultStorageServiceTimeField.getText()));&#13;&#10;        } catch (NumberFormatException e) {&#13;&#10;            showError(&quot;Input Error&quot;, &quot;Please check configuration parameter format&quot;);&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void updateUIFromConfig() {&#13;&#10;        arrivalIntervalField.setText(String.valueOf(config.getMeanArrivalInterval()));&#13;&#10;        simulationTimeField.setText(String.valueOf(config.getSimulationTime()));&#13;&#10;        cpuNodesField.setText(String.valueOf(config.getNumCpuNodes()));&#13;&#10;        gpuNodesField.setText(String.valueOf(config.getNumGpuNodes()));&#13;&#10;        cpuProbabilityField.setText(String.valueOf(config.getCpuTaskProbability()));&#13;&#10;        resultStorageServiceTimeField.setText(String.valueOf(config.getResultStorageServiceTime()));&#13;&#10;    }&#13;&#10;&#13;&#10;    private void copyConfig(SimulationConfig source, SimulationConfig dest) {&#13;&#10;        dest.setMeanArrivalInterval(source.getMeanArrivalInterval());&#13;&#10;        dest.setSimulationTime(source.getSimulationTime());&#13;&#10;        dest.setNumCpuNodes(source.getNumCpuNodes());&#13;&#10;        dest.setNumGpuNodes(source.getNumGpuNodes());&#13;&#10;        dest.setCpuTaskProbability(source.getCpuTaskProbability());&#13;&#10;        dest.setNormalUserProbability(source.getNormalUserProbability());&#13;&#10;        dest.setPersonalVipProbability(source.getPersonalVipProbability());&#13;&#10;        dest.setEnterpriseVipProbability(source.getEnterpriseVipProbability());&#13;&#10;    }&#13;&#10;&#13;&#10;    // ========== Utility Methods ==========&#13;&#10;&#13;&#10;    private void showInfo(String title, String message) {&#13;&#10;        Alert alert = new Alert(Alert.AlertType.INFORMATION);&#13;&#10;        alert.setTitle(title);&#13;&#10;        alert.setHeaderText(null);&#13;&#10;        alert.setContentText(message);&#13;&#10;        alert.showAndWait();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void showError(String title, String message) {&#13;&#10;        Alert alert = new Alert(Alert.AlertType.ERROR);&#13;&#10;        alert.setTitle(title);&#13;&#10;        alert.setHeaderText(null);&#13;&#10;        alert.setContentText(message);&#13;&#10;        alert.showAndWait();&#13;&#10;    }&#13;&#10;&#13;&#10;    // ========== Getters ==========&#13;&#10;&#13;&#10;    public SimulationEngine getEngine() {&#13;&#10;        return engine;&#13;&#10;    }&#13;&#10;&#13;&#10;    public SimulationConfig getConfig() {&#13;&#10;        return config;&#13;&#10;    }&#13;&#10;&#13;&#10;    public SimulationResults getResults() {&#13;&#10;        return engine != null ? engine.getResults() : null;&#13;&#10;    }&#13;&#10;&#13;&#10;    public double getCurrentTime() {&#13;&#10;        return Clock.getInstance().getTime();&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>