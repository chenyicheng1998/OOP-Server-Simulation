<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/USER_GUIDE.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/USER_GUIDE.md" />
              <option name="updatedContent" value="# 用户使用指南 (User Guide)&#10;&#10;##  文档说明&#10;&#10;本指南详细介绍云计算服务队列仿真系统的界面元素、参数含义和使用方法。&#10;&#10;**相关文档**：&#10;- **SCENARIO_GUIDE.md** - 场景化应用案例指南&#10;- **STATISTICS_IMPLEMENTATION.md** - 技术实现细节（开发者参考）&#10;&#10;---&#10;&#10;##  界面布局概览&#10;&#10;### 顶部控制面板&#10;- ▶️ Start / ⏸ Pause / ▶️ Resume / ⏹ Stop /  Reset 按钮&#10;- ⏱ 仿真时间显示&#10;-  速度控制滑块（0.1x - 100x）&#10;&#10;### 中央可视化区域&#10;- 系统流程可视化画布&#10;- 实时显示任务流动和服务点状态&#10;&#10;### 右侧统计面板&#10;- Overall Statistics (总体统计)&#10;- Queue Statistics (队列统计)&#10;- User Type Statistics (用户类型统计)&#10;- Task Type Statistics (任务类型统计)&#10;&#10;### 底部配置面板&#10;- 仿真参数配置&#10;- 数据库连接状态&#10;- 配置保存/加载功能&#10;- 历史仿真记录表&#10;&#10;---&#10;&#10;##  右侧统计面板详细说明&#10;&#10;### 1. Overall Statistics (总体统计)&#10;&#10;#### **Tasks Arrived (到达任务数)**&#10;**含义**: 系统中已到达的任务总数&#10;&#10;**作用**: 监控系统负载，了解有多少任务进入系统&#10;&#10;---&#10;&#10;#### **Tasks Completed (完成任务数)**&#10;**含义**: 系统已完成处理的任务总数&#10;&#10;**作用**: &#10;- 与到达任务数对比，了解系统处理进度&#10;- 如果完成数远小于到达数，说明系统存在积压&#10;&#10;---&#10;&#10;#### **Avg System Time (平均系统时间)**&#10;**含义**: 每个任务从到达系统到完成服务所经历的平均总时间（单位：秒）&#10;&#10;**计算公式**:&#10;```&#10;平均系统时间 = 所有已完成任务的系统时间总和 ÷ 已完成任务数量&#10;```&#10;&#10;**系统时间包括**:&#10;- 在各个队列中的等待时间&#10;- 在各个服务点的服务时间&#10;- 整个流程的总耗时&#10;&#10;**作用**:&#10;- 衡量系统的响应速度&#10;- 越小说明系统处理速度越快，用户体验越好&#10;- 如果这个值过大，说明系统可能存在瓶颈（队列太长、服务器不够等）&#10;&#10;**示例解读**:&#10;- `15.30s` → 平均每个任务需要15.3秒完成&#10;- `2.50s` → 平均每个任务需要2.5秒完成（系统效率高）&#10;- `45.00s` → 平均每个任务需要45秒完成（系统可能过载）&#10;&#10;---&#10;&#10;#### **Throughput (吞吐量)**&#10;**含义**: 系统每秒钟完成的任务数量（单位：任务/秒）&#10;&#10;**计算公式**:&#10;```&#10;吞吐量 = 已完成任务总数 ÷ 仿真运行时间&#10;```&#10;&#10;**作用**:&#10;- 衡量系统的处理能力&#10;- 越大说明系统在单位时间内处理的任务越多，性能越好&#10;- 这是评估云计算服务容量的关键指标&#10;&#10;**示例解读**:&#10;- `0.500/s` → 每秒完成0.5个任务（每2秒完成1个任务）&#10;- `2.000/s` → 每秒完成2个任务&#10;- `0.050/s` → 每秒完成0.05个任务（每20秒完成1个任务，系统效率很低）&#10;&#10;**影响因素**:&#10;- CPU/GPU节点数量（服务器越多，吞吐量越大）&#10;- 任务到达频率&#10;- 各服务点的处理速度&#10;- 队列管理策略&#10;&#10;---&#10;&#10;### 2. Queue Statistics (队列统计)&#10;&#10;**含义**: 实时显示系统中所有服务点的队列状态和利用率&#10;&#10;**显示内容**:&#10;&#10;####  Data Storage (数据存储)&#10;- **Queue**: 当前队列中等待的任务数量&#10;- **Busy**: 繁忙服务器数 / 总服务器数 (1个服务器)&#10;- **Max**: 仿真过程中队列的最大长度&#10;- **Utilization**: 服务器利用率百分比&#10;&#10;####  Classification (分类服务)&#10;- **Queue**: 当前队列中等待的任务数量&#10;- **Busy**: 繁忙服务器数 / 总服务器数 (1个服务器)&#10;- **Max**: 仿真过程中队列的最大长度&#10;- **Utilization**: 服务器利用率百分比&#10;&#10;####  CPU Queue (CPU等待队列)&#10;- **Waiting**: 当前等待分配到CPU节点的任务数量&#10;- **Max**: 等待队列的历史最大长度&#10;&#10;####  CPU Compute (CPU计算节点)&#10;- **Queue**: 当前队列中的任务数量&#10;- **Busy**: 繁忙节点数 / 总节点数（根据配置）&#10;- **Max**: 队列的历史最大长度&#10;- **Utilization**: CPU节点利用率百分比&#10;- **Served**: 已服务完成的任务总数&#10;&#10;####  GPU Queue (GPU等待队列)&#10;- **Waiting**: 当前等待分配到GPU节点的任务数量&#10;- **Max**: 等待队列的历史最大长度&#10;&#10;####  GPU Compute (GPU计算节点)&#10;- **Queue**: 当前队列中的任务数量&#10;- **Busy**: 繁忙节点数 / 总节点数（根据配置）&#10;- **Max**: 队列的历史最大长度&#10;- **Utilization**: GPU节点利用率百分比&#10;- **Served**: 已服务完成的任务总数&#10;&#10;####  Result Storage (结果存储)&#10;- **Queue**: 当前队列中等待的任务数量&#10;- **Busy**: 繁忙服务器数 / 总服务器数 (1个服务器)&#10;- **Max**: 仿真过程中队列的最大长度&#10;- **Utilization**: 服务器利用率百分比&#10;&#10;**作用**:&#10;-  **识别瓶颈**: 哪个队列最长？哪个服务点利用率最高？&#10;- ⚡ **优化资源**: 根据利用率决定是否需要增加/减少服务器&#10;-  **实时监控**: 观察系统运行状态，发现异常&#10;&#10;**利用率解读**:&#10;- `&lt; 30%` →  资源闲置，可能配置过多&#10;- `30% - 90%` → ✅ 资源利用良好，系统平衡&#10;- `&gt; 90%` → ⚠️ 资源过载，建议增加服务器&#10;&#10;---&#10;&#10;### 3. User Type Statistics (用户类型统计)&#10;&#10;**含义**: 按用户类型分析任务完成情况和服务质量&#10;&#10;**用户类型说明**:&#10;1. ** NORMAL (普通用户)** - 优先级最低&#10;2. **⭐ PERSONAL_VIP (个人VIP)** - 优先级中等&#10;3. **⭐⭐ ENTERPRISE_VIP (企业VIP)** - 优先级最高&#10;&#10;**显示内容**:&#10;&#10;####  NORMAL Users&#10;- **Completed**: 完成的任务数量&#10;- **百分比**: 占总完成任务的比例&#10;- **Avg System Time**: 该类型用户的平均系统时间&#10;&#10;#### ⭐ PERSONAL VIP&#10;- **Completed**: 完成的任务数量&#10;- **百分比**: 占总完成任务的比例&#10;- **Avg System Time**: 该类型用户的平均系统时间&#10;&#10;#### ⭐⭐ ENTERPRISE VIP&#10;- **Completed**: 完成的任务数量&#10;- **百分比**: 占总完成任务的比例&#10;- **Avg System Time**: 该类型用户的平均系统时间&#10;&#10;####  Priority Effect (优先级效果)&#10;- 显示企业VIP相比普通用户的速度提升百分比&#10;- 验证优先级策略是否有效&#10;&#10;**作用**:&#10;- ✅ 验证VIP优先级策略效果&#10;-  分析不同用户群体的服务质量差异&#10;-  评估差异化定价策略的合理性&#10;-  向客户展示VIP服务的价值&#10;&#10;**示例输出**:&#10;```&#10; NORMAL Users:&#10;   Completed: 150 (50.0%)&#10;   Avg System Time: 18.45s&#10;&#10;⭐ PERSONAL VIP:&#10;   Completed: 90 (30.0%)&#10;   Avg System Time: 12.23s&#10;&#10;⭐⭐ ENTERPRISE VIP:&#10;   Completed: 60 (20.0%)&#10;   Avg System Time: 8.76s&#10;&#10; Priority Effect:&#10;   Enterprise VIP is 52.5% faster&#10;```&#10;&#10;---&#10;&#10;### 4. Task Type Statistics (任务类型统计)&#10;&#10;**含义**: 按任务类型分析处理情况和资源使用&#10;&#10;**任务类型说明**:&#10;1. ** CPU Tasks** - 需要CPU节点处理的计算任务&#10;2. ** GPU Tasks** - 需要GPU节点处理的图形/深度学习任务&#10;&#10;**显示内容**:&#10;&#10;####  CPU Tasks&#10;- **Completed**: 完成的CPU任务数量&#10;- **百分比**: 占总完成任务的比例&#10;- **Avg System Time**: CPU任务的平均系统时间&#10;- **Node Utilization**: CPU节点的利用率百分比&#10;&#10;####  GPU Tasks&#10;- **Completed**: 完成的GPU任务数量&#10;- **百分比**: 占总完成任务的比例&#10;- **Avg System Time**: GPU任务的平均系统时间&#10;- **Node Utilization**: GPU节点的利用率百分比&#10;&#10;#### ⚡ Resource Efficiency (资源效率分析)&#10;自动分析资源使用效率并给出建议：&#10;- ✅ **节点平衡** (30%-90% 利用率) - 资源配置合理&#10;- ⚠️ **节点过载** (&gt;90% 利用率) - 建议增加节点数量&#10;-  **节点闲置** (&lt;30% 利用率) - 建议减少节点或增加负载&#10;&#10;**作用**:&#10;-  评估CPU/GPU资源使用效率&#10;-  优化硬件配置和成本&#10;-  指导资源调整决策&#10;-  平衡不同类型任务的处理能力&#10;&#10;**示例输出**:&#10;```&#10; CPU Tasks:&#10;   Completed: 210 (70.0%)&#10;   Avg System Time: 15.23s&#10;   Node Utilization: 85.3%&#10;&#10; GPU Tasks:&#10;   Completed: 90 (30.0%)&#10;   Avg System Time: 16.45s&#10;   Node Utilization: 45.7%&#10;&#10;⚡ Resource Efficiency:&#10;   ✅ CPU nodes balanced&#10;    GPU nodes underutilized&#10;```&#10;&#10;---&#10;&#10;## ⚙️ 底部配置面板详细说明&#10;&#10;### Mean Arrival Interval (平均到达间隔)&#10;&#10;**范围**: 通常 0.1 - 10.0 秒&#10;&#10;**含义**: 任务到达系统的平均时间间隔&#10;&#10;**调整效果**:&#10;- **减小** (例如 2.0 → 0.5)&#10;  - 任务到达更频繁&#10;  - 系统负载增加&#10;  - 队列会变长&#10;  - 平均系统时间会增加&#10;  - 可能观察到系统过载现象&#10;  &#10;- **增大** (例如 2.0 → 5.0)&#10;  - 任务到达更稀疏&#10;  - 系统负载降低&#10;  - 队列较短或为空&#10;  - 平均系统时间减少&#10;  - 服务器可能闲置&#10;&#10;**实际意义**: 模拟不同时段的用户访问量（高峰期 vs 低谷期）&#10;&#10;**建议值**: &#10;- 高负载测试：0.5 - 1.0s&#10;- 正常负载：1.5 - 3.0s&#10;- 轻负载：4.0 - 10.0s&#10;&#10;---&#10;&#10;### Simulation Time (仿真时间)&#10;&#10;**范围**: 100 - 10000 秒&#10;&#10;**含义**: 仿真运行的总时长&#10;&#10;**调整效果**:&#10;- **短时间** (例如 100s)&#10;  - 快速获得结果&#10;  - 但可能样本不足，统计不稳定&#10;  &#10;- **长时间** (例如 5000s)&#10;  - 更准确的统计结果&#10;  - 可以观察系统的长期行为&#10;  - 但运行时间更长&#10;&#10;**实际意义**: 平衡仿真精度和运行时间&#10;&#10;**建议值**:&#10;- 快速测试：100 - 500s&#10;- 标准仿真：1000 - 2000s&#10;- 详细分析：3000 - 5000s&#10;&#10;---&#10;&#10;### CPU Nodes (CPU节点数)&#10;&#10;**范围**: 通常 1 - 10&#10;&#10;**含义**: 系统中CPU服务器的数量&#10;&#10;**调整效果**:&#10;- **增加** (例如 2 → 4)&#10;  - CPU任务处理能力提升&#10;  - CPU队列等待时间减少&#10;  - 整体吞吐量增加（如果CPU是瓶颈）&#10;  - 但增加硬件成本&#10;  &#10;- **减少** (例如 2 → 1)&#10;  - CPU任务处理能力下降&#10;  - CPU队列变长&#10;  - 可能成为系统瓶颈&#10;&#10;**实际意义**: 评估硬件投资（增加服务器）对性能提升的效果&#10;&#10;**建议**:&#10;- 观察CPU Compute的利用率&#10;- 如果 &gt;90%，考虑增加节点&#10;- 如果 &lt;30%，考虑减少节点&#10;&#10;---&#10;&#10;### GPU Nodes (GPU节点数)&#10;&#10;**范围**: 通常 1 - 5&#10;&#10;**含义**: 系统中GPU服务器的数量&#10;&#10;**调整效果**: 与CPU Nodes类似，但针对GPU任务&#10;&#10;**实际意义**: &#10;- GPU硬件成本通常更高&#10;- 需要更谨慎地评估配置需求&#10;&#10;**建议**:&#10;- 观察GPU Compute的利用率&#10;- 根据GPU任务比例调整&#10;- 考虑成本-性能平衡&#10;&#10;---&#10;&#10;### CPU Task Probability (CPU任务概率)&#10;&#10;**范围**: 0.0 - 1.0（例如 0.7 = 70%）&#10;&#10;**含义**: 新到达任务是CPU任务的概率&#10;&#10;**调整效果**:&#10;- **0.7** = 70% CPU任务，30% GPU任务&#10;- **0.9** = 90% CPU任务，10% GPU任务&#10;  - CPU队列压力大&#10;  - GPU资源可能闲置&#10;  - 需要更多CPU节点&#10;  &#10;- **0.3** = 30% CPU任务，70% GPU任务&#10;  - GPU队列压力大&#10;  - CPU资源可能闲置&#10;  - 需要更多GPU节点&#10;&#10;**实际意义**: &#10;- 模拟不同应用场景的任务分布&#10;- 普通Web服务：高CPU概率 (0.8-0.9)&#10;- AI/机器学习：低CPU概率 (0.2-0.4)&#10;- 混合场景：中等概率 (0.5-0.7)&#10;&#10;**建议**:&#10;- 根据实际业务场景设置&#10;- 观察两种资源的利用率平衡&#10;&#10;---&#10;&#10;### Database连接和功能&#10;&#10;#### Database Status (数据库状态)&#10;&#10;**显示内容**:&#10;- ✅ **Connected** - 数据库连接成功&#10;- ❌ **Not Connected** - 数据库未连接&#10;&#10;#### Test 按钮&#10;&#10;**功能**: 测试数据库连接&#10;&#10;**点击后的效果**:&#10;1. 尝试连接到MariaDB数据库&#10;2. 测试数据库中的表是否存在&#10;3. 更新连接状态标签&#10;&#10;**成功时**:&#10;- 标签变为：`✅ Connected` (绿色)&#10;- 弹出信息框：`Database connection successful!`&#10;- 可以使用数据库功能&#10;&#10;**失败时**:&#10;- 标签保持：`❌ Not Connected` (红色)&#10;- 弹出错误框：显示具体错误信息&#10;- 数据库相关功能不可用&#10;&#10;#### 数据库功能（需要连接成功）&#10;&#10;** Save Config (保存配置)**&#10;- 将当前仿真配置保存到数据库&#10;- 可以为配置命名&#10;- 方便后续重复使用&#10;&#10;** Load Config (加载配置)**&#10;- 从数据库加载已保存的配置&#10;- 选择配置名称&#10;- 自动填充所有参数&#10;&#10;** View History (查看历史)**&#10;- 在底部表格中显示历史仿真记录&#10;- 包含运行时间、完成任务数、吞吐量等&#10;- 可以对比不同配置的效果&#10;&#10;---&#10;&#10;##  控制按钮说明&#10;&#10;### ▶️ Start (开始)&#10;- 使用当前配置开始新的仿真&#10;- 初始化所有统计数据&#10;- 创建数据库记录（如果连接）&#10;&#10;### ⏸ Pause (暂停)&#10;- 暂停仿真运行&#10;- 保持当前状态&#10;- 可以观察统计数据&#10;&#10;### ▶️ Resume (继续)&#10;- 从暂停状态继续运行&#10;- 保持之前的统计数据&#10;&#10;### ⏹ Stop (停止)&#10;- 停止仿真运行&#10;- 保存结果到数据库（如果连接）&#10;- 显示最终统计结果&#10;&#10;###  Reset (重置)&#10;- 重置仿真到初始状态&#10;- 清空所有统计数据&#10;- 保持当前配置参数&#10;&#10;###  Speed Control (速度控制)&#10;- 滑块范围：0.1x - 100x&#10;- 调整仿真运行速度&#10;- 1x = 实时速度&#10;- 100x = 快速仿真（用于快速获得结果）&#10;- 0.1x = 慢速仿真（用于详细观察）&#10;&#10;---&#10;&#10;##  基本使用流程&#10;&#10;### 1. 配置参数&#10;1. 在底部面板设置仿真参数：&#10;   - Mean Arrival Interval&#10;   - Simulation Time&#10;   - CPU/GPU Nodes&#10;   - CPU Task Probability&#10;&#10;### 2. 开始仿真&#10;1. 点击 ▶️ Start 按钮&#10;2. 观察中央可视化区域的动画&#10;3. 观察右侧统计面板的实时数据&#10;&#10;### 3. 控制仿真&#10;- 使用 ⏸ Pause 暂停观察&#10;- 使用 ▶️ Resume 继续&#10;- 调整  Speed 控制速度&#10;&#10;### 4. 分析结果&#10;1. 查看 Overall Statistics - 了解整体性能&#10;2. 查看 Queue Statistics - 识别瓶颈&#10;3. 查看 User Type Statistics - 验证优先级策略&#10;4. 查看 Task Type Statistics - 评估资源使用&#10;&#10;### 5. 优化配置&#10;1. 根据统计结果调整参数&#10;2. 重新运行仿真&#10;3. 对比不同配置的效果&#10;&#10;### 6. 保存结果（可选）&#10;1. 确保数据库连接&#10;2. 使用  Save Config 保存优秀配置&#10;3. 查看  History 对比历史数据&#10;&#10;---&#10;&#10;##  使用技巧&#10;&#10;### 快速测试&#10;1. 设置较短的 Simulation Time (100-500s)&#10;2. 提高 Speed 到 10x - 50x&#10;3. 快速获得初步结果&#10;&#10;### 详细分析&#10;1. 设置较长的 Simulation Time (2000-5000s)&#10;2. 使用正常 Speed (1x - 5x)&#10;3. 仔细观察各项指标变化&#10;&#10;### 识别瓶颈&#10;1. 运行仿真&#10;2. 观察 Queue Statistics&#10;3. 找到利用率 &gt;90% 或队列最长的服务点&#10;4. 调整相应资源配置&#10;&#10;### 参数优化&#10;1. **每次只改变一个参数**&#10;2. 记录每次的关键指标&#10;3. 对比找出最优配置&#10;4. 使用 Save Config 保存&#10;&#10;### 对比实验&#10;1. 保存多个不同配置&#10;2. 依次运行&#10;3. 记录关键指标&#10;4. 制作对比表格&#10;&#10;---&#10;&#10;## ⚠️ 常见问题&#10;&#10;### Q1: 统计面板没有数据？&#10;**A**: 需要点击 Start 开始仿真后才会有数据更新&#10;&#10;### Q2: 数据库连接失败？&#10;**A**: 检查 `database.properties` 文件，确保用户名密码正确，MariaDB服务正在运行&#10;&#10;### Q3: 仿真运行很慢？&#10;**A**: 调高 Speed 滑块，或者减少 Simulation Time&#10;&#10;### Q4: 如何判断系统性能好坏？&#10;**A**: 主要看两个指标：&#10;- Avg System Time - 越小越好&#10;- Throughput - 越大越好&#10;&#10;### Q5: 利用率多少算合理？&#10;**A**: 30%-90% 为合理范围，&gt;90% 过载，&lt;30% 浪费&#10;&#10;---&#10;&#10;##  下一步&#10;&#10;查看 **SCENARIO_GUIDE.md** 了解具体应用场景和实战案例！&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/simulation/controller/SimulationController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/simulation/controller/SimulationController.java" />
              <option name="originalContent" value="package com.simulation.controller;&#10;&#10;import com.simulation.database.DatabaseManager;&#10;import com.simulation.database.SimulationConfigDAO;&#10;import com.simulation.database.SimulationResultsDAO;&#10;import com.simulation.model.*;&#10;import javafx.application.Platform;&#10;import javafx.beans.property.SimpleStringProperty;&#10;import javafx.collections.FXCollections;&#10;import javafx.fxml.FXML;&#10;import javafx.scene.canvas.Canvas;&#10;import javafx.scene.canvas.GraphicsContext;&#10;import javafx.scene.control.*;&#10;import javafx.scene.paint.Color;&#10;import javafx.stage.Stage;&#10;&#10;import java.sql.SQLException;&#10;import java.util.*;&#10;&#10;/**&#10; * FXML Controller that mediates between View and Model&#10; * Handles UI events and database operations&#10; */&#10;public class SimulationController {&#10;    // FXML Components&#10;    @FXML private Button startButton;&#10;    @FXML private Button pauseButton;&#10;    @FXML private Button resumeButton;&#10;    @FXML private Button stopButton;&#10;    @FXML private Button resetButton;&#10;&#10;    @FXML private Label timeLabel;&#10;    @FXML private Label speedLabel;&#10;    @FXML private Label arrivedTasksLabel;&#10;    @FXML private Label completedTasksLabel;&#10;    @FXML private Label avgSystemTimeLabel;&#10;    @FXML private Label throughputLabel;&#10;    @FXML private Label queueStatsLabel;&#10;    @FXML private Label userTypeStatsLabel;&#10;    @FXML private Label taskTypeStatsLabel;&#10;    @FXML private Label dbStatusLabel;&#10;&#10;    @FXML private TextField arrivalIntervalField;&#10;    @FXML private TextField simulationTimeField;&#10;    @FXML private TextField cpuNodesField;&#10;    @FXML private TextField gpuNodesField;&#10;    @FXML private TextField cpuProbabilityField;&#10;&#10;    @FXML private Slider speedSlider;&#10;    @FXML private Canvas visualizationCanvas;&#10;&#10;    @FXML private TableView&lt;Map&lt;String,Object&gt;&gt; historyTable;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; runIdColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; runNameColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; startTimeColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; endTimeColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; completedTasksColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; avgSystemTimeColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; throughputColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; statusColumn;&#10;&#10;&#10;&#10;    // Model components&#10;    private SimulationEngine engine;&#10;    private final SimulationConfig config;&#10;&#10;    // Database components&#10;    private final DatabaseManager dbManager;&#10;    private final SimulationConfigDAO configDAO;&#10;    private final SimulationResultsDAO resultsDAO;&#10;    private Integer currentRunId;&#10;&#10;    // UI update throttling&#10;    private long lastUpdateTime = 0;&#10;    private static final long UPDATE_INTERVAL_MS = 100; // Update UI every 100ms&#10;&#10;    public SimulationController() {&#10;        this.config = new SimulationConfig();&#10;        this.dbManager = DatabaseManager.getInstance();&#10;&#10;        // Initialize DAO objects, but they will handle database unavailability internally&#10;        SimulationConfigDAO tempConfigDAO = null;&#10;        SimulationResultsDAO tempResultsDAO = null;&#10;        try {&#10;            tempConfigDAO = new SimulationConfigDAO();&#10;            tempResultsDAO = new SimulationResultsDAO();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;⚠️  Could not initialize database DAOs: &quot; + e.getMessage());&#10;        }&#10;        this.configDAO = tempConfigDAO;&#10;        this.resultsDAO = tempResultsDAO;&#10;    }&#10;&#10;    /**&#10;     * Initialize method called after FXML loading&#10;     */&#10;    @FXML&#10;    public void initialize() {&#10;        // Setup speed slider listener&#10;        if (speedSlider != null) {&#10;            speedSlider.valueProperty().addListener((obs, oldVal, newVal) -&gt; {&#10;                double speed = newVal.doubleValue();&#10;                // Format speed display: show 1 decimal for &lt; 10x, integer for &gt;= 10x&#10;                if (speed &gt;= 10.0) {&#10;                    speedLabel.setText(String.format(&quot;%.0fx&quot;, speed));&#10;                } else {&#10;                    speedLabel.setText(String.format(&quot;%.1fx&quot;, speed));&#10;                }&#10;                if (engine != null) {&#10;                    engine.setSpeed(speed);&#10;                }&#10;            });&#10;        }&#10;&#10;        // Test database connection&#10;        testDatabaseConnection();&#10;&#10;        // Initialize canvas&#10;        if (visualizationCanvas != null) {&#10;            drawInitialCanvas();&#10;        }&#10;        // === Table column bindings ===&#10;        runIdColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;runId&quot;)))&#10;        );&#10;&#10;        runNameColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;runName&quot;)))&#10;        );&#10;&#10;        startTimeColumn.setCellValueFactory(cell -&gt; {&#10;            Object ts = cell.getValue().get(&quot;startTime&quot;);&#10;            return new SimpleStringProperty(ts == null ? &quot;&quot; : ts.toString());&#10;        });&#10;&#10;        endTimeColumn.setCellValueFactory(cell -&gt; {&#10;            Object ts = cell.getValue().get(&quot;endTime&quot;);&#10;            return new SimpleStringProperty(ts == null ? &quot;&quot; : ts.toString());&#10;        });&#10;&#10;        completedTasksColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;totalTasks&quot;)))&#10;        );&#10;&#10;        avgSystemTimeColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(&#10;                        String.format(&quot;%.3f&quot;,&#10;                                (double) cell.getValue().get(&quot;avgSystemTime&quot;))&#10;                )&#10;        );&#10;&#10;        throughputColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(&#10;                        String.format(&quot;%.3f&quot;,&#10;                                (double) cell.getValue().get(&quot;throughput&quot;))&#10;                )&#10;        );&#10;&#10;        statusColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;status&quot;)))&#10;        );&#10;&#10;        // Auto-load history on startup&#10;        loadHistoryData();&#10;    }&#10;&#10;&#10;        // ========== FXML Event Handlers ==========&#10;&#10;    @FXML&#10;    private void handleStart() {&#10;        updateConfigFromUI();&#10;        initializeSimulation();&#10;&#10;        // Apply current speed from slider to the new engine&#10;        if (engine != null &amp;&amp; speedSlider != null) {&#10;            engine.setSpeed(speedSlider.getValue());&#10;        }&#10;&#10;        // Create database run record&#10;        try {&#10;            currentRunId = resultsDAO.createSimulationRun(null,&#10;                &quot;Simulation Run &quot; + System.currentTimeMillis());&#10;        } catch (SQLException e) {&#10;            showError(&quot;Database Error&quot;, &quot;Failed to create run record: &quot; + e.getMessage());&#10;        }&#10;&#10;        startSimulation();&#10;        updateButtonStates(true);&#10;    }&#10;&#10;    @FXML&#10;    private void handlePause() {&#10;        pauseSimulation();&#10;        pauseButton.setDisable(true);&#10;        resumeButton.setDisable(false);&#10;    }&#10;&#10;    @FXML&#10;    private void handleResume() {&#10;        resumeSimulation();&#10;        pauseButton.setDisable(false);&#10;        resumeButton.setDisable(true);&#10;    }&#10;&#10;    @FXML&#10;    private void handleStop() {&#10;        stopSimulation();&#10;&#10;        // Save results to database&#10;        if (currentRunId != null) {&#10;            saveResultsToDatabase();&#10;        }&#10;&#10;        updateButtonStates(false);&#10;    }&#10;&#10;    @FXML&#10;    private void handleReset() {&#10;        stopSimulation();&#10;        initializeSimulation();&#10;&#10;        // Apply current speed from slider to the reset engine&#10;        if (engine != null &amp;&amp; speedSlider != null) {&#10;            engine.setSpeed(speedSlider.getValue());&#10;        }&#10;&#10;        updateStatistics();&#10;        updateButtonStates(false);&#10;    }&#10;&#10;    @FXML&#10;    private void handleSaveConfig() {&#10;        TextInputDialog dialog = new TextInputDialog(&quot;My Configuration&quot;);&#10;        dialog.setTitle(&quot;Save Configuration&quot;);&#10;        dialog.setHeaderText(&quot;Save current configuration to database&quot;);&#10;        dialog.setContentText(&quot;Configuration Name:&quot;);&#10;&#10;        Optional&lt;String&gt; result = dialog.showAndWait();&#10;        result.ifPresent(name -&gt; {&#10;            try {&#10;                updateConfigFromUI();&#10;                configDAO.saveConfig(config, name);&#10;                showInfo(&quot;Success&quot;, &quot;Configuration saved: &quot; + name);&#10;            } catch (SQLException e) {&#10;                showError(&quot;Error&quot;, &quot;Failed to save configuration: &quot; + e.getMessage());&#10;            }&#10;        });&#10;    }&#10;&#10;    @FXML&#10;    private void handleLoadConfig() {&#10;        try {&#10;            List&lt;String&gt; configNames = configDAO.getAllConfigNames();&#10;&#10;            ChoiceDialog&lt;String&gt; dialog = new ChoiceDialog&lt;&gt;(&#10;                configNames.isEmpty() ? null : configNames.get(0), configNames);&#10;            dialog.setTitle(&quot;Load Configuration&quot;);&#10;            dialog.setHeaderText(&quot;Load configuration from database&quot;);&#10;            dialog.setContentText(&quot;Select Configuration:&quot;);&#10;&#10;            Optional&lt;String&gt; result = dialog.showAndWait();&#10;            result.ifPresent(name -&gt; {&#10;                try {&#10;                    SimulationConfig loadedConfig = configDAO.loadConfigByName(name);&#10;                    if (loadedConfig != null) {&#10;                        copyConfig(loadedConfig, config);&#10;                        updateUIFromConfig();&#10;                        showInfo(&quot;Success&quot;, &quot;Configuration loaded: &quot; + name);&#10;                    }&#10;                } catch (SQLException e) {&#10;                    showError(&quot;Error&quot;, &quot;Failed to load configuration: &quot; + e.getMessage());&#10;                }&#10;            });&#10;        } catch (SQLException e) {&#10;            showError(&quot;Error&quot;, &quot;Failed to get configuration list: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Load history data from database and display in table&#10;     */&#10;    private void loadHistoryData() {&#10;        if (resultsDAO == null) {&#10;            System.out.println(&quot;⚠️  Database not available - cannot load history&quot;);&#10;            return;&#10;        }&#10;&#10;        try {&#10;            List&lt;Map&lt;String,Object&gt;&gt; runs = resultsDAO.getAllSimulationRuns();&#10;            System.out.println(&quot;✅ History loaded: &quot; + runs.size() + &quot; simulation runs found&quot;);&#10;&#10;            if (historyTable != null) {&#10;                historyTable.setItems(FXCollections.observableArrayList(runs));&#10;                historyTable.refresh();&#10;                System.out.println(&quot;✅ History table updated in UI&quot;);&#10;            } else {&#10;                System.err.println(&quot;⚠️  History table is null!&quot;);&#10;            }&#10;        } catch (SQLException e) {&#10;            System.err.println(&quot;❌ Failed to load history: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;❌ Unexpected error loading history: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    @FXML&#10;    private void handleViewHistory() {&#10;        System.out.println(&quot; View History button clicked!&quot;);&#10;        loadHistoryData();&#10;    }&#10;&#10;&#10;    @FXML&#10;    private void handleTestDatabase() {&#10;        testDatabaseConnection();&#10;    }&#10;&#10;    // ========== Simulation Control Methods ==========&#10;&#10;    public void initializeSimulation() {&#10;        if (engine != null &amp;&amp; engine.isAlive()) {&#10;            engine.stopSimulation();&#10;            try {&#10;                engine.join(1000);&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;&#10;        engine = new SimulationEngine(config);&#10;        engine.initialize();&#10;        setupSimulationListener();&#10;    }&#10;&#10;    public void startSimulation() {&#10;        if (engine != null &amp;&amp; !engine.isRunning()) {&#10;            engine.start();&#10;        }&#10;    }&#10;&#10;    public void pauseSimulation() {&#10;        if (engine != null) {&#10;            engine.pauseSimulation();&#10;        }&#10;    }&#10;&#10;    public void resumeSimulation() {&#10;        if (engine != null) {&#10;            engine.resumeSimulation();&#10;        }&#10;    }&#10;&#10;    public void stopSimulation() {&#10;        if (engine != null) {&#10;            engine.stopSimulation();&#10;        }&#10;    }&#10;&#10;    public void stepSimulation() {&#10;        if (engine != null) {&#10;            engine.stepForward();&#10;        }&#10;    }&#10;&#10;    public void setSimulationListener(SimulationEngine.SimulationListener listener) {&#10;        if (engine != null) {&#10;            engine.setListener(listener);&#10;        }&#10;    }&#10;&#10;    // ========== Database Methods ==========&#10;&#10;    private void testDatabaseConnection() {&#10;        boolean connected = dbManager.testConnection();&#10;        Platform.runLater(() -&gt; {&#10;            if (connected) {&#10;                dbStatusLabel.setText(&quot;✅ Connected&quot;);&#10;                dbStatusLabel.setStyle(&quot;-fx-text-fill: green;&quot;);&#10;            } else {&#10;                dbStatusLabel.setText(&quot;❌ Not Connected&quot;);&#10;                dbStatusLabel.setStyle(&quot;-fx-text-fill: red;&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void saveResultsToDatabase() {&#10;        if (currentRunId == null || engine == null) return;&#10;&#10;        try {&#10;            SimulationResults results = engine.getResults();&#10;            resultsDAO.updateSimulationRun(currentRunId, results, &quot;COMPLETED&quot;);&#10;&#10;            // Save completed tasks&#10;            if (!results.getCompletedTasks().isEmpty()) {&#10;                resultsDAO.saveTasks(currentRunId, results.getCompletedTasks());&#10;            }&#10;&#10;            showInfo(&quot;Success&quot;, &quot;Simulation results saved to database&quot;);&#10;        } catch (SQLException e) {&#10;            showError(&quot;Database Error&quot;, &quot;Failed to save results: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    // ========== UI Update Methods ==========&#10;&#10;    private void setupSimulationListener() {&#10;        if (engine != null) {&#10;            engine.setListener(new SimulationEngine.SimulationListener() {&#10;                @Override&#10;                public void onTimeUpdate(double time) {&#10;                    // Throttle UI updates to prevent stuttering&#10;                    long currentTime = System.currentTimeMillis();&#10;                    if (currentTime - lastUpdateTime &gt;= UPDATE_INTERVAL_MS) {&#10;                        lastUpdateTime = currentTime;&#10;                        Platform.runLater(() -&gt; {&#10;                            timeLabel.setText(String.format(&quot;%.2fs&quot;, time));&#10;                            updateStatistics();&#10;                            updateVisualization();&#10;                        });&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onSimulationComplete() {&#10;                    Platform.runLater(() -&gt; {&#10;                        // Final update to show accurate completion state&#10;                        updateStatistics();&#10;                        updateVisualization();&#10;                        updateButtonStates(false);&#10;                        if (currentRunId != null) {&#10;                            saveResultsToDatabase();&#10;                        }&#10;                        showInfo(&quot;Complete&quot;, &quot;Simulation completed!&quot;);&#10;                    });&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    private void updateStatistics() {&#10;        if (engine == null) return;&#10;&#10;        SimulationResults results = engine.getResults();&#10;        arrivedTasksLabel.setText(String.valueOf(results.getTotalArrivedTasks()));&#10;        completedTasksLabel.setText(String.valueOf(results.getTotalCompletedTasks()));&#10;        avgSystemTimeLabel.setText(String.format(&quot;%.2fs&quot;, results.getAverageSystemTime()));&#10;        throughputLabel.setText(String.format(&quot;%.3f/s&quot;, results.getThroughput()));&#10;&#10;        // Update queue stats&#10;        updateQueueStatistics();&#10;&#10;        // Update user type stats&#10;        updateUserTypeStatistics();&#10;&#10;        // Update task type stats&#10;        updateTaskTypeStatistics();&#10;    }&#10;&#10;    /**&#10;     * Update Queue Statistics display&#10;     */&#10;    private void updateQueueStatistics() {&#10;        if (engine == null || queueStatsLabel == null) return;&#10;&#10;        ServicePoint dataStorage = engine.getDataStorage();&#10;        ServicePoint classification = engine.getClassification();&#10;        ServicePoint cpuQueue = engine.getCpuQueue();&#10;        ServicePoint gpuQueue = engine.getGpuQueue();&#10;        ServicePoint cpuCompute = engine.getCpuCompute();&#10;        ServicePoint gpuCompute = engine.getGpuCompute();&#10;        ServicePoint resultStorage = engine.getResultStorage();&#10;&#10;        double currentTime = Clock.getInstance().getTime();&#10;&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot; Data Storage:\n&quot;);&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#10;            dataStorage.getQueueLength(), dataStorage.getBusyServers(), 1, dataStorage.getMaxQueueLength()));&#10;        sb.append(String.format(&quot;   Utilization: %.1f%%\n\n&quot;, dataStorage.getUtilization(currentTime) * 100));&#10;&#10;        sb.append(&quot; Classification:\n&quot;);&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#10;            classification.getQueueLength(), classification.getBusyServers(), 1, classification.getMaxQueueLength()));&#10;        sb.append(String.format(&quot;   Utilization: %.1f%%\n\n&quot;, classification.getUtilization(currentTime) * 100));&#10;&#10;        sb.append(&quot; CPU Queue:\n&quot;);&#10;        sb.append(String.format(&quot;   Waiting: %d | Max: %d\n\n&quot;,&#10;            cpuQueue.getQueueLength(), cpuQueue.getMaxQueueLength()));&#10;&#10;        sb.append(&quot; CPU Compute:\n&quot;);&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#10;            cpuCompute.getQueueLength(), cpuCompute.getBusyServers(),&#10;            config.getNumCpuNodes(), cpuCompute.getMaxQueueLength()));&#10;        sb.append(String.format(&quot;   Utilization: %.1f%% | Served: %d\n\n&quot;,&#10;            cpuCompute.getUtilization(currentTime) * 100, cpuCompute.getTasksServed()));&#10;&#10;        sb.append(&quot; GPU Queue:\n&quot;);&#10;        sb.append(String.format(&quot;   Waiting: %d | Max: %d\n\n&quot;,&#10;            gpuQueue.getQueueLength(), gpuQueue.getMaxQueueLength()));&#10;&#10;        sb.append(&quot; GPU Compute:\n&quot;);&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#10;            gpuCompute.getQueueLength(), gpuCompute.getBusyServers(),&#10;            config.getNumGpuNodes(), gpuCompute.getMaxQueueLength()));&#10;        sb.append(String.format(&quot;   Utilization: %.1f%% | Served: %d\n\n&quot;,&#10;            gpuCompute.getUtilization(currentTime) * 100, gpuCompute.getTasksServed()));&#10;&#10;        sb.append(&quot; Result Storage:\n&quot;);&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#10;            resultStorage.getQueueLength(), resultStorage.getBusyServers(), 1, resultStorage.getMaxQueueLength()));&#10;        sb.append(String.format(&quot;   Utilization: %.1f%%&quot;, resultStorage.getUtilization(currentTime) * 100));&#10;&#10;        queueStatsLabel.setText(sb.toString());&#10;    }&#10;&#10;    /**&#10;     * Update User Type Statistics display&#10;     */&#10;    private void updateUserTypeStatistics() {&#10;        if (engine == null || userTypeStatsLabel == null) return;&#10;&#10;        SimulationResults results = engine.getResults();&#10;        int totalCompleted = results.getTotalCompletedTasks();&#10;&#10;        if (totalCompleted == 0) {&#10;            userTypeStatsLabel.setText(&quot;No tasks completed yet...&quot;);&#10;            return;&#10;        }&#10;&#10;        int normalCompleted = results.getNormalUserTasksCompleted();&#10;        int personalVipCompleted = results.getPersonalVipTasksCompleted();&#10;        int enterpriseVipCompleted = results.getEnterpriseVipTasksCompleted();&#10;&#10;        // Calculate average system time for each user type&#10;        Map&lt;UserType, Double&gt; avgSystemTimeByUser = calculateAverageSystemTimeByUserType();&#10;&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot; NORMAL Users:\n&quot;);&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#10;            normalCompleted, (normalCompleted * 100.0 / totalCompleted)));&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n\n&quot;,&#10;            avgSystemTimeByUser.getOrDefault(UserType.NORMAL, 0.0)));&#10;&#10;        sb.append(&quot;⭐ PERSONAL VIP:\n&quot;);&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#10;            personalVipCompleted, (personalVipCompleted * 100.0 / totalCompleted)));&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n\n&quot;,&#10;            avgSystemTimeByUser.getOrDefault(UserType.PERSONAL_VIP, 0.0)));&#10;&#10;        sb.append(&quot;⭐⭐ ENTERPRISE VIP:\n&quot;);&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#10;            enterpriseVipCompleted, (enterpriseVipCompleted * 100.0 / totalCompleted)));&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n\n&quot;,&#10;            avgSystemTimeByUser.getOrDefault(UserType.ENTERPRISE_VIP, 0.0)));&#10;&#10;        // Add comparison&#10;        sb.append(&quot; Priority Effect:\n&quot;);&#10;        double normalTime = avgSystemTimeByUser.getOrDefault(UserType.NORMAL, 0.0);&#10;        double enterpriseTime = avgSystemTimeByUser.getOrDefault(UserType.ENTERPRISE_VIP, 0.0);&#10;        if (normalTime &gt; 0 &amp;&amp; enterpriseTime &gt; 0) {&#10;            double improvement = ((normalTime - enterpriseTime) / normalTime) * 100;&#10;            sb.append(String.format(&quot;   Enterprise VIP is %.1f%% faster&quot;, improvement));&#10;        } else {&#10;            sb.append(&quot;   Insufficient data&quot;);&#10;        }&#10;&#10;        userTypeStatsLabel.setText(sb.toString());&#10;    }&#10;&#10;    /**&#10;     * Update Task Type Statistics display&#10;     */&#10;    private void updateTaskTypeStatistics() {&#10;        if (engine == null || taskTypeStatsLabel == null) return;&#10;&#10;        SimulationResults results = engine.getResults();&#10;        int totalCompleted = results.getTotalCompletedTasks();&#10;&#10;        if (totalCompleted == 0) {&#10;            taskTypeStatsLabel.setText(&quot;No tasks completed yet...&quot;);&#10;            return;&#10;        }&#10;&#10;        int cpuCompleted = results.getCpuTasksCompleted();&#10;        int gpuCompleted = results.getGpuTasksCompleted();&#10;&#10;        // Calculate average system time for each task type&#10;        Map&lt;TaskType, Double&gt; avgSystemTimeByTask = calculateAverageSystemTimeByTaskType();&#10;&#10;        ServicePoint cpuCompute = engine.getCpuCompute();&#10;        ServicePoint gpuCompute = engine.getGpuCompute();&#10;        double currentTime = Clock.getInstance().getTime();&#10;&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot; CPU Tasks:\n&quot;);&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#10;            cpuCompleted, (cpuCompleted * 100.0 / totalCompleted)));&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n&quot;,&#10;            avgSystemTimeByTask.getOrDefault(TaskType.CPU, 0.0)));&#10;        sb.append(String.format(&quot;   Node Utilization: %.1f%%\n\n&quot;,&#10;            cpuCompute.getUtilization(currentTime) * 100));&#10;&#10;        sb.append(&quot; GPU Tasks:\n&quot;);&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#10;            gpuCompleted, (gpuCompleted * 100.0 / totalCompleted)));&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n&quot;,&#10;            avgSystemTimeByTask.getOrDefault(TaskType.GPU, 0.0)));&#10;        sb.append(String.format(&quot;   Node Utilization: %.1f%%\n\n&quot;,&#10;            gpuCompute.getUtilization(currentTime) * 100));&#10;&#10;        // Add resource efficiency analysis&#10;        sb.append(&quot;⚡ Resource Efficiency:\n&quot;);&#10;        double cpuUtil = cpuCompute.getUtilization(currentTime) * 100;&#10;        double gpuUtil = gpuCompute.getUtilization(currentTime) * 100;&#10;&#10;        if (cpuUtil &gt; 90) {&#10;            sb.append(&quot;   ⚠️ CPU nodes overloaded\n&quot;);&#10;        } else if (cpuUtil &lt; 30) {&#10;            sb.append(&quot;    CPU nodes underutilized\n&quot;);&#10;        } else {&#10;            sb.append(&quot;   ✅ CPU nodes balanced\n&quot;);&#10;        }&#10;&#10;        if (gpuUtil &gt; 90) {&#10;            sb.append(&quot;   ⚠️ GPU nodes overloaded&quot;);&#10;        } else if (gpuUtil &lt; 30) {&#10;            sb.append(&quot;    GPU nodes underutilized&quot;);&#10;        } else {&#10;            sb.append(&quot;   ✅ GPU nodes balanced&quot;);&#10;        }&#10;&#10;        taskTypeStatsLabel.setText(sb.toString());&#10;    }&#10;&#10;    /**&#10;     * Calculate average system time grouped by user type&#10;     */&#10;    private Map&lt;UserType, Double&gt; calculateAverageSystemTimeByUserType() {&#10;        Map&lt;UserType, Double&gt; result = new HashMap&lt;&gt;();&#10;        Map&lt;UserType, Integer&gt; counts = new HashMap&lt;&gt;();&#10;&#10;        if (engine == null) return result;&#10;&#10;        SimulationResults results = engine.getResults();&#10;        List&lt;Task&gt; completedTasks = results.getCompletedTasks();&#10;&#10;        for (Task task : completedTasks) {&#10;            UserType type = task.getUserType();&#10;            double systemTime = task.getTotalSystemTime();&#10;            result.put(type, result.getOrDefault(type, 0.0) + systemTime);&#10;            counts.put(type, counts.getOrDefault(type, 0) + 1);&#10;        }&#10;&#10;        // Calculate averages&#10;        for (UserType type : result.keySet()) {&#10;            int count = counts.get(type);&#10;            if (count &gt; 0) {&#10;                result.put(type, result.get(type) / count);&#10;            }&#10;        }&#10;&#10;        return result;&#10;    }&#10;&#10;    /**&#10;     * Calculate average system time grouped by task type&#10;     */&#10;    private Map&lt;TaskType, Double&gt; calculateAverageSystemTimeByTaskType() {&#10;        Map&lt;TaskType, Double&gt; result = new HashMap&lt;&gt;();&#10;        Map&lt;TaskType, Integer&gt; counts = new HashMap&lt;&gt;();&#10;&#10;        if (engine == null) return result;&#10;&#10;        SimulationResults results = engine.getResults();&#10;        List&lt;Task&gt; completedTasks = results.getCompletedTasks();&#10;&#10;        for (Task task : completedTasks) {&#10;            TaskType type = task.getTaskType();&#10;            double systemTime = task.getTotalSystemTime();&#10;            result.put(type, result.getOrDefault(type, 0.0) + systemTime);&#10;            counts.put(type, counts.getOrDefault(type, 0) + 1);&#10;        }&#10;&#10;        // Calculate averages&#10;        for (TaskType type : result.keySet()) {&#10;            int count = counts.get(type);&#10;            if (count &gt; 0) {&#10;                result.put(type, result.get(type) / count);&#10;            }&#10;        }&#10;&#10;        return result;&#10;    }&#10;&#10;    private void updateVisualization() {&#10;        if (visualizationCanvas == null || engine == null) return;&#10;&#10;        GraphicsContext gc = visualizationCanvas.getGraphicsContext2D();&#10;        gc.clearRect(0, 0, visualizationCanvas.getWidth(), visualizationCanvas.getHeight());&#10;        gc.setFill(Color.WHITE);&#10;        gc.fillRect(0, 0, visualizationCanvas.getWidth(), visualizationCanvas.getHeight());&#10;&#10;        // Draw system with current state&#10;        drawSystemWithState(gc);&#10;    }&#10;&#10;    private void drawInitialCanvas() {&#10;        if (visualizationCanvas == null) return;&#10;&#10;        GraphicsContext gc = visualizationCanvas.getGraphicsContext2D();&#10;        gc.setFill(Color.WHITE);&#10;        gc.fillRect(0, 0, visualizationCanvas.getWidth(), visualizationCanvas.getHeight());&#10;&#10;        gc.setFill(Color.BLACK);&#10;        gc.setFont(javafx.scene.text.Font.font(16));&#10;        gc.fillText(&quot;System Visualization Area&quot;, visualizationCanvas.getWidth() / 2 - 90,&#10;                    visualizationCanvas.getHeight() / 2);&#10;    }&#10;&#10;    private void drawSystemWithState(GraphicsContext gc) {&#10;        gc.setStroke(Color.BLACK);&#10;        gc.setLineWidth(2);&#10;&#10;        double startX = 50;&#10;        double startY = 300;&#10;        double spacing = 100;&#10;&#10;        // Draw service points with current state&#10;        drawServicePoint(gc, startX, startY, &quot;Arrival&quot;, Color.LIGHTGREEN, 0, 0);&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#10;&#10;        startX += spacing;&#10;        ServicePoint dataStorage = engine.getDataStorage();&#10;        drawServicePoint(gc, startX, startY, &quot;Data\nStorage&quot;, Color.LIGHTBLUE,&#10;            dataStorage.getQueueLength(), dataStorage.getBusyServers());&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#10;&#10;        startX += spacing;&#10;        ServicePoint classification = engine.getClassification();&#10;        drawServicePoint(gc, startX, startY, &quot;Classification&quot;, Color.LIGHTYELLOW,&#10;            classification.getQueueLength(), classification.getBusyServers());&#10;&#10;        // CPU and GPU paths&#10;        double cpuY = startY - 100;&#10;        double gpuY = startY + 100;&#10;&#10;        drawArrow(gc, startX + 30, startY - 30, startX + 30, cpuY + 30);&#10;        ServicePoint cpuQueue = engine.getCpuQueue();&#10;        drawServicePoint(gc, startX, cpuY, &quot;CPU\nQueue&quot;, Color.ORANGE,&#10;            cpuQueue.getQueueLength(), 0);&#10;        drawArrow(gc, startX + 60, cpuY, startX + spacing, cpuY);&#10;&#10;        double cpuComputeX = startX + spacing;&#10;        ServicePoint cpuCompute = engine.getCpuCompute();&#10;        drawServicePoint(gc, cpuComputeX, cpuY, &quot;CPU\nCompute&quot;, Color.CORAL,&#10;            0, cpuCompute.getBusyServers());&#10;&#10;        drawArrow(gc, startX + 30, startY + 30, startX + 30, gpuY - 30);&#10;        ServicePoint gpuQueue = engine.getGpuQueue();&#10;        drawServicePoint(gc, startX, gpuY, &quot;GPU\nQueue&quot;, Color.PINK,&#10;            gpuQueue.getQueueLength(), 0);&#10;        drawArrow(gc, startX + 60, gpuY, startX + spacing, gpuY);&#10;&#10;        double gpuComputeX = startX + spacing;&#10;        ServicePoint gpuCompute = engine.getGpuCompute();&#10;        drawServicePoint(gc, gpuComputeX, gpuY, &quot;GPU\nCompute&quot;, Color.PLUM,&#10;            0, gpuCompute.getBusyServers());&#10;&#10;        double resultX = cpuComputeX + spacing;&#10;        drawArrow(gc, cpuComputeX + 60, cpuY, resultX, startY);&#10;        drawArrow(gc, gpuComputeX + 60, gpuY, resultX, startY);&#10;&#10;        ServicePoint resultStorage = engine.getResultStorage();&#10;        drawServicePoint(gc, resultX, startY, &quot;Result\nStorage&quot;, Color.LIGHTGREEN,&#10;            resultStorage.getQueueLength(), resultStorage.getBusyServers());&#10;        drawArrow(gc, resultX + 60, startY, resultX + 80, startY);&#10;&#10;        gc.fillText(&quot;Exit&quot;, resultX + 85, startY + 5);&#10;    }&#10;&#10;    private void drawServicePoint(GraphicsContext gc, double x, double y, String name,&#10;                                   Color color, int queueLength, int busyServers) {&#10;        // Draw box&#10;        gc.setFill(color);&#10;        gc.fillRect(x, y - 30, 60, 60);&#10;        gc.setStroke(Color.BLACK);&#10;        gc.strokeRect(x, y - 30, 60, 60);&#10;&#10;        // Draw name&#10;        gc.setFill(Color.BLACK);&#10;        gc.setFont(javafx.scene.text.Font.font(&quot;Arial&quot;, 10));&#10;        String[] lines = name.split(&quot;\n&quot;);&#10;        for (int i = 0; i &lt; lines.length; i++) {&#10;            gc.fillText(lines[i], x + 5, y - 10 + i * 12);&#10;        }&#10;&#10;        // Draw queue length if &gt; 0&#10;        if (queueLength &gt; 0) {&#10;            gc.setFill(Color.RED);&#10;            gc.fillText(&quot;Q:&quot; + queueLength, x + 5, y + 20);&#10;        }&#10;&#10;        // Draw busy servers if &gt; 0&#10;        if (busyServers &gt; 0) {&#10;            gc.setFill(Color.BLUE);&#10;            gc.fillText(&quot;B:&quot; + busyServers, x + 35, y + 20);&#10;        }&#10;    }&#10;&#10;    private void drawArrow(GraphicsContext gc, double x1, double y1, double x2, double y2) {&#10;        gc.strokeLine(x1, y1, x2, y2);&#10;&#10;        // Draw arrowhead&#10;        double angle = Math.atan2(y2 - y1, x2 - x1);&#10;        double arrowLength = 10;&#10;        double arrowAngle = Math.PI / 6;&#10;&#10;        double x3 = x2 - arrowLength * Math.cos(angle - arrowAngle);&#10;        double y3 = y2 - arrowLength * Math.sin(angle - arrowAngle);&#10;        double x4 = x2 - arrowLength * Math.cos(angle + arrowAngle);&#10;        double y4 = y2 - arrowLength * Math.sin(angle + arrowAngle);&#10;&#10;        gc.strokeLine(x2, y2, x3, y3);&#10;        gc.strokeLine(x2, y2, x4, y4);&#10;    }&#10;&#10;    private void updateButtonStates(boolean running) {&#10;        startButton.setDisable(running);&#10;        pauseButton.setDisable(!running);&#10;        resumeButton.setDisable(true);&#10;        stopButton.setDisable(!running);&#10;    }&#10;&#10;    private void updateConfigFromUI() {&#10;        try {&#10;            config.setMeanArrivalInterval(Double.parseDouble(arrivalIntervalField.getText()));&#10;            config.setSimulationTime(Double.parseDouble(simulationTimeField.getText()));&#10;            config.setNumCpuNodes(Integer.parseInt(cpuNodesField.getText()));&#10;            config.setNumGpuNodes(Integer.parseInt(gpuNodesField.getText()));&#10;            config.setCpuTaskProbability(Double.parseDouble(cpuProbabilityField.getText()));&#10;        } catch (NumberFormatException e) {&#10;            showError(&quot;Input Error&quot;, &quot;Please check configuration parameter format&quot;);&#10;        }&#10;    }&#10;&#10;    private void updateUIFromConfig() {&#10;        arrivalIntervalField.setText(String.valueOf(config.getMeanArrivalInterval()));&#10;        simulationTimeField.setText(String.valueOf(config.getSimulationTime()));&#10;        cpuNodesField.setText(String.valueOf(config.getNumCpuNodes()));&#10;        gpuNodesField.setText(String.valueOf(config.getNumGpuNodes()));&#10;        cpuProbabilityField.setText(String.valueOf(config.getCpuTaskProbability()));&#10;    }&#10;&#10;    private void copyConfig(SimulationConfig source, SimulationConfig dest) {&#10;        dest.setMeanArrivalInterval(source.getMeanArrivalInterval());&#10;        dest.setSimulationTime(source.getSimulationTime());&#10;        dest.setNumCpuNodes(source.getNumCpuNodes());&#10;        dest.setNumGpuNodes(source.getNumGpuNodes());&#10;        dest.setCpuTaskProbability(source.getCpuTaskProbability());&#10;        dest.setNormalUserProbability(source.getNormalUserProbability());&#10;        dest.setPersonalVipProbability(source.getPersonalVipProbability());&#10;        dest.setEnterpriseVipProbability(source.getEnterpriseVipProbability());&#10;    }&#10;&#10;    // ========== Utility Methods ==========&#10;&#10;    private void showInfo(String title, String message) {&#10;        Alert alert = new Alert(Alert.AlertType.INFORMATION);&#10;        alert.setTitle(title);&#10;        alert.setHeaderText(null);&#10;        alert.setContentText(message);&#10;        alert.showAndWait();&#10;    }&#10;&#10;    private void showError(String title, String message) {&#10;        Alert alert = new Alert(Alert.AlertType.ERROR);&#10;        alert.setTitle(title);&#10;        alert.setHeaderText(null);&#10;        alert.setContentText(message);&#10;        alert.showAndWait();&#10;    }&#10;&#10;    // ========== Getters ==========&#10;&#10;    public SimulationEngine getEngine() {&#10;        return engine;&#10;    }&#10;&#10;    public SimulationConfig getConfig() {&#10;        return config;&#10;    }&#10;&#10;    public SimulationResults getResults() {&#10;        return engine != null ? engine.getResults() : null;&#10;    }&#10;&#10;    public double getCurrentTime() {&#10;        return Clock.getInstance().getTime();&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.simulation.controller;&#10;&#10;import com.simulation.database.DatabaseManager;&#10;import com.simulation.database.SimulationConfigDAO;&#10;import com.simulation.database.SimulationResultsDAO;&#10;import com.simulation.model.*;&#10;import javafx.application.Platform;&#10;import javafx.beans.property.SimpleStringProperty;&#10;import javafx.collections.FXCollections;&#10;import javafx.fxml.FXML;&#10;import javafx.scene.canvas.Canvas;&#10;import javafx.scene.canvas.GraphicsContext;&#10;import javafx.scene.control.*;&#10;import javafx.scene.paint.Color;&#10;import javafx.stage.Stage;&#10;&#10;import java.sql.SQLException;&#10;import java.util.*;&#10;&#10;/**&#10; * FXML Controller that mediates between View and Model&#10; * Handles UI events and database operations&#10; */&#10;public class SimulationController {&#10;    // FXML Components&#10;    @FXML private Button startButton;&#10;    @FXML private Button pauseButton;&#10;    @FXML private Button resumeButton;&#10;    @FXML private Button stopButton;&#10;    @FXML private Button resetButton;&#10;&#10;    @FXML private Label timeLabel;&#10;    @FXML private Label speedLabel;&#10;    @FXML private Label arrivedTasksLabel;&#10;    @FXML private Label completedTasksLabel;&#10;    @FXML private Label avgSystemTimeLabel;&#10;    @FXML private Label throughputLabel;&#10;    @FXML private Label queueStatsLabel;&#10;    @FXML private Label userTypeStatsLabel;&#10;    @FXML private Label taskTypeStatsLabel;&#10;    @FXML private Label dbStatusLabel;&#10;&#10;    @FXML private TextField arrivalIntervalField;&#10;    @FXML private TextField simulationTimeField;&#10;    @FXML private TextField cpuNodesField;&#10;    @FXML private TextField gpuNodesField;&#10;    @FXML private TextField cpuProbabilityField;&#10;&#10;    @FXML private Slider speedSlider;&#10;    @FXML private Canvas visualizationCanvas;&#10;&#10;    @FXML private TableView&lt;Map&lt;String,Object&gt;&gt; historyTable;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; runIdColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; runNameColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; startTimeColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; endTimeColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; completedTasksColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; avgSystemTimeColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; throughputColumn;&#10;    @FXML private TableColumn&lt;Map&lt;String,Object&gt;, String&gt; statusColumn;&#10;&#10;&#10;&#10;    // Model components&#10;    private SimulationEngine engine;&#10;    private final SimulationConfig config;&#10;&#10;    // Database components&#10;    private final DatabaseManager dbManager;&#10;    private final SimulationConfigDAO configDAO;&#10;    private final SimulationResultsDAO resultsDAO;&#10;    private Integer currentRunId;&#10;&#10;    // UI update throttling&#10;    private long lastUpdateTime = 0;&#10;    private static final long UPDATE_INTERVAL_MS = 100; // Update UI every 100ms&#10;&#10;    public SimulationController() {&#10;        this.config = new SimulationConfig();&#10;        this.dbManager = DatabaseManager.getInstance();&#10;&#10;        // Initialize DAO objects, but they will handle database unavailability internally&#10;        SimulationConfigDAO tempConfigDAO = null;&#10;        SimulationResultsDAO tempResultsDAO = null;&#10;        try {&#10;            tempConfigDAO = new SimulationConfigDAO();&#10;            tempResultsDAO = new SimulationResultsDAO();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;⚠️  Could not initialize database DAOs: &quot; + e.getMessage());&#10;        }&#10;        this.configDAO = tempConfigDAO;&#10;        this.resultsDAO = tempResultsDAO;&#10;    }&#10;&#10;    /**&#10;     * Initialize method called after FXML loading&#10;     */&#10;    @FXML&#10;    public void initialize() {&#10;        // Setup speed slider listener&#10;        if (speedSlider != null) {&#10;            speedSlider.valueProperty().addListener((obs, oldVal, newVal) -&gt; {&#10;                double speed = newVal.doubleValue();&#10;                // Format speed display: show 1 decimal for &lt; 10x, integer for &gt;= 10x&#10;                if (speed &gt;= 10.0) {&#10;                    speedLabel.setText(String.format(&quot;%.0fx&quot;, speed));&#10;                } else {&#10;                    speedLabel.setText(String.format(&quot;%.1fx&quot;, speed));&#10;                }&#10;                if (engine != null) {&#10;                    engine.setSpeed(speed);&#10;                }&#10;            });&#10;        }&#10;&#10;        // Test database connection&#10;        testDatabaseConnection();&#10;&#10;        // Initialize canvas&#10;        if (visualizationCanvas != null) {&#10;            drawInitialCanvas();&#10;        }&#10;        // === Table column bindings ===&#10;        runIdColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;runId&quot;)))&#10;        );&#10;&#10;        runNameColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;runName&quot;)))&#10;        );&#10;&#10;        startTimeColumn.setCellValueFactory(cell -&gt; {&#10;            Object ts = cell.getValue().get(&quot;startTime&quot;);&#10;            return new SimpleStringProperty(ts == null ? &quot;&quot; : ts.toString());&#10;        });&#10;&#10;        endTimeColumn.setCellValueFactory(cell -&gt; {&#10;            Object ts = cell.getValue().get(&quot;endTime&quot;);&#10;            return new SimpleStringProperty(ts == null ? &quot;&quot; : ts.toString());&#10;        });&#10;&#10;        completedTasksColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;totalTasks&quot;)))&#10;        );&#10;&#10;        avgSystemTimeColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(&#10;                        String.format(&quot;%.3f&quot;,&#10;                                (double) cell.getValue().get(&quot;avgSystemTime&quot;))&#10;                )&#10;        );&#10;&#10;        throughputColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(&#10;                        String.format(&quot;%.3f&quot;,&#10;                                (double) cell.getValue().get(&quot;throughput&quot;))&#10;                )&#10;        );&#10;&#10;        statusColumn.setCellValueFactory(cell -&gt;&#10;                new SimpleStringProperty(String.valueOf(cell.getValue().get(&quot;status&quot;)))&#10;        );&#10;&#10;        // Auto-load history on startup&#10;        loadHistoryData();&#10;    }&#10;&#10;&#10;        // ========== FXML Event Handlers ==========&#10;&#10;    @FXML&#10;    private void handleStart() {&#10;        updateConfigFromUI();&#10;        initializeSimulation();&#10;&#10;        // Apply current speed from slider to the new engine&#10;        if (engine != null &amp;&amp; speedSlider != null) {&#10;            engine.setSpeed(speedSlider.getValue());&#10;        }&#10;&#10;        // Create database run record&#10;        try {&#10;            currentRunId = resultsDAO.createSimulationRun(null,&#10;                &quot;Simulation Run &quot; + System.currentTimeMillis());&#10;        } catch (SQLException e) {&#10;            showError(&quot;Database Error&quot;, &quot;Failed to create run record: &quot; + e.getMessage());&#10;        }&#10;&#10;        startSimulation();&#10;        updateButtonStates(true);&#10;    }&#10;&#10;    @FXML&#10;    private void handlePause() {&#10;        pauseSimulation();&#10;        pauseButton.setDisable(true);&#10;        resumeButton.setDisable(false);&#10;    }&#10;&#10;    @FXML&#10;    private void handleResume() {&#10;        resumeSimulation();&#10;        pauseButton.setDisable(false);&#10;        resumeButton.setDisable(true);&#10;    }&#10;&#10;    @FXML&#10;    private void handleStop() {&#10;        stopSimulation();&#10;&#10;        // Save results to database&#10;        if (currentRunId != null) {&#10;            saveResultsToDatabase();&#10;        }&#10;&#10;        updateButtonStates(false);&#10;    }&#10;&#10;    @FXML&#10;    private void handleReset() {&#10;        stopSimulation();&#10;        initializeSimulation();&#10;&#10;        // Apply current speed from slider to the reset engine&#10;        if (engine != null &amp;&amp; speedSlider != null) {&#10;            engine.setSpeed(speedSlider.getValue());&#10;        }&#10;&#10;        updateStatistics();&#10;        updateButtonStates(false);&#10;    }&#10;&#10;    @FXML&#10;    private void handleSaveConfig() {&#10;        TextInputDialog dialog = new TextInputDialog(&quot;My Configuration&quot;);&#10;        dialog.setTitle(&quot;Save Configuration&quot;);&#10;        dialog.setHeaderText(&quot;Save current configuration to database&quot;);&#10;        dialog.setContentText(&quot;Configuration Name:&quot;);&#10;&#10;        Optional&lt;String&gt; result = dialog.showAndWait();&#10;        result.ifPresent(name -&gt; {&#10;            try {&#10;                updateConfigFromUI();&#10;                configDAO.saveConfig(config, name);&#10;                showInfo(&quot;Success&quot;, &quot;Configuration saved: &quot; + name);&#10;            } catch (SQLException e) {&#10;                showError(&quot;Error&quot;, &quot;Failed to save configuration: &quot; + e.getMessage());&#10;            }&#10;        });&#10;    }&#10;&#10;    @FXML&#10;    private void handleLoadConfig() {&#10;        try {&#10;            List&lt;String&gt; configNames = configDAO.getAllConfigNames();&#10;&#10;            ChoiceDialog&lt;String&gt; dialog = new ChoiceDialog&lt;&gt;(&#10;                configNames.isEmpty() ? null : configNames.get(0), configNames);&#10;            dialog.setTitle(&quot;Load Configuration&quot;);&#10;            dialog.setHeaderText(&quot;Load configuration from database&quot;);&#10;            dialog.setContentText(&quot;Select Configuration:&quot;);&#10;&#10;            Optional&lt;String&gt; result = dialog.showAndWait();&#10;            result.ifPresent(name -&gt; {&#10;                try {&#10;                    SimulationConfig loadedConfig = configDAO.loadConfigByName(name);&#10;                    if (loadedConfig != null) {&#10;                        copyConfig(loadedConfig, config);&#10;                        updateUIFromConfig();&#10;                        showInfo(&quot;Success&quot;, &quot;Configuration loaded: &quot; + name);&#10;                    }&#10;                } catch (SQLException e) {&#10;                    showError(&quot;Error&quot;, &quot;Failed to load configuration: &quot; + e.getMessage());&#10;                }&#10;            });&#10;        } catch (SQLException e) {&#10;            showError(&quot;Error&quot;, &quot;Failed to get configuration list: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Load history data from database and display in table&#10;     */&#10;    private void loadHistoryData() {&#10;        if (resultsDAO == null) {&#10;            System.out.println(&quot;⚠️  Database not available - cannot load history&quot;);&#10;            return;&#10;        }&#10;&#10;        try {&#10;            List&lt;Map&lt;String,Object&gt;&gt; runs = resultsDAO.getAllSimulationRuns();&#10;            System.out.println(&quot;✅ History loaded: &quot; + runs.size() + &quot; simulation runs found&quot;);&#10;&#10;            if (historyTable != null) {&#10;                historyTable.setItems(FXCollections.observableArrayList(runs));&#10;                historyTable.refresh();&#10;                System.out.println(&quot;✅ History table updated in UI&quot;);&#10;            } else {&#10;                System.err.println(&quot;⚠️  History table is null!&quot;);&#10;            }&#10;        } catch (SQLException e) {&#10;            System.err.println(&quot;❌ Failed to load history: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        } catch (Exception e) {&#10;            System.err.println(&quot;❌ Unexpected error loading history: &quot; + e.getMessage());&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;&#10;    @FXML&#10;    private void handleViewHistory() {&#10;        System.out.println(&quot; View History button clicked!&quot;);&#10;        loadHistoryData();&#10;    }&#10;&#10;&#10;    @FXML&#10;    private void handleTestDatabase() {&#10;        testDatabaseConnection();&#10;    }&#10;&#10;    // ========== Simulation Control Methods ==========&#10;&#10;    public void initializeSimulation() {&#10;        if (engine != null &amp;&amp; engine.isAlive()) {&#10;            engine.stopSimulation();&#10;            try {&#10;                engine.join(1000);&#10;            } catch (InterruptedException e) {&#10;                Thread.currentThread().interrupt();&#10;            }&#10;        }&#10;&#10;        engine = new SimulationEngine(config);&#10;        engine.initialize();&#10;        setupSimulationListener();&#10;    }&#10;&#10;    public void startSimulation() {&#10;        if (engine != null &amp;&amp; !engine.isRunning()) {&#10;            engine.start();&#10;        }&#10;    }&#10;&#10;    public void pauseSimulation() {&#10;        if (engine != null) {&#10;            engine.pauseSimulation();&#10;        }&#10;    }&#10;&#10;    public void resumeSimulation() {&#10;        if (engine != null) {&#10;            engine.resumeSimulation();&#10;        }&#10;    }&#10;&#10;    public void stopSimulation() {&#10;        if (engine != null) {&#10;            engine.stopSimulation();&#10;        }&#10;    }&#10;&#10;    public void stepSimulation() {&#10;        if (engine != null) {&#10;            engine.stepForward();&#10;        }&#10;    }&#10;&#10;    public void setSimulationListener(SimulationEngine.SimulationListener listener) {&#10;        if (engine != null) {&#10;            engine.setListener(listener);&#10;        }&#10;    }&#10;&#10;    // ========== Database Methods ==========&#10;&#10;    private void testDatabaseConnection() {&#10;        boolean connected = dbManager.testConnection();&#10;        Platform.runLater(() -&gt; {&#10;            if (connected) {&#10;                dbStatusLabel.setText(&quot;✅ Connected&quot;);&#10;                dbStatusLabel.setStyle(&quot;-fx-text-fill: green;&quot;);&#10;            } else {&#10;                dbStatusLabel.setText(&quot;❌ Not Connected&quot;);&#10;                dbStatusLabel.setStyle(&quot;-fx-text-fill: red;&quot;);&#10;            }&#10;        });&#10;    }&#10;&#10;    private void saveResultsToDatabase() {&#10;        if (currentRunId == null || engine == null) return;&#10;&#10;        try {&#10;            SimulationResults results = engine.getResults();&#10;            resultsDAO.updateSimulationRun(currentRunId, results, &quot;COMPLETED&quot;);&#10;&#10;            // Save completed tasks&#10;            if (!results.getCompletedTasks().isEmpty()) {&#10;                resultsDAO.saveTasks(currentRunId, results.getCompletedTasks());&#10;            }&#10;&#10;            showInfo(&quot;Success&quot;, &quot;Simulation results saved to database&quot;);&#10;        } catch (SQLException e) {&#10;            showError(&quot;Database Error&quot;, &quot;Failed to save results: &quot; + e.getMessage());&#10;        }&#10;    }&#10;&#10;    // ========== UI Update Methods ==========&#10;&#10;    private void setupSimulationListener() {&#10;        if (engine != null) {&#10;            engine.setListener(new SimulationEngine.SimulationListener() {&#10;                @Override&#10;                public void onTimeUpdate(double time) {&#10;                    // Throttle UI updates to prevent stuttering&#10;                    long currentTime = System.currentTimeMillis();&#10;                    if (currentTime - lastUpdateTime &gt;= UPDATE_INTERVAL_MS) {&#10;                        lastUpdateTime = currentTime;&#10;                        Platform.runLater(() -&gt; {&#10;                            timeLabel.setText(String.format(&quot;%.2fs&quot;, time));&#10;                            updateStatistics();&#10;                            updateVisualization();&#10;                        });&#10;                    }&#10;                }&#10;&#10;                @Override&#10;                public void onSimulationComplete() {&#10;                    Platform.runLater(() -&gt; {&#10;                        // Final update to show accurate completion state&#10;                        updateStatistics();&#10;                        updateVisualization();&#10;                        updateButtonStates(false);&#10;                        if (currentRunId != null) {&#10;                            saveResultsToDatabase();&#10;                        }&#10;                        showInfo(&quot;Complete&quot;, &quot;Simulation completed!&quot;);&#10;                    });&#10;                }&#10;            });&#10;        }&#10;    }&#10;&#10;    private void updateStatistics() {&#10;        if (engine == null) return;&#10;&#10;        SimulationResults results = engine.getResults();&#10;        arrivedTasksLabel.setText(String.valueOf(results.getTotalArrivedTasks()));&#10;        completedTasksLabel.setText(String.valueOf(results.getTotalCompletedTasks()));&#10;        avgSystemTimeLabel.setText(String.format(&quot;%.2fs&quot;, results.getAverageSystemTime()));&#10;        throughputLabel.setText(String.format(&quot;%.3f/s&quot;, results.getThroughput()));&#10;&#10;        // Update queue stats&#10;        updateQueueStatistics();&#10;&#10;        // Update user type stats&#10;        updateUserTypeStatistics();&#10;&#10;        // Update task type stats&#10;        updateTaskTypeStatistics();&#10;    }&#10;&#10;    /**&#10;     * Update Queue Statistics display&#10;     */&#10;    private void updateQueueStatistics() {&#10;        if (engine == null || queueStatsLabel == null) return;&#10;&#10;        ServicePoint dataStorage = engine.getDataStorage();&#10;        ServicePoint classification = engine.getClassification();&#10;        ServicePoint cpuCompute = engine.getCpuCompute();&#10;        ServicePoint gpuCompute = engine.getGpuCompute();&#10;        ServicePoint resultStorage = engine.getResultStorage();&#10;&#10;        double currentTime = Clock.getInstance().getTime();&#10;&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot; Data Storage:\n&quot;);&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#10;            dataStorage.getQueueLength(), dataStorage.getBusyServers(), 1, dataStorage.getMaxQueueLength()));&#10;        sb.append(String.format(&quot;   Utilization: %.1f%%\n\n&quot;, dataStorage.getUtilization(currentTime) * 100));&#10;&#10;        sb.append(&quot; Classification:\n&quot;);&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#10;            classification.getQueueLength(), classification.getBusyServers(), 1, classification.getMaxQueueLength()));&#10;        sb.append(String.format(&quot;   Utilization: %.1f%%\n\n&quot;, classification.getUtilization(currentTime) * 100));&#10;&#10;        sb.append(&quot; CPU Compute:\n&quot;);&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#10;            cpuCompute.getQueueLength(), cpuCompute.getBusyServers(),&#10;            config.getNumCpuNodes(), cpuCompute.getMaxQueueLength()));&#10;        sb.append(String.format(&quot;   Utilization: %.1f%% | Served: %d\n\n&quot;,&#10;            cpuCompute.getUtilization(currentTime) * 100, cpuCompute.getTasksServed()));&#10;&#10;&#10;        sb.append(&quot; GPU Compute:\n&quot;);&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#10;            gpuCompute.getQueueLength(), gpuCompute.getBusyServers(),&#10;            config.getNumGpuNodes(), gpuCompute.getMaxQueueLength()));&#10;        sb.append(String.format(&quot;   Utilization: %.1f%% | Served: %d\n\n&quot;,&#10;            gpuCompute.getUtilization(currentTime) * 100, gpuCompute.getTasksServed()));&#10;&#10;        sb.append(&quot; Result Storage:\n&quot;);&#10;        sb.append(String.format(&quot;   Queue: %d | Busy: %d/%d | Max: %d\n&quot;,&#10;            resultStorage.getQueueLength(), resultStorage.getBusyServers(), 1, resultStorage.getMaxQueueLength()));&#10;        sb.append(String.format(&quot;   Utilization: %.1f%%&quot;, resultStorage.getUtilization(currentTime) * 100));&#10;&#10;        queueStatsLabel.setText(sb.toString());&#10;    }&#10;&#10;    /**&#10;     * Update User Type Statistics display&#10;     */&#10;    private void updateUserTypeStatistics() {&#10;        if (engine == null || userTypeStatsLabel == null) return;&#10;&#10;        SimulationResults results = engine.getResults();&#10;        int totalCompleted = results.getTotalCompletedTasks();&#10;&#10;        if (totalCompleted == 0) {&#10;            userTypeStatsLabel.setText(&quot;No tasks completed yet...&quot;);&#10;            return;&#10;        }&#10;&#10;        int normalCompleted = results.getNormalUserTasksCompleted();&#10;        int personalVipCompleted = results.getPersonalVipTasksCompleted();&#10;        int enterpriseVipCompleted = results.getEnterpriseVipTasksCompleted();&#10;&#10;        // Calculate average system time for each user type&#10;        Map&lt;UserType, Double&gt; avgSystemTimeByUser = calculateAverageSystemTimeByUserType();&#10;&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot; NORMAL Users:\n&quot;);&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#10;            normalCompleted, (normalCompleted * 100.0 / totalCompleted)));&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n\n&quot;,&#10;            avgSystemTimeByUser.getOrDefault(UserType.NORMAL, 0.0)));&#10;&#10;        sb.append(&quot;⭐ PERSONAL VIP:\n&quot;);&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#10;            personalVipCompleted, (personalVipCompleted * 100.0 / totalCompleted)));&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n\n&quot;,&#10;            avgSystemTimeByUser.getOrDefault(UserType.PERSONAL_VIP, 0.0)));&#10;&#10;        sb.append(&quot;⭐⭐ ENTERPRISE VIP:\n&quot;);&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#10;            enterpriseVipCompleted, (enterpriseVipCompleted * 100.0 / totalCompleted)));&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n\n&quot;,&#10;            avgSystemTimeByUser.getOrDefault(UserType.ENTERPRISE_VIP, 0.0)));&#10;&#10;        // Add comparison&#10;        sb.append(&quot; Priority Effect:\n&quot;);&#10;        double normalTime = avgSystemTimeByUser.getOrDefault(UserType.NORMAL, 0.0);&#10;        double enterpriseTime = avgSystemTimeByUser.getOrDefault(UserType.ENTERPRISE_VIP, 0.0);&#10;        if (normalTime &gt; 0 &amp;&amp; enterpriseTime &gt; 0) {&#10;            double improvement = ((normalTime - enterpriseTime) / normalTime) * 100;&#10;            sb.append(String.format(&quot;   Enterprise VIP is %.1f%% faster&quot;, improvement));&#10;        } else {&#10;            sb.append(&quot;   Insufficient data&quot;);&#10;        }&#10;&#10;        userTypeStatsLabel.setText(sb.toString());&#10;    }&#10;&#10;    /**&#10;     * Update Task Type Statistics display&#10;     */&#10;    private void updateTaskTypeStatistics() {&#10;        if (engine == null || taskTypeStatsLabel == null) return;&#10;&#10;        SimulationResults results = engine.getResults();&#10;        int totalCompleted = results.getTotalCompletedTasks();&#10;&#10;        if (totalCompleted == 0) {&#10;            taskTypeStatsLabel.setText(&quot;No tasks completed yet...&quot;);&#10;            return;&#10;        }&#10;&#10;        int cpuCompleted = results.getCpuTasksCompleted();&#10;        int gpuCompleted = results.getGpuTasksCompleted();&#10;&#10;        // Calculate average system time for each task type&#10;        Map&lt;TaskType, Double&gt; avgSystemTimeByTask = calculateAverageSystemTimeByTaskType();&#10;&#10;        ServicePoint cpuCompute = engine.getCpuCompute();&#10;        ServicePoint gpuCompute = engine.getGpuCompute();&#10;        double currentTime = Clock.getInstance().getTime();&#10;&#10;        StringBuilder sb = new StringBuilder();&#10;        sb.append(&quot; CPU Tasks:\n&quot;);&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#10;            cpuCompleted, (cpuCompleted * 100.0 / totalCompleted)));&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n&quot;,&#10;            avgSystemTimeByTask.getOrDefault(TaskType.CPU, 0.0)));&#10;        sb.append(String.format(&quot;   Node Utilization: %.1f%%\n\n&quot;,&#10;            cpuCompute.getUtilization(currentTime) * 100));&#10;&#10;        sb.append(&quot; GPU Tasks:\n&quot;);&#10;        sb.append(String.format(&quot;   Completed: %d (%.1f%%)\n&quot;,&#10;            gpuCompleted, (gpuCompleted * 100.0 / totalCompleted)));&#10;        sb.append(String.format(&quot;   Avg System Time: %.2fs\n&quot;,&#10;            avgSystemTimeByTask.getOrDefault(TaskType.GPU, 0.0)));&#10;        sb.append(String.format(&quot;   Node Utilization: %.1f%%\n\n&quot;,&#10;            gpuCompute.getUtilization(currentTime) * 100));&#10;&#10;        // Add resource efficiency analysis&#10;        sb.append(&quot;⚡ Resource Efficiency:\n&quot;);&#10;        double cpuUtil = cpuCompute.getUtilization(currentTime) * 100;&#10;        double gpuUtil = gpuCompute.getUtilization(currentTime) * 100;&#10;&#10;        if (cpuUtil &gt; 90) {&#10;            sb.append(&quot;   ⚠️ CPU nodes overloaded\n&quot;);&#10;        } else if (cpuUtil &lt; 30) {&#10;            sb.append(&quot;    CPU nodes underutilized\n&quot;);&#10;        } else {&#10;            sb.append(&quot;   ✅ CPU nodes balanced\n&quot;);&#10;        }&#10;&#10;        if (gpuUtil &gt; 90) {&#10;            sb.append(&quot;   ⚠️ GPU nodes overloaded&quot;);&#10;        } else if (gpuUtil &lt; 30) {&#10;            sb.append(&quot;    GPU nodes underutilized&quot;);&#10;        } else {&#10;            sb.append(&quot;   ✅ GPU nodes balanced&quot;);&#10;        }&#10;&#10;        taskTypeStatsLabel.setText(sb.toString());&#10;    }&#10;&#10;    /**&#10;     * Calculate average system time grouped by user type&#10;     */&#10;    private Map&lt;UserType, Double&gt; calculateAverageSystemTimeByUserType() {&#10;        Map&lt;UserType, Double&gt; result = new HashMap&lt;&gt;();&#10;        Map&lt;UserType, Integer&gt; counts = new HashMap&lt;&gt;();&#10;&#10;        if (engine == null) return result;&#10;&#10;        SimulationResults results = engine.getResults();&#10;        List&lt;Task&gt; completedTasks = results.getCompletedTasks();&#10;&#10;        for (Task task : completedTasks) {&#10;            UserType type = task.getUserType();&#10;            double systemTime = task.getTotalSystemTime();&#10;            result.put(type, result.getOrDefault(type, 0.0) + systemTime);&#10;            counts.put(type, counts.getOrDefault(type, 0) + 1);&#10;        }&#10;&#10;        // Calculate averages&#10;        for (UserType type : result.keySet()) {&#10;            int count = counts.get(type);&#10;            if (count &gt; 0) {&#10;                result.put(type, result.get(type) / count);&#10;            }&#10;        }&#10;&#10;        return result;&#10;    }&#10;&#10;    /**&#10;     * Calculate average system time grouped by task type&#10;     */&#10;    private Map&lt;TaskType, Double&gt; calculateAverageSystemTimeByTaskType() {&#10;        Map&lt;TaskType, Double&gt; result = new HashMap&lt;&gt;();&#10;        Map&lt;TaskType, Integer&gt; counts = new HashMap&lt;&gt;();&#10;&#10;        if (engine == null) return result;&#10;&#10;        SimulationResults results = engine.getResults();&#10;        List&lt;Task&gt; completedTasks = results.getCompletedTasks();&#10;&#10;        for (Task task : completedTasks) {&#10;            TaskType type = task.getTaskType();&#10;            double systemTime = task.getTotalSystemTime();&#10;            result.put(type, result.getOrDefault(type, 0.0) + systemTime);&#10;            counts.put(type, counts.getOrDefault(type, 0) + 1);&#10;        }&#10;&#10;        // Calculate averages&#10;        for (TaskType type : result.keySet()) {&#10;            int count = counts.get(type);&#10;            if (count &gt; 0) {&#10;                result.put(type, result.get(type) / count);&#10;            }&#10;        }&#10;&#10;        return result;&#10;    }&#10;&#10;    private void updateVisualization() {&#10;        if (visualizationCanvas == null || engine == null) return;&#10;&#10;        GraphicsContext gc = visualizationCanvas.getGraphicsContext2D();&#10;        gc.clearRect(0, 0, visualizationCanvas.getWidth(), visualizationCanvas.getHeight());&#10;        gc.setFill(Color.WHITE);&#10;        gc.fillRect(0, 0, visualizationCanvas.getWidth(), visualizationCanvas.getHeight());&#10;&#10;        // Draw system with current state&#10;        drawSystemWithState(gc);&#10;    }&#10;&#10;    private void drawInitialCanvas() {&#10;        if (visualizationCanvas == null) return;&#10;&#10;        GraphicsContext gc = visualizationCanvas.getGraphicsContext2D();&#10;        gc.setFill(Color.WHITE);&#10;        gc.fillRect(0, 0, visualizationCanvas.getWidth(), visualizationCanvas.getHeight());&#10;&#10;        gc.setFill(Color.BLACK);&#10;        gc.setFont(javafx.scene.text.Font.font(16));&#10;        gc.fillText(&quot;System Visualization Area&quot;, visualizationCanvas.getWidth() / 2 - 90,&#10;                    visualizationCanvas.getHeight() / 2);&#10;    }&#10;&#10;    private void drawSystemWithState(GraphicsContext gc) {&#10;        gc.setStroke(Color.BLACK);&#10;        gc.setLineWidth(2);&#10;&#10;        double startX = 50;&#10;        double startY = 300;&#10;        double spacing = 100;&#10;&#10;        // Draw service points with current state&#10;        drawServicePoint(gc, startX, startY, &quot;Arrival&quot;, Color.LIGHTGREEN, 0, 0);&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#10;&#10;        startX += spacing;&#10;        ServicePoint dataStorage = engine.getDataStorage();&#10;        drawServicePoint(gc, startX, startY, &quot;Data\nStorage&quot;, Color.LIGHTBLUE,&#10;            dataStorage.getQueueLength(), dataStorage.getBusyServers());&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#10;&#10;        startX += spacing;&#10;        ServicePoint classification = engine.getClassification();&#10;        drawServicePoint(gc, startX, startY, &quot;Classification&quot;, Color.LIGHTYELLOW,&#10;            classification.getQueueLength(), classification.getBusyServers());&#10;&#10;        // CPU and GPU paths - now compute service points include their own queues&#10;        double cpuY = startY - 100;&#10;        double gpuY = startY + 100;&#10;&#10;        drawArrow(gc, startX + 30, startY - 30, startX + 30, cpuY + 30);&#10;        double cpuComputeX = startX;&#10;        ServicePoint cpuCompute = engine.getCpuCompute();&#10;        drawServicePoint(gc, cpuComputeX, cpuY, &quot;CPU\nCompute&quot;, Color.CORAL,&#10;            cpuCompute.getQueueLength(), cpuCompute.getBusyServers());&#10;&#10;        drawArrow(gc, startX + 30, startY + 30, startX + 30, gpuY - 30);&#10;        double gpuComputeX = startX;&#10;        ServicePoint gpuCompute = engine.getGpuCompute();&#10;        drawServicePoint(gc, gpuComputeX, gpuY, &quot;GPU\nCompute&quot;, Color.PLUM,&#10;            gpuCompute.getQueueLength(), gpuCompute.getBusyServers());&#10;&#10;        double resultX = cpuComputeX + spacing;&#10;        drawArrow(gc, cpuComputeX + 60, cpuY, resultX, startY);&#10;        drawArrow(gc, gpuComputeX + 60, gpuY, resultX, startY);&#10;&#10;        ServicePoint resultStorage = engine.getResultStorage();&#10;        drawServicePoint(gc, resultX, startY, &quot;Result\nStorage&quot;, Color.LIGHTGREEN,&#10;            resultStorage.getQueueLength(), resultStorage.getBusyServers());&#10;        drawArrow(gc, resultX + 60, startY, resultX + 80, startY);&#10;&#10;        gc.fillText(&quot;Exit&quot;, resultX + 85, startY + 5);&#10;    }&#10;&#10;    private void drawServicePoint(GraphicsContext gc, double x, double y, String name,&#10;                                   Color color, int queueLength, int busyServers) {&#10;        // Draw box&#10;        gc.setFill(color);&#10;        gc.fillRect(x, y - 30, 60, 60);&#10;        gc.setStroke(Color.BLACK);&#10;        gc.strokeRect(x, y - 30, 60, 60);&#10;&#10;        // Draw name&#10;        gc.setFill(Color.BLACK);&#10;        gc.setFont(javafx.scene.text.Font.font(&quot;Arial&quot;, 10));&#10;        String[] lines = name.split(&quot;\n&quot;);&#10;        for (int i = 0; i &lt; lines.length; i++) {&#10;            gc.fillText(lines[i], x + 5, y - 10 + i * 12);&#10;        }&#10;&#10;        // Draw queue length if &gt; 0&#10;        if (queueLength &gt; 0) {&#10;            gc.setFill(Color.RED);&#10;            gc.fillText(&quot;Q:&quot; + queueLength, x + 5, y + 20);&#10;        }&#10;&#10;        // Draw busy servers if &gt; 0&#10;        if (busyServers &gt; 0) {&#10;            gc.setFill(Color.BLUE);&#10;            gc.fillText(&quot;B:&quot; + busyServers, x + 35, y + 20);&#10;        }&#10;    }&#10;&#10;    private void drawArrow(GraphicsContext gc, double x1, double y1, double x2, double y2) {&#10;        gc.strokeLine(x1, y1, x2, y2);&#10;&#10;        // Draw arrowhead&#10;        double angle = Math.atan2(y2 - y1, x2 - x1);&#10;        double arrowLength = 10;&#10;        double arrowAngle = Math.PI / 6;&#10;&#10;        double x3 = x2 - arrowLength * Math.cos(angle - arrowAngle);&#10;        double y3 = y2 - arrowLength * Math.sin(angle - arrowAngle);&#10;        double x4 = x2 - arrowLength * Math.cos(angle + arrowAngle);&#10;        double y4 = y2 - arrowLength * Math.sin(angle + arrowAngle);&#10;&#10;        gc.strokeLine(x2, y2, x3, y3);&#10;        gc.strokeLine(x2, y2, x4, y4);&#10;    }&#10;&#10;    private void updateButtonStates(boolean running) {&#10;        startButton.setDisable(running);&#10;        pauseButton.setDisable(!running);&#10;        resumeButton.setDisable(true);&#10;        stopButton.setDisable(!running);&#10;    }&#10;&#10;    private void updateConfigFromUI() {&#10;        try {&#10;            config.setMeanArrivalInterval(Double.parseDouble(arrivalIntervalField.getText()));&#10;            config.setSimulationTime(Double.parseDouble(simulationTimeField.getText()));&#10;            config.setNumCpuNodes(Integer.parseInt(cpuNodesField.getText()));&#10;            config.setNumGpuNodes(Integer.parseInt(gpuNodesField.getText()));&#10;            config.setCpuTaskProbability(Double.parseDouble(cpuProbabilityField.getText()));&#10;        } catch (NumberFormatException e) {&#10;            showError(&quot;Input Error&quot;, &quot;Please check configuration parameter format&quot;);&#10;        }&#10;    }&#10;&#10;    private void updateUIFromConfig() {&#10;        arrivalIntervalField.setText(String.valueOf(config.getMeanArrivalInterval()));&#10;        simulationTimeField.setText(String.valueOf(config.getSimulationTime()));&#10;        cpuNodesField.setText(String.valueOf(config.getNumCpuNodes()));&#10;        gpuNodesField.setText(String.valueOf(config.getNumGpuNodes()));&#10;        cpuProbabilityField.setText(String.valueOf(config.getCpuTaskProbability()));&#10;    }&#10;&#10;    private void copyConfig(SimulationConfig source, SimulationConfig dest) {&#10;        dest.setMeanArrivalInterval(source.getMeanArrivalInterval());&#10;        dest.setSimulationTime(source.getSimulationTime());&#10;        dest.setNumCpuNodes(source.getNumCpuNodes());&#10;        dest.setNumGpuNodes(source.getNumGpuNodes());&#10;        dest.setCpuTaskProbability(source.getCpuTaskProbability());&#10;        dest.setNormalUserProbability(source.getNormalUserProbability());&#10;        dest.setPersonalVipProbability(source.getPersonalVipProbability());&#10;        dest.setEnterpriseVipProbability(source.getEnterpriseVipProbability());&#10;    }&#10;&#10;    // ========== Utility Methods ==========&#10;&#10;    private void showInfo(String title, String message) {&#10;        Alert alert = new Alert(Alert.AlertType.INFORMATION);&#10;        alert.setTitle(title);&#10;        alert.setHeaderText(null);&#10;        alert.setContentText(message);&#10;        alert.showAndWait();&#10;    }&#10;&#10;    private void showError(String title, String message) {&#10;        Alert alert = new Alert(Alert.AlertType.ERROR);&#10;        alert.setTitle(title);&#10;        alert.setHeaderText(null);&#10;        alert.setContentText(message);&#10;        alert.showAndWait();&#10;    }&#10;&#10;    // ========== Getters ==========&#10;&#10;    public SimulationEngine getEngine() {&#10;        return engine;&#10;    }&#10;&#10;    public SimulationConfig getConfig() {&#10;        return config;&#10;    }&#10;&#10;    public SimulationResults getResults() {&#10;        return engine != null ? engine.getResults() : null;&#10;    }&#10;&#10;    public double getCurrentTime() {&#10;        return Clock.getInstance().getTime();&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/simulation/model/ServicePoint.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/simulation/model/ServicePoint.java" />
              <option name="originalContent" value="package com.simulation.model;&#10;import com.simulation.util.RandomGenerator;&#10;import java.util.*;&#10;public class ServicePoint {&#10;    private final String name;&#10;    private final int numServers;&#10;    private final double meanServiceTime;&#10;    private final Queue&lt;Task&gt; queue;&#10;    private int busyServers, tasksServed, maxQueueLength;&#10;    private double totalServiceTime;&#10;    public ServicePoint(String name, int numServers, double meanServiceTime, boolean usePriorityQueue) {&#10;        this.name = name;&#10;        this.numServers = numServers;&#10;        this.meanServiceTime = meanServiceTime;&#10;        this.queue = usePriorityQueue ? new PriorityQueue&lt;&gt;() : new LinkedList&lt;&gt;();&#10;    }&#10;    public void addToQueue(Task task) {&#10;        queue.add(task);&#10;        if (queue.size() &gt; maxQueueLength) maxQueueLength = queue.size();&#10;    }&#10;    public boolean isAvailable() { return busyServers &lt; numServers; }&#10;    public boolean isQueueEmpty() { return queue.isEmpty(); }&#10;    public Task beginService(double currentTime) {&#10;        if (queue.isEmpty() || !isAvailable()) return null;&#10;        busyServers++;&#10;        return queue.poll();&#10;    }&#10;    public double getServiceTime() {&#10;        double serviceTime = RandomGenerator.exponential(meanServiceTime);&#10;        totalServiceTime += serviceTime;&#10;        return serviceTime;&#10;    }&#10;    public void endService() {&#10;        if (busyServers &gt; 0) { busyServers--; tasksServed++; }&#10;    }&#10;    public String getName() { return name; }&#10;    public int getQueueLength() { return queue.size(); }&#10;    public int getBusyServers() { return busyServers; }&#10;    public int getTasksServed() { return tasksServed; }&#10;    public int getMaxQueueLength() { return maxQueueLength; }&#10;    public double getUtilization(double totalTime) {&#10;        return (totalTime &gt; 0 &amp;&amp; numServers &gt; 0) ? totalServiceTime / (totalTime * numServers) : 0;&#10;    }&#10;    public double getAverageServiceTime() { return tasksServed &gt; 0 ? totalServiceTime / tasksServed : 0; }&#10;    public double getAverageQueueTime() { return 0; }&#10;    public void reset() {&#10;        queue.clear();&#10;        busyServers = 0;&#10;        tasksServed = 0;&#10;        totalServiceTime = 0;&#10;        maxQueueLength = 0;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.simulation.model;&#10;import com.simulation.util.RandomGenerator;&#10;import java.util.*;&#10;&#10;/**&#10; * Represents a service point or queue in the simulation system.&#10; * Can function as either:&#10; * 1. Pure Queue: Just holds tasks waiting (e.g., CPU Queue, GPU Queue)&#10; * 2. Service Point: Processes tasks with servers (e.g., Data Storage, CPU Compute)&#10; */&#10;public class ServicePoint {&#10;    private final String name;&#10;    private final int numServers;&#10;    private final double meanServiceTime;&#10;    private final Queue&lt;Task&gt; queue;&#10;    private final boolean isPureQueue; // True for queues without service processing&#10;&#10;    private int busyServers;&#10;    private int tasksServed;&#10;    private int maxQueueLength;&#10;    private double totalBusyTime; // Total time servers have been busy&#10;    private double lastUpdateTime; // Last time utilization was updated&#10;&#10;    /**&#10;     * Constructor for service points with processing capability&#10;     */&#10;    public ServicePoint(String name, int numServers, double meanServiceTime, boolean usePriorityQueue) {&#10;        this.name = name;&#10;        this.numServers = numServers;&#10;        this.meanServiceTime = meanServiceTime;&#10;        this.queue = usePriorityQueue ? new PriorityQueue&lt;&gt;() : new LinkedList&lt;&gt;();&#10;        this.isPureQueue = (meanServiceTime == 0); // If service time is 0, it's a pure queue&#10;        this.lastUpdateTime = 0;&#10;    }&#10;&#10;    public void addToQueue(Task task) {&#10;        queue.add(task);&#10;        if (queue.size() &gt; maxQueueLength) maxQueueLength = queue.size();&#10;    }&#10;&#10;    /**&#10;     * Remove task from queue without starting service (for pure queues)&#10;     */&#10;    public Task removeFromQueue() {&#10;        return queue.isEmpty() ? null : queue.poll();&#10;    }&#10;&#10;    public boolean isAvailable() {&#10;        return busyServers &lt; numServers;&#10;    }&#10;&#10;    public boolean isQueueEmpty() {&#10;        return queue.isEmpty();&#10;    }&#10;&#10;    /**&#10;     * Start service by marking a server as busy (for service points without their own queue)&#10;     */&#10;    public void startService(double currentTime) {&#10;        if (busyServers &lt; numServers) {&#10;            updateUtilizationTracking(currentTime);&#10;            busyServers++;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Begin service by taking task from own queue (for service points with queue)&#10;     */&#10;    public Task beginService(double currentTime) {&#10;        if (queue.isEmpty() || !isAvailable()) return null;&#10;        updateUtilizationTracking(currentTime);&#10;        busyServers++;&#10;        return queue.poll();&#10;    }&#10;&#10;    /**&#10;     * Generate service time and track it for utilization calculation&#10;     */&#10;    public double getServiceTime() {&#10;        return RandomGenerator.exponential(meanServiceTime);&#10;    }&#10;&#10;    /**&#10;     * End service and update statistics&#10;     */&#10;    public void endService(double currentTime) {&#10;        if (busyServers &gt; 0) {&#10;            updateUtilizationTracking(currentTime);&#10;            busyServers--;&#10;            tasksServed++;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Update the busy time tracking for accurate utilization calculation&#10;     */&#10;    private void updateUtilizationTracking(double currentTime) {&#10;        if (!isPureQueue &amp;&amp; currentTime &gt; lastUpdateTime) {&#10;            totalBusyTime += busyServers * (currentTime - lastUpdateTime);&#10;            lastUpdateTime = currentTime;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Calculate utilization based on actual busy time&#10;     */&#10;    public double getUtilization(double currentTime) {&#10;        if (isPureQueue || numServers == 0 || currentTime &lt;= 0) {&#10;            return 0.0;&#10;        }&#10;&#10;        // Update to current time before calculating&#10;        updateUtilizationTracking(currentTime);&#10;&#10;        // Utilization = total busy time / (simulation time * number of servers)&#10;        double totalCapacityTime = currentTime * numServers;&#10;        return totalCapacityTime &gt; 0 ? totalBusyTime / totalCapacityTime : 0.0;&#10;    }&#10;&#10;    public String getName() { return name; }&#10;    public int getQueueLength() { return queue.size(); }&#10;    public int getBusyServers() { return busyServers; }&#10;    public int getTasksServed() { return tasksServed; }&#10;    public int getMaxQueueLength() { return maxQueueLength; }&#10;    public boolean isPureQueue() { return isPureQueue; }&#10;&#10;    public double getAverageServiceTime() { &#10;        return tasksServed &gt; 0 ? (totalBusyTime / tasksServed) : 0; &#10;    }&#10;    &#10;    /**&#10;     * Get average queue time (not yet implemented, returns 0)&#10;     * TODO: Implement proper queue time tracking&#10;     */&#10;    public double getAverageQueueTime() {&#10;        return 0.0;&#10;    }&#10;    &#10;    public void reset() {&#10;        queue.clear();&#10;        busyServers = 0;&#10;        tasksServed = 0;&#10;        totalBusyTime = 0;&#10;        maxQueueLength = 0;&#10;        lastUpdateTime = 0;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/simulation/model/SimulationEngine.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/simulation/model/SimulationEngine.java" />
              <option name="originalContent" value="package com.simulation.model;&#10;import com.simulation.util.RandomGenerator;&#10;public class SimulationEngine extends Thread {&#10;    private final SimulationConfig config;&#10;    private final SimulationResults results;&#10;    private final EventList eventList;&#10;    private final Clock clock;&#10;    private ServicePoint dataStorage, classification, cpuQueue, gpuQueue, cpuCompute, gpuCompute, resultStorage;&#10;    private volatile boolean running, paused;&#10;    private volatile double speedMultiplier = 1.0;&#10;    private final Object pauseLock = new Object();&#10;    private SimulationListener listener;&#10;    /**&#10;     * Listener interface for simulation events&#10;     */&#10;    public interface SimulationListener {&#10;        void onTimeUpdate(double time);&#10;        void onSimulationComplete();&#10;        default void onSimulationUpdate() {&#10;            onTimeUpdate(Clock.getInstance().getTime());&#10;        }&#10;    }&#10;    public SimulationEngine(SimulationConfig config) {&#10;        this.config = config;&#10;        this.results = new SimulationResults();&#10;        this.eventList = new EventList();&#10;        this.clock = Clock.getInstance();&#10;        initializeServicePoints();&#10;    }&#10;    private void initializeServicePoints() {&#10;        dataStorage = new ServicePoint(&quot;Data Storage&quot;, 1, config.getDataStorageServiceTime(), false);&#10;        classification = new ServicePoint(&quot;Classification&quot;, 1, config.getClassificationServiceTime(), false);&#10;        cpuQueue = new ServicePoint(&quot;CPU Queue&quot;, Integer.MAX_VALUE, 0, true);&#10;        gpuQueue = new ServicePoint(&quot;GPU Queue&quot;, Integer.MAX_VALUE, 0, true);&#10;        cpuCompute = new ServicePoint(&quot;CPU Compute&quot;, config.getNumCpuNodes(), config.getCpuComputeServiceTime(), false);&#10;        gpuCompute = new ServicePoint(&quot;GPU Compute&quot;, config.getNumGpuNodes(), config.getGpuComputeServiceTime(), false);&#10;        resultStorage = new ServicePoint(&quot;Result Storage&quot;, 1, config.getResultStorageServiceTime(), false);&#10;    }&#10;    public void setListener(SimulationListener listener) {&#10;        this.listener = listener;&#10;    }&#10;    public void setSpeed(double speed) {&#10;        this.speedMultiplier = Math.max(0.1, Math.min(100.0, speed));&#10;    }&#10;    public void initialize() {&#10;        clock.reset();&#10;        eventList.clear();&#10;        results.reset();&#10;        dataStorage.reset(); classification.reset(); cpuQueue.reset(); gpuQueue.reset();&#10;        cpuCompute.reset(); gpuCompute.reset(); resultStorage.reset();&#10;        scheduleNextArrival();&#10;    }&#10;    private void scheduleNextArrival() {&#10;        double arrivalTime = clock.getTime() + RandomGenerator.exponential(config.getMeanArrivalInterval());&#10;        if (arrivalTime &lt;= config.getSimulationTime()) {&#10;            TaskType taskType = RandomGenerator.bernoulli(config.getCpuTaskProbability()) ? TaskType.CPU : TaskType.GPU;&#10;            UserType userType = generateUserType();&#10;            Task task = new Task(taskType, userType, arrivalTime);&#10;            eventList.addEvent(new Event(EventType.ARRIVAL, arrivalTime, task));&#10;        }&#10;    }&#10;    private UserType generateUserType() {&#10;        double rand = Math.random();&#10;        if (rand &lt; config.getNormalUserProbability()) return UserType.NORMAL;&#10;        else if (rand &lt; config.getNormalUserProbability() + config.getPersonalVipProbability()) return UserType.PERSONAL_VIP;&#10;        else return UserType.ENTERPRISE_VIP;&#10;    }&#10;    @Override&#10;    public void run() {&#10;        running = true;&#10;        double previousTime = 0.0;&#10;&#10;        while (running &amp;&amp; eventList.hasEvents() &amp;&amp; clock.getTime() &lt;= config.getSimulationTime()) {&#10;            synchronized (pauseLock) {&#10;                while (paused &amp;&amp; running) {&#10;                    try { pauseLock.wait(); } catch (InterruptedException e) { return; }&#10;                }&#10;            }&#10;            if (!running) break;&#10;            Event event = eventList.getNextEvent();&#10;            if (event != null) {&#10;                double targetTime = event.getTime();&#10;                double timeElapsed = targetTime - previousTime;&#10;&#10;                // Sleep proportional to simulated time elapsed, but break into small chunks&#10;                // for smooth time display updates&#10;                // At 1x speed: 1 simulated second = 1 real second (1000ms)&#10;                // At 2x speed: 1 simulated second = 0.5 real seconds (500ms)&#10;                if (timeElapsed &gt; 0) {&#10;                    // Capture current speed to avoid inconsistency if slider is adjusted during sleep&#10;                    double currentSpeed = speedMultiplier;&#10;                    long totalSleepTime = (long)(timeElapsed * 1000.0 / currentSpeed);&#10;                    long sleepChunk = 50; // Update UI every 50ms for smooth display&#10;                    long initialSleepTime = totalSleepTime;&#10;&#10;                    // Break the sleep into small chunks and update time progressively&#10;                    while (totalSleepTime &gt; 0 &amp;&amp; running &amp;&amp; !paused) {&#10;                        long currentSleep = Math.min(sleepChunk, totalSleepTime);&#10;                        try {&#10;                            Thread.sleep(currentSleep);&#10;                        } catch (InterruptedException e) {&#10;                            return;&#10;                        }&#10;&#10;                        // Update clock progressively for smooth display&#10;                        // Use initial sleep time to calculate consistent progress&#10;                        double progress = (double)(initialSleepTime - totalSleepTime + currentSleep) / initialSleepTime;&#10;                        double intermediateTime = previousTime + (timeElapsed * progress);&#10;                        clock.setTime(intermediateTime);&#10;&#10;                        if (listener != null) listener.onTimeUpdate(clock.getTime());&#10;&#10;                        totalSleepTime -= currentSleep;&#10;                    }&#10;                }&#10;&#10;                clock.setTime(targetTime);&#10;                processEvent(event);&#10;                previousTime = targetTime;&#10;&#10;                if (listener != null) listener.onTimeUpdate(clock.getTime());&#10;            }&#10;        }&#10;        running = false;&#10;        results.setTotalSimulationTime(clock.getTime());&#10;        if (listener != null) listener.onSimulationComplete();&#10;    }&#10;    private void processEvent(Event event) {&#10;        Task task = event.getTask();&#10;        switch (event.getType()) {&#10;            case ARRIVAL: handleArrival(task); break;&#10;            case DEP_DATA_STORAGE: handleDepartureDataStorage(task); break;&#10;            case DEP_CLASSIFICATION: handleDepartureClassification(task); break;&#10;            case DEP_CPU_COMPUTE: handleDepartureCpuCompute(task); break;&#10;            case DEP_GPU_COMPUTE: handleDepartureGpuCompute(task); break;&#10;            case DEP_RESULT_STORAGE: handleDepartureResultStorage(task); break;&#10;        }&#10;    }&#10;    private void handleArrival(Task task) {&#10;        results.recordArrival();&#10;        dataStorage.addToQueue(task);&#10;        if (dataStorage.isAvailable()) startServiceDataStorage();&#10;        scheduleNextArrival();&#10;    }&#10;    private void startServiceDataStorage() {&#10;        Task task = dataStorage.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = dataStorage.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_DATA_STORAGE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureDataStorage(Task task) {&#10;        dataStorage.endService();&#10;        classification.addToQueue(task);&#10;        if (classification.isAvailable()) startServiceClassification();&#10;        if (dataStorage.isAvailable() &amp;&amp; !dataStorage.isQueueEmpty()) startServiceDataStorage();&#10;    }&#10;    private void startServiceClassification() {&#10;        Task task = classification.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = classification.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_CLASSIFICATION, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;        classification.endService();&#10;        classification.endService(clock.getTime());&#10;        if (task.getTaskType() == TaskType.CPU) {&#10;            cpuQueue.addToQueue(task);&#10;            if (cpuCompute.isAvailable()) startServiceCpuCompute();&#10;        } else {&#10;            gpuQueue.addToQueue(task);&#10;            if (gpuCompute.isAvailable()) startServiceGpuCompute();&#10;        }&#10;        if (classification.isAvailable() &amp;&amp; !classification.isQueueEmpty()) startServiceClassification();&#10;    }&#10;        Task task = cpuQueue.beginService(clock.getTime());&#10;        if (task != null) {&#10;            cpuCompute.startService(clock.getTime());  // Mark compute node as busy&#10;            double serviceTime = cpuCompute.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_CPU_COMPUTE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;        Task task = gpuQueue.beginService(clock.getTime());&#10;        if (task != null) {&#10;            gpuCompute.startService(clock.getTime());  // Mark compute node as busy&#10;            double serviceTime = gpuCompute.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_GPU_COMPUTE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureCpuCompute(Task task) {&#10;        cpuCompute.endService();&#10;        resultStorage.addToQueue(task);&#10;        if (resultStorage.isAvailable()) startServiceResultStorage();&#10;        if (cpuCompute.isAvailable() &amp;&amp; !cpuQueue.isQueueEmpty()) startServiceCpuCompute();&#10;    }&#10;    private void handleDepartureGpuCompute(Task task) {&#10;        gpuCompute.endService(clock.getTime());&#10;        gpuCompute.endService();&#10;        if (resultStorage.isAvailable()) startServiceResultStorage();&#10;        if (gpuCompute.isAvailable() &amp;&amp; !gpuQueue.isQueueEmpty()) startServiceGpuCompute();&#10;    }&#10;    private void startServiceResultStorage() {&#10;        Task task = resultStorage.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = resultStorage.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_RESULT_STORAGE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureResultStorage(Task task) {&#10;        resultStorage.endService(clock.getTime());&#10;        resultStorage.endService();&#10;        results.recordCompletion(task);&#10;        if (resultStorage.isAvailable() &amp;&amp; !resultStorage.isQueueEmpty()) startServiceResultStorage();&#10;    }&#10;    public boolean isRunning() {&#10;        return running;&#10;    }&#10;&#10;    public boolean isPaused() {&#10;        return paused;&#10;    }&#10;&#10;    public void pauseSimulation() {&#10;        paused = true;&#10;    }&#10;&#10;    public void resumeSimulation() {&#10;        synchronized (pauseLock) {&#10;            paused = false;&#10;            pauseLock.notifyAll();&#10;        }&#10;    }&#10;&#10;    public void stopSimulation() {&#10;        running = false;&#10;        synchronized (pauseLock) {&#10;            pauseLock.notifyAll();&#10;        }&#10;    }&#10;&#10;    public void stepForward() {&#10;        if (paused &amp;&amp; eventList.hasEvents()) {&#10;            Event event = eventList.getNextEvent();&#10;            if (event != null) {&#10;                clock.setTime(event.getTime());&#10;                processEvent(event);&#10;                if (listener != null) listener.onTimeUpdate(clock.getTime());&#10;            }&#10;        }&#10;    }&#10;&#10;    public SimulationResults getResults() {&#10;        return results;&#10;    }&#10;    public ServicePoint getDataStorage() { return dataStorage; }&#10;    public ServicePoint getClassification() { return classification; }&#10;    public ServicePoint getCpuQueue() { return cpuQueue; }&#10;    public ServicePoint getGpuQueue() { return gpuQueue; }&#10;    public ServicePoint getCpuCompute() { return cpuCompute; }&#10;    public ServicePoint getGpuCompute() { return gpuCompute; }&#10;    public ServicePoint getResultStorage() { return resultStorage; }&#10;}&#10;" />
              <option name="updatedContent" value="package com.simulation.model;&#10;import com.simulation.util.RandomGenerator;&#10;public class SimulationEngine extends Thread {&#10;    private final SimulationConfig config;&#10;    private final SimulationResults results;&#10;    private final EventList eventList;&#10;    private final Clock clock;&#10;    private ServicePoint dataStorage, classification, cpuQueue, gpuQueue, cpuCompute, gpuCompute, resultStorage;&#10;    private volatile boolean running, paused;&#10;    private volatile double speedMultiplier = 1.0;&#10;    private final Object pauseLock = new Object();&#10;    private SimulationListener listener;&#10;    /**&#10;     * Listener interface for simulation events&#10;     */&#10;    public interface SimulationListener {&#10;        void onTimeUpdate(double time);&#10;        void onSimulationComplete();&#10;        default void onSimulationUpdate() {&#10;            onTimeUpdate(Clock.getInstance().getTime());&#10;        }&#10;    }&#10;    public SimulationEngine(SimulationConfig config) {&#10;        this.config = config;&#10;        this.results = new SimulationResults();&#10;        this.eventList = new EventList();&#10;        this.clock = Clock.getInstance();&#10;        initializeServicePoints();&#10;    }&#10;    private void initializeServicePoints() {&#10;        dataStorage = new ServicePoint(&quot;Data Storage&quot;, 1, config.getDataStorageServiceTime(), false);&#10;        classification = new ServicePoint(&quot;Classification&quot;, 1, config.getClassificationServiceTime(), false);&#10;        cpuQueue = new ServicePoint(&quot;CPU Queue&quot;, Integer.MAX_VALUE, 0, true);&#10;        gpuQueue = new ServicePoint(&quot;GPU Queue&quot;, Integer.MAX_VALUE, 0, true);&#10;        cpuCompute = new ServicePoint(&quot;CPU Compute&quot;, config.getNumCpuNodes(), config.getCpuComputeServiceTime(), false);&#10;        gpuCompute = new ServicePoint(&quot;GPU Compute&quot;, config.getNumGpuNodes(), config.getGpuComputeServiceTime(), false);&#10;        resultStorage = new ServicePoint(&quot;Result Storage&quot;, 1, config.getResultStorageServiceTime(), false);&#10;    }&#10;    public void setListener(SimulationListener listener) {&#10;        this.listener = listener;&#10;    }&#10;    public void setSpeed(double speed) {&#10;        this.speedMultiplier = Math.max(0.1, Math.min(100.0, speed));&#10;    }&#10;    public void initialize() {&#10;        clock.reset();&#10;        eventList.clear();&#10;        results.reset();&#10;        dataStorage.reset();&#10;        classification.reset();&#10;        cpuCompute.reset();&#10;        gpuCompute.reset();&#10;        resultStorage.reset();&#10;        scheduleNextArrival();&#10;    }&#10;    private void scheduleNextArrival() {&#10;        double arrivalTime = clock.getTime() + RandomGenerator.exponential(config.getMeanArrivalInterval());&#10;        if (arrivalTime &lt;= config.getSimulationTime()) {&#10;            TaskType taskType = RandomGenerator.bernoulli(config.getCpuTaskProbability()) ? TaskType.CPU : TaskType.GPU;&#10;            UserType userType = generateUserType();&#10;            Task task = new Task(taskType, userType, arrivalTime);&#10;            eventList.addEvent(new Event(EventType.ARRIVAL, arrivalTime, task));&#10;        }&#10;    }&#10;    private UserType generateUserType() {&#10;        double rand = Math.random();&#10;        if (rand &lt; config.getNormalUserProbability()) return UserType.NORMAL;&#10;        else if (rand &lt; config.getNormalUserProbability() + config.getPersonalVipProbability()) return UserType.PERSONAL_VIP;&#10;        else return UserType.ENTERPRISE_VIP;&#10;    }&#10;    @Override&#10;    public void run() {&#10;        running = true;&#10;        double previousTime = 0.0;&#10;&#10;        while (running &amp;&amp; eventList.hasEvents() &amp;&amp; clock.getTime() &lt;= config.getSimulationTime()) {&#10;            synchronized (pauseLock) {&#10;                while (paused &amp;&amp; running) {&#10;                    try { pauseLock.wait(); } catch (InterruptedException e) { return; }&#10;                }&#10;            }&#10;            if (!running) break;&#10;            Event event = eventList.getNextEvent();&#10;            if (event != null) {&#10;                double targetTime = event.getTime();&#10;                double timeElapsed = targetTime - previousTime;&#10;&#10;                // Sleep proportional to simulated time elapsed, but break into small chunks&#10;                // for smooth time display updates&#10;                // At 1x speed: 1 simulated second = 1 real second (1000ms)&#10;                // At 2x speed: 1 simulated second = 0.5 real seconds (500ms)&#10;                if (timeElapsed &gt; 0) {&#10;                    // Capture current speed to avoid inconsistency if slider is adjusted during sleep&#10;                    double currentSpeed = speedMultiplier;&#10;                    long totalSleepTime = (long)(timeElapsed * 1000.0 / currentSpeed);&#10;                    long sleepChunk = 50; // Update UI every 50ms for smooth display&#10;                    long initialSleepTime = totalSleepTime;&#10;&#10;                    // Break the sleep into small chunks and update time progressively&#10;                    while (totalSleepTime &gt; 0 &amp;&amp; running &amp;&amp; !paused) {&#10;                        long currentSleep = Math.min(sleepChunk, totalSleepTime);&#10;                        try {&#10;                            Thread.sleep(currentSleep);&#10;                        } catch (InterruptedException e) {&#10;                            return;&#10;                        }&#10;&#10;                        // Update clock progressively for smooth display&#10;                        // Use initial sleep time to calculate consistent progress&#10;                        double progress = (double)(initialSleepTime - totalSleepTime + currentSleep) / initialSleepTime;&#10;                        double intermediateTime = previousTime + (timeElapsed * progress);&#10;                        clock.setTime(intermediateTime);&#10;&#10;                        if (listener != null) listener.onTimeUpdate(clock.getTime());&#10;&#10;                        totalSleepTime -= currentSleep;&#10;                    }&#10;                }&#10;&#10;                clock.setTime(targetTime);&#10;                processEvent(event);&#10;                previousTime = targetTime;&#10;&#10;                if (listener != null) listener.onTimeUpdate(clock.getTime());&#10;            }&#10;        }&#10;        running = false;&#10;        results.setTotalSimulationTime(clock.getTime());&#10;        if (listener != null) listener.onSimulationComplete();&#10;    }&#10;    private void processEvent(Event event) {&#10;        Task task = event.getTask();&#10;        switch (event.getType()) {&#10;            case ARRIVAL: handleArrival(task); break;&#10;            case DEP_DATA_STORAGE: handleDepartureDataStorage(task); break;&#10;            case DEP_CLASSIFICATION: handleDepartureClassification(task); break;&#10;            case DEP_CPU_COMPUTE: handleDepartureCpuCompute(task); break;&#10;            case DEP_GPU_COMPUTE: handleDepartureGpuCompute(task); break;&#10;            case DEP_RESULT_STORAGE: handleDepartureResultStorage(task); break;&#10;        }&#10;    }&#10;    private void handleArrival(Task task) {&#10;        results.recordArrival();&#10;        dataStorage.addToQueue(task);&#10;        if (dataStorage.isAvailable()) startServiceDataStorage();&#10;        scheduleNextArrival();&#10;    }&#10;    private void startServiceDataStorage() {&#10;        Task task = dataStorage.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = dataStorage.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_DATA_STORAGE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureDataStorage(Task task) {&#10;        dataStorage.endService(clock.getTime());&#10;        classification.addToQueue(task);&#10;        if (classification.isAvailable()) startServiceClassification();&#10;        if (dataStorage.isAvailable() &amp;&amp; !dataStorage.isQueueEmpty()) startServiceDataStorage();&#10;    }&#10;    private void startServiceClassification() {&#10;        Task task = classification.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = classification.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_CLASSIFICATION, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureClassification(Task task) {&#10;        classification.endService(clock.getTime());&#10;        // Add task directly to CPU/GPU compute service point (which now has its own queue)&#10;        if (task.getTaskType() == TaskType.CPU) {&#10;            cpuCompute.addToQueue(task);&#10;            if (cpuCompute.isAvailable()) startServiceCpuCompute();&#10;        } else {&#10;            gpuCompute.addToQueue(task);&#10;            if (gpuCompute.isAvailable()) startServiceGpuCompute();&#10;        }&#10;        if (classification.isAvailable() &amp;&amp; !classification.isQueueEmpty()) startServiceClassification();&#10;    }&#10;&#10;    private void startServiceCpuCompute() {&#10;        Task task = cpuCompute.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = cpuCompute.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_CPU_COMPUTE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;&#10;    private void startServiceGpuCompute() {&#10;        Task task = gpuCompute.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = gpuCompute.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_GPU_COMPUTE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;&#10;    private void handleDepartureCpuCompute(Task task) {&#10;        cpuCompute.endService(clock.getTime());&#10;        resultStorage.addToQueue(task);&#10;        if (resultStorage.isAvailable()) startServiceResultStorage();&#10;        if (cpuCompute.isAvailable() &amp;&amp; !cpuCompute.isQueueEmpty()) startServiceCpuCompute();&#10;    }&#10;&#10;    private void handleDepartureGpuCompute(Task task) {&#10;        gpuCompute.endService(clock.getTime());&#10;        resultStorage.addToQueue(task);&#10;        if (resultStorage.isAvailable()) startServiceResultStorage();&#10;        if (gpuCompute.isAvailable() &amp;&amp; !gpuCompute.isQueueEmpty()) startServiceGpuCompute();&#10;    }&#10;    private void startServiceResultStorage() {&#10;        Task task = resultStorage.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = resultStorage.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_RESULT_STORAGE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureResultStorage(Task task) {&#10;        resultStorage.endService(clock.getTime());&#10;        task.setCompletionTime(clock.getTime());&#10;        results.recordCompletion(task);&#10;        if (resultStorage.isAvailable() &amp;&amp; !resultStorage.isQueueEmpty()) startServiceResultStorage();&#10;    }&#10;    public boolean isRunning() {&#10;        return running;&#10;    }&#10;&#10;    public boolean isPaused() {&#10;        return paused;&#10;    }&#10;&#10;    public void pauseSimulation() {&#10;        paused = true;&#10;    }&#10;&#10;    public void resumeSimulation() {&#10;        synchronized (pauseLock) {&#10;            paused = false;&#10;            pauseLock.notifyAll();&#10;        }&#10;    }&#10;&#10;    public void stopSimulation() {&#10;        running = false;&#10;        synchronized (pauseLock) {&#10;            pauseLock.notifyAll();&#10;        }&#10;    }&#10;&#10;    public void stepForward() {&#10;        if (paused &amp;&amp; eventList.hasEvents()) {&#10;            Event event = eventList.getNextEvent();&#10;            if (event != null) {&#10;                clock.setTime(event.getTime());&#10;                processEvent(event);&#10;                if (listener != null) listener.onTimeUpdate(clock.getTime());&#10;            }&#10;        }&#10;    }&#10;&#10;    public SimulationResults getResults() {&#10;        return results;&#10;    }&#10;    public ServicePoint getDataStorage() { return dataStorage; }&#10;    public ServicePoint getClassification() { return classification; }&#10;    public ServicePoint getCpuCompute() { return cpuCompute; }&#10;    public ServicePoint getGpuCompute() { return gpuCompute; }&#10;    public ServicePoint getResultStorage() { return resultStorage; }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/simulation/view/SimulationView.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/simulation/view/SimulationView.java" />
              <option name="originalContent" value="package com.simulation.view;&#10;&#10;import com.simulation.controller.SimulationController;&#10;import com.simulation.model.*;&#10;import javafx.application.Platform;&#10;import javafx.geometry.Insets;&#10;import javafx.geometry.Pos;&#10;import javafx.scene.Scene;&#10;import javafx.scene.canvas.Canvas;&#10;import javafx.scene.canvas.GraphicsContext;&#10;import javafx.scene.control.*;&#10;import javafx.scene.layout.*;&#10;import javafx.scene.paint.Color;&#10;import javafx.scene.text.Font;&#10;import javafx.scene.text.FontWeight;&#10;import javafx.stage.Stage;&#10;&#10;/**&#10; * Main JavaFX view for the simulation&#10; */&#10;public class SimulationView {&#10;    private final SimulationController controller;&#10;    private Stage stage;&#10;&#10;    // UI Components&#10;    private Canvas canvas;&#10;    private TextArea statsArea;&#10;    private Label timeLabel;&#10;    private Button startButton;&#10;    private Button pauseButton;&#10;    private Button stepButton;&#10;    private Button stopButton;&#10;    private Button resetButton;&#10;&#10;    // Configuration controls&#10;    private TextField arrivalIntervalField;&#10;    private TextField cpuNodesField;&#10;    private TextField gpuNodesField;&#10;    private TextField simulationTimeField;&#10;    private Slider speedSlider;&#10;&#10;    public SimulationView(SimulationController controller) {&#10;        this.controller = controller;&#10;    }&#10;&#10;    public void start(Stage primaryStage) {&#10;        this.stage = primaryStage;&#10;        primaryStage.setTitle(&quot;Cloud Computing Service Queue Simulation&quot;);&#10;&#10;        BorderPane root = new BorderPane();&#10;        root.setPadding(new Insets(10));&#10;&#10;        // Top: Control panel&#10;        root.setTop(createControlPanel());&#10;&#10;        // Center: Visualization canvas&#10;        root.setCenter(createVisualizationPanel());&#10;&#10;        // Right: Statistics panel&#10;        root.setRight(createStatsPanel());&#10;&#10;        // Bottom: Configuration panel&#10;        root.setBottom(createConfigPanel());&#10;&#10;        Scene scene = new Scene(root, 1400, 800);&#10;        primaryStage.setScene(scene);&#10;        primaryStage.show();&#10;&#10;        // Set up simulation listener&#10;        updateSimulationListener();&#10;    }&#10;&#10;    private VBox createControlPanel() {&#10;        VBox controlBox = new VBox(10);&#10;        controlBox.setPadding(new Insets(10));&#10;        controlBox.setAlignment(Pos.CENTER);&#10;&#10;        Label titleLabel = new Label(&quot;Simulation Controls&quot;);&#10;        titleLabel.setFont(Font.font(&quot;Arial&quot;, FontWeight.BOLD, 16));&#10;&#10;        HBox buttonBox = new HBox(10);&#10;        buttonBox.setAlignment(Pos.CENTER);&#10;&#10;        startButton = new Button(&quot;Start&quot;);&#10;        startButton.setOnAction(e -&gt; startSimulation());&#10;&#10;        pauseButton = new Button(&quot;Pause&quot;);&#10;        pauseButton.setOnAction(e -&gt; pauseSimulation());&#10;        pauseButton.setDisable(true);&#10;&#10;        stepButton = new Button(&quot;Step&quot;);&#10;        stepButton.setOnAction(e -&gt; stepSimulation());&#10;&#10;        stopButton = new Button(&quot;Stop&quot;);&#10;        stopButton.setOnAction(e -&gt; stopSimulation());&#10;        stopButton.setDisable(true);&#10;&#10;        resetButton = new Button(&quot;Reset&quot;);&#10;        resetButton.setOnAction(e -&gt; resetSimulation());&#10;&#10;        timeLabel = new Label(&quot;Time: 0.00s&quot;);&#10;        timeLabel.setFont(Font.font(&quot;Arial&quot;, FontWeight.BOLD, 14));&#10;&#10;        buttonBox.getChildren().addAll(startButton, pauseButton, stepButton, stopButton, resetButton, timeLabel);&#10;        controlBox.getChildren().addAll(titleLabel, buttonBox);&#10;&#10;        return controlBox;&#10;    }&#10;&#10;    private VBox createVisualizationPanel() {&#10;        VBox vizBox = new VBox(10);&#10;        vizBox.setPadding(new Insets(10));&#10;        vizBox.setAlignment(Pos.CENTER);&#10;&#10;        Label titleLabel = new Label(&quot;System Visualization&quot;);&#10;        titleLabel.setFont(Font.font(&quot;Arial&quot;, FontWeight.BOLD, 16));&#10;&#10;        canvas = new Canvas(800, 600);&#10;        drawInitialState();&#10;&#10;        vizBox.getChildren().addAll(titleLabel, canvas);&#10;        return vizBox;&#10;    }&#10;&#10;    private VBox createStatsPanel() {&#10;        VBox statsBox = new VBox(10);&#10;        statsBox.setPadding(new Insets(10));&#10;        statsBox.setPrefWidth(350);&#10;&#10;        Label titleLabel = new Label(&quot;Statistics&quot;);&#10;        titleLabel.setFont(Font.font(&quot;Arial&quot;, FontWeight.BOLD, 16));&#10;&#10;        statsArea = new TextArea();&#10;        statsArea.setEditable(false);&#10;        statsArea.setPrefHeight(700);&#10;        statsArea.setFont(Font.font(&quot;Courier New&quot;, 11));&#10;&#10;        statsBox.getChildren().addAll(titleLabel, statsArea);&#10;        return statsBox;&#10;    }&#10;&#10;    private VBox createConfigPanel() {&#10;        VBox configBox = new VBox(10);&#10;        configBox.setPadding(new Insets(10));&#10;&#10;        Label titleLabel = new Label(&quot;Configuration Parameters&quot;);&#10;        titleLabel.setFont(Font.font(&quot;Arial&quot;, FontWeight.BOLD, 14));&#10;&#10;        GridPane grid = new GridPane();&#10;        grid.setHgap(10);&#10;        grid.setVgap(5);&#10;&#10;        int row = 0;&#10;&#10;        // Arrival interval&#10;        grid.add(new Label(&quot;Mean Arrival Interval (s):&quot;), 0, row);&#10;        arrivalIntervalField = new TextField(String.valueOf(controller.getConfig().getMeanArrivalInterval()));&#10;        grid.add(arrivalIntervalField, 1, row++);&#10;&#10;        // CPU nodes&#10;        grid.add(new Label(&quot;CPU Compute Nodes:&quot;), 0, row);&#10;        cpuNodesField = new TextField(String.valueOf(controller.getConfig().getNumCpuNodes()));&#10;        grid.add(cpuNodesField, 1, row++);&#10;&#10;        // GPU nodes&#10;        grid.add(new Label(&quot;GPU Compute Nodes:&quot;), 0, row);&#10;        gpuNodesField = new TextField(String.valueOf(controller.getConfig().getNumGpuNodes()));&#10;        grid.add(gpuNodesField, 1, row++);&#10;&#10;        // Simulation time&#10;        grid.add(new Label(&quot;Simulation Time (s):&quot;), 0, row);&#10;        simulationTimeField = new TextField(String.valueOf(controller.getConfig().getSimulationTime()));&#10;        grid.add(simulationTimeField, 1, row++);&#10;&#10;        // Speed control&#10;        grid.add(new Label(&quot;Simulation Speed:&quot;), 0, row);&#10;        speedSlider = new Slider(0.1, 5.0, 1.0);&#10;        speedSlider.setShowTickLabels(true);&#10;        speedSlider.setShowTickMarks(true);&#10;        speedSlider.setMajorTickUnit(1.0);&#10;        speedSlider.valueProperty().addListener((obs, oldVal, newVal) -&gt; {&#10;            controller.getConfig().setSpeedMultiplier(newVal.doubleValue());&#10;        });&#10;        grid.add(speedSlider, 1, row++);&#10;&#10;        Button applyButton = new Button(&quot;Apply Configuration&quot;);&#10;        applyButton.setOnAction(e -&gt; applyConfiguration());&#10;        grid.add(applyButton, 0, row, 2, 1);&#10;&#10;        configBox.getChildren().addAll(titleLabel, grid);&#10;        return configBox;&#10;    }&#10;&#10;    private void drawInitialState() {&#10;        GraphicsContext gc = canvas.getGraphicsContext2D();&#10;        gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());&#10;        gc.setFill(Color.WHITE);&#10;        gc.fillRect(0, 0, canvas.getWidth(), canvas.getHeight());&#10;&#10;        drawSystemDiagram(gc);&#10;    }&#10;&#10;    private void drawSystemDiagram(GraphicsContext gc) {&#10;        // Draw the system flow diagram&#10;        gc.setStroke(Color.BLACK);&#10;        gc.setLineWidth(2);&#10;&#10;        double startX = 50;&#10;        double startY = 300;&#10;        double spacing = 100;&#10;&#10;        // Draw service points as boxes&#10;        drawServicePoint(gc, startX, startY, &quot;Arrival&quot;, Color.LIGHTGREEN, 0, 0);&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#10;&#10;        startX += spacing;&#10;        drawServicePoint(gc, startX, startY, &quot;Data\nStorage&quot;, Color.LIGHTBLUE, 0, 0);&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#10;&#10;        startX += spacing;&#10;        drawServicePoint(gc, startX, startY, &quot;Classification&quot;, Color.LIGHTYELLOW, 0, 0);&#10;&#10;        // Split into CPU and GPU paths&#10;        double cpuY = startY - 100;&#10;        double gpuY = startY + 100;&#10;&#10;        // CPU path&#10;        drawArrow(gc, startX + 30, startY - 30, startX + 30, cpuY + 30);&#10;        drawServicePoint(gc, startX, cpuY, &quot;CPU\nQueue&quot;, Color.ORANGE, 0, 0);&#10;        drawArrow(gc, startX + 60, cpuY, startX + spacing, cpuY);&#10;&#10;        double cpuComputeX = startX + spacing;&#10;        drawServicePoint(gc, cpuComputeX, cpuY, &quot;CPU\nCompute&quot;, Color.CORAL, 0, 0);&#10;&#10;        // GPU path&#10;        drawArrow(gc, startX + 30, startY + 30, startX + 30, gpuY - 30);&#10;        drawServicePoint(gc, startX, gpuY, &quot;GPU\nQueue&quot;, Color.PINK, 0, 0);&#10;        drawArrow(gc, startX + 60, gpuY, startX + spacing, gpuY);&#10;&#10;        double gpuComputeX = startX + spacing;&#10;        drawServicePoint(gc, gpuComputeX, gpuY, &quot;GPU\nCompute&quot;, Color.PLUM, 0, 0);&#10;&#10;        // Merge to result storage&#10;        double resultX = cpuComputeX + spacing;&#10;        drawArrow(gc, cpuComputeX + 60, cpuY, resultX, startY);&#10;        drawArrow(gc, gpuComputeX + 60, gpuY, resultX, startY);&#10;&#10;        drawServicePoint(gc, resultX, startY, &quot;Result\nStorage&quot;, Color.LIGHTGREEN, 0, 0);&#10;        drawArrow(gc, resultX + 60, startY, resultX + 80, startY);&#10;&#10;        gc.fillText(&quot;Exit&quot;, resultX + 85, startY + 5);&#10;    }&#10;&#10;    private void drawServicePoint(GraphicsContext gc, double x, double y, String name, Color color, int queueLength, int busyServers) {&#10;        // Draw box&#10;        gc.setFill(color);&#10;        gc.fillRect(x, y - 30, 60, 60);&#10;        gc.setStroke(Color.BLACK);&#10;        gc.strokeRect(x, y - 30, 60, 60);&#10;&#10;        // Draw name&#10;        gc.setFill(Color.BLACK);&#10;        gc.setFont(Font.font(&quot;Arial&quot;, 10));&#10;        String[] lines = name.split(&quot;\n&quot;);&#10;        for (int i = 0; i &lt; lines.length; i++) {&#10;            gc.fillText(lines[i], x + 5, y - 10 + i * 12);&#10;        }&#10;&#10;        // Draw queue length if &gt; 0&#10;        if (queueLength &gt; 0) {&#10;            gc.setFill(Color.RED);&#10;            gc.fillText(&quot;Q:&quot; + queueLength, x + 5, y + 20);&#10;        }&#10;    }&#10;&#10;    private void drawArrow(GraphicsContext gc, double x1, double y1, double x2, double y2) {&#10;        gc.strokeLine(x1, y1, x2, y2);&#10;&#10;        // Draw arrowhead&#10;        double angle = Math.atan2(y2 - y1, x2 - x1);&#10;        double arrowLength = 10;&#10;        double arrowAngle = Math.PI / 6;&#10;&#10;        double x3 = x2 - arrowLength * Math.cos(angle - arrowAngle);&#10;        double y3 = y2 - arrowLength * Math.sin(angle - arrowAngle);&#10;        double x4 = x2 - arrowLength * Math.cos(angle + arrowAngle);&#10;        double y4 = y2 - arrowLength * Math.sin(angle + arrowAngle);&#10;&#10;        gc.strokeLine(x2, y2, x3, y3);&#10;        gc.strokeLine(x2, y2, x4, y4);&#10;    }&#10;&#10;    private void updateVisualization() {&#10;        if (controller.getEngine() == null) return;&#10;&#10;        GraphicsContext gc = canvas.getGraphicsContext2D();&#10;        gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());&#10;        gc.setFill(Color.WHITE);&#10;        gc.fillRect(0, 0, canvas.getWidth(), canvas.getHeight());&#10;&#10;        // Redraw with current state&#10;        SimulationEngine engine = controller.getEngine();&#10;        drawSystemWithState(gc, engine);&#10;    }&#10;&#10;    private void drawSystemWithState(GraphicsContext gc, SimulationEngine engine) {&#10;        gc.setStroke(Color.BLACK);&#10;        gc.setLineWidth(2);&#10;&#10;        double startX = 50;&#10;        double startY = 300;&#10;        double spacing = 100;&#10;&#10;        // Draw service points with current state&#10;        drawServicePoint(gc, startX, startY, &quot;Arrival&quot;, Color.LIGHTGREEN, 0, 0);&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#10;&#10;        startX += spacing;&#10;        ServicePoint dataStorage = engine.getDataStorage();&#10;        drawServicePoint(gc, startX, startY, &quot;Data\nStorage&quot;, Color.LIGHTBLUE,&#10;            dataStorage.getQueueLength(), dataStorage.getBusyServers());&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#10;&#10;        startX += spacing;&#10;        ServicePoint classification = engine.getClassification();&#10;        drawServicePoint(gc, startX, startY, &quot;Classification&quot;, Color.LIGHTYELLOW,&#10;            classification.getQueueLength(), classification.getBusyServers());&#10;&#10;        // CPU and GPU paths&#10;        double cpuY = startY - 100;&#10;        double gpuY = startY + 100;&#10;&#10;        drawArrow(gc, startX + 30, startY - 30, startX + 30, cpuY + 30);&#10;        ServicePoint cpuQueue = engine.getCpuQueue();&#10;        drawServicePoint(gc, startX, cpuY, &quot;CPU\nQueue&quot;, Color.ORANGE,&#10;            cpuQueue.getQueueLength(), 0);&#10;        drawArrow(gc, startX + 60, cpuY, startX + spacing, cpuY);&#10;&#10;        double cpuComputeX = startX + spacing;&#10;        ServicePoint cpuCompute = engine.getCpuCompute();&#10;        drawServicePoint(gc, cpuComputeX, cpuY, &quot;CPU\nCompute&quot;, Color.CORAL,&#10;            0, cpuCompute.getBusyServers());&#10;&#10;        drawArrow(gc, startX + 30, startY + 30, startX + 30, gpuY - 30);&#10;        ServicePoint gpuQueue = engine.getGpuQueue();&#10;        drawServicePoint(gc, startX, gpuY, &quot;GPU\nQueue&quot;, Color.PINK,&#10;            gpuQueue.getQueueLength(), 0);&#10;        drawArrow(gc, startX + 60, gpuY, startX + spacing, gpuY);&#10;&#10;        double gpuComputeX = startX + spacing;&#10;        ServicePoint gpuCompute = engine.getGpuCompute();&#10;        drawServicePoint(gc, gpuComputeX, gpuY, &quot;GPU\nCompute&quot;, Color.PLUM,&#10;            0, gpuCompute.getBusyServers());&#10;&#10;        double resultX = cpuComputeX + spacing;&#10;        drawArrow(gc, cpuComputeX + 60, cpuY, resultX, startY);&#10;        drawArrow(gc, gpuComputeX + 60, gpuY, resultX, startY);&#10;&#10;        ServicePoint resultStorage = engine.getResultStorage();&#10;        drawServicePoint(gc, resultX, startY, &quot;Result\nStorage&quot;, Color.LIGHTGREEN,&#10;            resultStorage.getQueueLength(), resultStorage.getBusyServers());&#10;        drawArrow(gc, resultX + 60, startY, resultX + 80, startY);&#10;&#10;        gc.fillText(&quot;Exit&quot;, resultX + 85, startY + 5);&#10;    }&#10;&#10;    private void updateStatistics() {&#10;        if (controller.getEngine() == null) return;&#10;&#10;        SimulationEngine engine = controller.getEngine();&#10;        SimulationResults results = engine.getResults();&#10;&#10;        StringBuilder stats = new StringBuilder();&#10;        stats.append(&quot;=== SIMULATION STATISTICS ===\n\n&quot;);&#10;&#10;        stats.append(&quot;Current Time: &quot;).append(String.format(&quot;%.2f&quot;, controller.getCurrentTime())).append(&quot; s\n\n&quot;);&#10;&#10;        stats.append(&quot;--- Task Statistics ---\n&quot;);&#10;        stats.append(&quot;Tasks Arrived: &quot;).append(results.getTotalTasksArrived()).append(&quot;\n&quot;);&#10;        stats.append(&quot;Tasks Completed: &quot;).append(results.getTotalTasksCompleted()).append(&quot;\n&quot;);&#10;        stats.append(&quot;CPU Tasks: &quot;).append(results.getCpuTasksCompleted()).append(&quot;\n&quot;);&#10;        stats.append(&quot;GPU Tasks: &quot;).append(results.getGpuTasksCompleted()).append(&quot;\n\n&quot;);&#10;&#10;        stats.append(&quot;--- User Type Statistics ---\n&quot;);&#10;        stats.append(&quot;Normal Users: &quot;).append(results.getNormalUserTasksCompleted()).append(&quot;\n&quot;);&#10;        stats.append(&quot;Personal VIP: &quot;).append(results.getPersonalVipTasksCompleted()).append(&quot;\n&quot;);&#10;        stats.append(&quot;Enterprise VIP: &quot;).append(results.getEnterpriseVipTasksCompleted()).append(&quot;\n\n&quot;);&#10;&#10;        stats.append(&quot;--- Performance Metrics ---\n&quot;);&#10;        stats.append(&quot;Avg System Time: &quot;).append(String.format(&quot;%.2f&quot;, results.getAverageSystemTime())).append(&quot; s\n&quot;);&#10;        stats.append(&quot;Min System Time: &quot;).append(String.format(&quot;%.2f&quot;, results.getMinSystemTime())).append(&quot; s\n&quot;);&#10;        stats.append(&quot;Max System Time: &quot;).append(String.format(&quot;%.2f&quot;, results.getMaxSystemTime())).append(&quot; s\n&quot;);&#10;        stats.append(&quot;Throughput: &quot;).append(String.format(&quot;%.4f&quot;, results.getThroughput(controller.getCurrentTime()))).append(&quot; tasks/s\n\n&quot;);&#10;&#10;        stats.append(&quot;--- Service Point Statistics ---\n&quot;);&#10;        addServicePointStats(stats, &quot;Data Storage&quot;, engine.getDataStorage());&#10;        addServicePointStats(stats, &quot;Classification&quot;, engine.getClassification());&#10;        addServicePointStats(stats, &quot;CPU Queue&quot;, engine.getCpuQueue());&#10;        addServicePointStats(stats, &quot;CPU Compute&quot;, engine.getCpuCompute());&#10;        addServicePointStats(stats, &quot;GPU Queue&quot;, engine.getGpuQueue());&#10;        addServicePointStats(stats, &quot;GPU Compute&quot;, engine.getGpuCompute());&#10;        addServicePointStats(stats, &quot;Result Storage&quot;, engine.getResultStorage());&#10;&#10;        statsArea.setText(stats.toString());&#10;    }&#10;&#10;    private void addServicePointStats(StringBuilder stats, String name, ServicePoint sp) {&#10;        stats.append(name).append(&quot;:\n&quot;);&#10;        stats.append(&quot;  Queue Length: &quot;).append(sp.getQueueLength()).append(&quot;\n&quot;);&#10;        stats.append(&quot;  Max Queue: &quot;).append(sp.getMaxQueueLength()).append(&quot;\n&quot;);&#10;        stats.append(&quot;  Tasks Served: &quot;).append(sp.getTasksServed()).append(&quot;\n&quot;);&#10;        stats.append(&quot;  Avg Queue Time: &quot;).append(String.format(&quot;%.2f&quot;, sp.getAverageQueueTime())).append(&quot; s\n&quot;);&#10;        stats.append(&quot;  Utilization: &quot;).append(String.format(&quot;%.2f%%&quot;, sp.getUtilization(controller.getCurrentTime()) * 100)).append(&quot;\n\n&quot;);&#10;    }&#10;&#10;    private void updateSimulationListener() {&#10;        controller.setSimulationListener(new SimulationEngine.SimulationListener() {&#10;            @Override&#10;            public void onTimeUpdate(double time) {&#10;                Platform.runLater(() -&gt; {&#10;                    timeLabel.setText(String.format(&quot;Time: %.2fs&quot;, time));&#10;                    updateVisualization();&#10;                    updateStatistics();&#10;                });&#10;            }&#10;&#10;            @Override&#10;            public void onSimulationComplete() {&#10;                Platform.runLater(() -&gt; {&#10;                    updateVisualization();&#10;                    updateStatistics();&#10;                    startButton.setDisable(true);&#10;                    pauseButton.setDisable(true);&#10;                    stepButton.setDisable(true);&#10;                    stopButton.setDisable(true);&#10;&#10;                    Alert alert = new Alert(Alert.AlertType.INFORMATION);&#10;                    alert.setTitle(&quot;Simulation Complete&quot;);&#10;                    alert.setHeaderText(&quot;Simulation has finished&quot;);&#10;                    alert.setContentText(&quot;The simulation has completed. Check the statistics for results.&quot;);&#10;                    alert.showAndWait();&#10;                });&#10;            }&#10;        });&#10;    }&#10;&#10;    private void startSimulation() {&#10;        applyConfiguration();&#10;        controller.initializeSimulation();&#10;        updateSimulationListener();&#10;        controller.startSimulation();&#10;&#10;        startButton.setDisable(true);&#10;        pauseButton.setDisable(false);&#10;        stopButton.setDisable(false);&#10;    }&#10;&#10;    private void pauseSimulation() {&#10;        if (controller.getEngine().isPaused()) {&#10;            controller.resumeSimulation();&#10;            pauseButton.setText(&quot;Pause&quot;);&#10;        } else {&#10;            controller.pauseSimulation();&#10;            pauseButton.setText(&quot;Resume&quot;);&#10;        }&#10;    }&#10;&#10;    private void stepSimulation() {&#10;        controller.stepSimulation();&#10;    }&#10;&#10;    private void stopSimulation() {&#10;        controller.stopSimulation();&#10;        startButton.setDisable(false);&#10;        pauseButton.setDisable(true);&#10;        stopButton.setDisable(true);&#10;    }&#10;&#10;    private void resetSimulation() {&#10;        controller.stopSimulation();&#10;        controller.initializeSimulation();&#10;        updateSimulationListener();&#10;&#10;        timeLabel.setText(&quot;Time: 0.00s&quot;);&#10;        drawInitialState();&#10;        statsArea.clear();&#10;&#10;        startButton.setDisable(false);&#10;        pauseButton.setDisable(true);&#10;        pauseButton.setText(&quot;Pause&quot;);&#10;        stepButton.setDisable(false);&#10;        stopButton.setDisable(true);&#10;    }&#10;&#10;    private void applyConfiguration() {&#10;        try {&#10;            SimulationConfig config = controller.getConfig();&#10;            config.setMeanArrivalInterval(Double.parseDouble(arrivalIntervalField.getText()));&#10;            config.setNumCpuNodes(Integer.parseInt(cpuNodesField.getText()));&#10;            config.setNumGpuNodes(Integer.parseInt(gpuNodesField.getText()));&#10;            config.setSimulationTime(Double.parseDouble(simulationTimeField.getText()));&#10;        } catch (NumberFormatException e) {&#10;            Alert alert = new Alert(Alert.AlertType.ERROR);&#10;            alert.setTitle(&quot;Invalid Input&quot;);&#10;            alert.setHeaderText(&quot;Configuration Error&quot;);&#10;            alert.setContentText(&quot;Please enter valid numbers for all configuration fields.&quot;);&#10;            alert.showAndWait();&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.simulation.view;&#10;&#10;import com.simulation.controller.SimulationController;&#10;import com.simulation.model.*;&#10;import javafx.application.Platform;&#10;import javafx.geometry.Insets;&#10;import javafx.geometry.Pos;&#10;import javafx.scene.Scene;&#10;import javafx.scene.canvas.Canvas;&#10;import javafx.scene.canvas.GraphicsContext;&#10;import javafx.scene.control.*;&#10;import javafx.scene.layout.*;&#10;import javafx.scene.paint.Color;&#10;import javafx.scene.text.Font;&#10;import javafx.scene.text.FontWeight;&#10;import javafx.stage.Stage;&#10;&#10;/**&#10; * Main JavaFX view for the simulation&#10; */&#10;public class SimulationView {&#10;    private final SimulationController controller;&#10;    private Stage stage;&#10;&#10;    // UI Components&#10;    private Canvas canvas;&#10;    private TextArea statsArea;&#10;    private Label timeLabel;&#10;    private Button startButton;&#10;    private Button pauseButton;&#10;    private Button stepButton;&#10;    private Button stopButton;&#10;    private Button resetButton;&#10;&#10;    // Configuration controls&#10;    private TextField arrivalIntervalField;&#10;    private TextField cpuNodesField;&#10;    private TextField gpuNodesField;&#10;    private TextField simulationTimeField;&#10;    private Slider speedSlider;&#10;&#10;    public SimulationView(SimulationController controller) {&#10;        this.controller = controller;&#10;    }&#10;&#10;    public void start(Stage primaryStage) {&#10;        this.stage = primaryStage;&#10;        primaryStage.setTitle(&quot;Cloud Computing Service Queue Simulation&quot;);&#10;&#10;        BorderPane root = new BorderPane();&#10;        root.setPadding(new Insets(10));&#10;&#10;        // Top: Control panel&#10;        root.setTop(createControlPanel());&#10;&#10;        // Center: Visualization canvas&#10;        root.setCenter(createVisualizationPanel());&#10;&#10;        // Right: Statistics panel&#10;        root.setRight(createStatsPanel());&#10;&#10;        // Bottom: Configuration panel&#10;        root.setBottom(createConfigPanel());&#10;&#10;        Scene scene = new Scene(root, 1400, 800);&#10;        primaryStage.setScene(scene);&#10;        primaryStage.show();&#10;&#10;        // Set up simulation listener&#10;        updateSimulationListener();&#10;    }&#10;&#10;    private VBox createControlPanel() {&#10;        VBox controlBox = new VBox(10);&#10;        controlBox.setPadding(new Insets(10));&#10;        controlBox.setAlignment(Pos.CENTER);&#10;&#10;        Label titleLabel = new Label(&quot;Simulation Controls&quot;);&#10;        titleLabel.setFont(Font.font(&quot;Arial&quot;, FontWeight.BOLD, 16));&#10;&#10;        HBox buttonBox = new HBox(10);&#10;        buttonBox.setAlignment(Pos.CENTER);&#10;&#10;        startButton = new Button(&quot;Start&quot;);&#10;        startButton.setOnAction(e -&gt; startSimulation());&#10;&#10;        pauseButton = new Button(&quot;Pause&quot;);&#10;        pauseButton.setOnAction(e -&gt; pauseSimulation());&#10;        pauseButton.setDisable(true);&#10;&#10;        stepButton = new Button(&quot;Step&quot;);&#10;        stepButton.setOnAction(e -&gt; stepSimulation());&#10;&#10;        stopButton = new Button(&quot;Stop&quot;);&#10;        stopButton.setOnAction(e -&gt; stopSimulation());&#10;        stopButton.setDisable(true);&#10;&#10;        resetButton = new Button(&quot;Reset&quot;);&#10;        resetButton.setOnAction(e -&gt; resetSimulation());&#10;&#10;        timeLabel = new Label(&quot;Time: 0.00s&quot;);&#10;        timeLabel.setFont(Font.font(&quot;Arial&quot;, FontWeight.BOLD, 14));&#10;&#10;        buttonBox.getChildren().addAll(startButton, pauseButton, stepButton, stopButton, resetButton, timeLabel);&#10;        controlBox.getChildren().addAll(titleLabel, buttonBox);&#10;&#10;        return controlBox;&#10;    }&#10;&#10;    private VBox createVisualizationPanel() {&#10;        VBox vizBox = new VBox(10);&#10;        vizBox.setPadding(new Insets(10));&#10;        vizBox.setAlignment(Pos.CENTER);&#10;&#10;        Label titleLabel = new Label(&quot;System Visualization&quot;);&#10;        titleLabel.setFont(Font.font(&quot;Arial&quot;, FontWeight.BOLD, 16));&#10;&#10;        canvas = new Canvas(800, 600);&#10;        drawInitialState();&#10;&#10;        vizBox.getChildren().addAll(titleLabel, canvas);&#10;        return vizBox;&#10;    }&#10;&#10;    private VBox createStatsPanel() {&#10;        VBox statsBox = new VBox(10);&#10;        statsBox.setPadding(new Insets(10));&#10;        statsBox.setPrefWidth(350);&#10;&#10;        Label titleLabel = new Label(&quot;Statistics&quot;);&#10;        titleLabel.setFont(Font.font(&quot;Arial&quot;, FontWeight.BOLD, 16));&#10;&#10;        statsArea = new TextArea();&#10;        statsArea.setEditable(false);&#10;        statsArea.setPrefHeight(700);&#10;        statsArea.setFont(Font.font(&quot;Courier New&quot;, 11));&#10;&#10;        statsBox.getChildren().addAll(titleLabel, statsArea);&#10;        return statsBox;&#10;    }&#10;&#10;    private VBox createConfigPanel() {&#10;        VBox configBox = new VBox(10);&#10;        configBox.setPadding(new Insets(10));&#10;&#10;        Label titleLabel = new Label(&quot;Configuration Parameters&quot;);&#10;        titleLabel.setFont(Font.font(&quot;Arial&quot;, FontWeight.BOLD, 14));&#10;&#10;        GridPane grid = new GridPane();&#10;        grid.setHgap(10);&#10;        grid.setVgap(5);&#10;&#10;        int row = 0;&#10;&#10;        // Arrival interval&#10;        grid.add(new Label(&quot;Mean Arrival Interval (s):&quot;), 0, row);&#10;        arrivalIntervalField = new TextField(String.valueOf(controller.getConfig().getMeanArrivalInterval()));&#10;        grid.add(arrivalIntervalField, 1, row++);&#10;&#10;        // CPU nodes&#10;        grid.add(new Label(&quot;CPU Compute Nodes:&quot;), 0, row);&#10;        cpuNodesField = new TextField(String.valueOf(controller.getConfig().getNumCpuNodes()));&#10;        grid.add(cpuNodesField, 1, row++);&#10;&#10;        // GPU nodes&#10;        grid.add(new Label(&quot;GPU Compute Nodes:&quot;), 0, row);&#10;        gpuNodesField = new TextField(String.valueOf(controller.getConfig().getNumGpuNodes()));&#10;        grid.add(gpuNodesField, 1, row++);&#10;&#10;        // Simulation time&#10;        grid.add(new Label(&quot;Simulation Time (s):&quot;), 0, row);&#10;        simulationTimeField = new TextField(String.valueOf(controller.getConfig().getSimulationTime()));&#10;        grid.add(simulationTimeField, 1, row++);&#10;&#10;        // Speed control&#10;        grid.add(new Label(&quot;Simulation Speed:&quot;), 0, row);&#10;        speedSlider = new Slider(0.1, 5.0, 1.0);&#10;        speedSlider.setShowTickLabels(true);&#10;        speedSlider.setShowTickMarks(true);&#10;        speedSlider.setMajorTickUnit(1.0);&#10;        speedSlider.valueProperty().addListener((obs, oldVal, newVal) -&gt; {&#10;            controller.getConfig().setSpeedMultiplier(newVal.doubleValue());&#10;        });&#10;        grid.add(speedSlider, 1, row++);&#10;&#10;        Button applyButton = new Button(&quot;Apply Configuration&quot;);&#10;        applyButton.setOnAction(e -&gt; applyConfiguration());&#10;        grid.add(applyButton, 0, row, 2, 1);&#10;&#10;        configBox.getChildren().addAll(titleLabel, grid);&#10;        return configBox;&#10;    }&#10;&#10;    private void drawInitialState() {&#10;        GraphicsContext gc = canvas.getGraphicsContext2D();&#10;        gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());&#10;        gc.setFill(Color.WHITE);&#10;        gc.fillRect(0, 0, canvas.getWidth(), canvas.getHeight());&#10;&#10;        drawSystemDiagram(gc);&#10;    }&#10;&#10;    private void drawSystemDiagram(GraphicsContext gc) {&#10;        // Draw the system flow diagram&#10;        gc.setStroke(Color.BLACK);&#10;        gc.setLineWidth(2);&#10;&#10;        double startX = 50;&#10;        double startY = 300;&#10;        double spacing = 100;&#10;&#10;        // Draw service points as boxes&#10;        drawServicePoint(gc, startX, startY, &quot;Arrival&quot;, Color.LIGHTGREEN, 0, 0);&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#10;&#10;        startX += spacing;&#10;        drawServicePoint(gc, startX, startY, &quot;Data\nStorage&quot;, Color.LIGHTBLUE, 0, 0);&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#10;&#10;        startX += spacing;&#10;        drawServicePoint(gc, startX, startY, &quot;Classification&quot;, Color.LIGHTYELLOW, 0, 0);&#10;&#10;        // Split into CPU and GPU paths&#10;        double cpuY = startY - 100;&#10;        double gpuY = startY + 100;&#10;&#10;        // CPU path&#10;        drawArrow(gc, startX + 30, startY - 30, startX + 30, cpuY + 30);&#10;        drawServicePoint(gc, startX, cpuY, &quot;CPU\nQueue&quot;, Color.ORANGE, 0, 0);&#10;        drawArrow(gc, startX + 60, cpuY, startX + spacing, cpuY);&#10;&#10;        double cpuComputeX = startX + spacing;&#10;        drawServicePoint(gc, cpuComputeX, cpuY, &quot;CPU\nCompute&quot;, Color.CORAL, 0, 0);&#10;&#10;        // GPU path&#10;        drawArrow(gc, startX + 30, startY + 30, startX + 30, gpuY - 30);&#10;        drawServicePoint(gc, startX, gpuY, &quot;GPU\nQueue&quot;, Color.PINK, 0, 0);&#10;        drawArrow(gc, startX + 60, gpuY, startX + spacing, gpuY);&#10;&#10;        double gpuComputeX = startX + spacing;&#10;        drawServicePoint(gc, gpuComputeX, gpuY, &quot;GPU\nCompute&quot;, Color.PLUM, 0, 0);&#10;&#10;        // Merge to result storage&#10;        double resultX = cpuComputeX + spacing;&#10;        drawArrow(gc, cpuComputeX + 60, cpuY, resultX, startY);&#10;        drawArrow(gc, gpuComputeX + 60, gpuY, resultX, startY);&#10;&#10;        drawServicePoint(gc, resultX, startY, &quot;Result\nStorage&quot;, Color.LIGHTGREEN, 0, 0);&#10;        drawArrow(gc, resultX + 60, startY, resultX + 80, startY);&#10;&#10;        gc.fillText(&quot;Exit&quot;, resultX + 85, startY + 5);&#10;    }&#10;&#10;    private void drawServicePoint(GraphicsContext gc, double x, double y, String name, Color color, int queueLength, int busyServers) {&#10;        // Draw box&#10;        gc.setFill(color);&#10;        gc.fillRect(x, y - 30, 60, 60);&#10;        gc.setStroke(Color.BLACK);&#10;        gc.strokeRect(x, y - 30, 60, 60);&#10;&#10;        // Draw name&#10;        gc.setFill(Color.BLACK);&#10;        gc.setFont(Font.font(&quot;Arial&quot;, 10));&#10;        String[] lines = name.split(&quot;\n&quot;);&#10;        for (int i = 0; i &lt; lines.length; i++) {&#10;            gc.fillText(lines[i], x + 5, y - 10 + i * 12);&#10;        }&#10;&#10;        // Draw queue length if &gt; 0&#10;        if (queueLength &gt; 0) {&#10;            gc.setFill(Color.RED);&#10;            gc.fillText(&quot;Q:&quot; + queueLength, x + 5, y + 20);&#10;        }&#10;    }&#10;&#10;    private void drawArrow(GraphicsContext gc, double x1, double y1, double x2, double y2) {&#10;        gc.strokeLine(x1, y1, x2, y2);&#10;&#10;        // Draw arrowhead&#10;        double angle = Math.atan2(y2 - y1, x2 - x1);&#10;        double arrowLength = 10;&#10;        double arrowAngle = Math.PI / 6;&#10;&#10;        double x3 = x2 - arrowLength * Math.cos(angle - arrowAngle);&#10;        double y3 = y2 - arrowLength * Math.sin(angle - arrowAngle);&#10;        double x4 = x2 - arrowLength * Math.cos(angle + arrowAngle);&#10;        double y4 = y2 - arrowLength * Math.sin(angle + arrowAngle);&#10;&#10;        gc.strokeLine(x2, y2, x3, y3);&#10;        gc.strokeLine(x2, y2, x4, y4);&#10;    }&#10;&#10;    private void updateVisualization() {&#10;        if (controller.getEngine() == null) return;&#10;&#10;        GraphicsContext gc = canvas.getGraphicsContext2D();&#10;        gc.clearRect(0, 0, canvas.getWidth(), canvas.getHeight());&#10;        gc.setFill(Color.WHITE);&#10;        gc.fillRect(0, 0, canvas.getWidth(), canvas.getHeight());&#10;&#10;        // Redraw with current state&#10;        SimulationEngine engine = controller.getEngine();&#10;        drawSystemWithState(gc, engine);&#10;    }&#10;&#10;    private void drawSystemWithState(GraphicsContext gc, SimulationEngine engine) {&#10;        gc.setStroke(Color.BLACK);&#10;        gc.setLineWidth(2);&#10;&#10;        double startX = 50;&#10;        double startY = 300;&#10;        double spacing = 100;&#10;&#10;        // Draw service points with current state&#10;        drawServicePoint(gc, startX, startY, &quot;Arrival&quot;, Color.LIGHTGREEN, 0, 0);&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#10;&#10;        startX += spacing;&#10;        ServicePoint dataStorage = engine.getDataStorage();&#10;        drawServicePoint(gc, startX, startY, &quot;Data\nStorage&quot;, Color.LIGHTBLUE,&#10;            dataStorage.getQueueLength(), dataStorage.getBusyServers());&#10;        drawArrow(gc, startX + 60, startY, startX + spacing, startY);&#10;&#10;        startX += spacing;&#10;        ServicePoint classification = engine.getClassification();&#10;        drawServicePoint(gc, startX, startY, &quot;Classification&quot;, Color.LIGHTYELLOW,&#10;            classification.getQueueLength(), classification.getBusyServers());&#10;&#10;        // CPU and GPU paths - compute service points now include their own queues&#10;        double cpuY = startY - 100;&#10;        double gpuY = startY + 100;&#10;&#10;        drawArrow(gc, startX + 30, startY - 30, startX + 30, cpuY + 30);&#10;        double cpuComputeX = startX;&#10;        ServicePoint cpuCompute = engine.getCpuCompute();&#10;        drawServicePoint(gc, cpuComputeX, cpuY, &quot;CPU\nCompute&quot;, Color.CORAL,&#10;            cpuCompute.getQueueLength(), cpuCompute.getBusyServers());&#10;&#10;        drawArrow(gc, startX + 30, startY + 30, startX + 30, gpuY - 30);&#10;        double gpuComputeX = startX;&#10;        ServicePoint gpuCompute = engine.getGpuCompute();&#10;        drawServicePoint(gc, gpuComputeX, gpuY, &quot;GPU\nCompute&quot;, Color.PLUM,&#10;            gpuCompute.getQueueLength(), gpuCompute.getBusyServers());&#10;&#10;        double resultX = cpuComputeX + spacing;&#10;        drawArrow(gc, cpuComputeX + 60, cpuY, resultX, startY);&#10;        drawArrow(gc, gpuComputeX + 60, gpuY, resultX, startY);&#10;&#10;        ServicePoint resultStorage = engine.getResultStorage();&#10;        drawServicePoint(gc, resultX, startY, &quot;Result\nStorage&quot;, Color.LIGHTGREEN,&#10;            resultStorage.getQueueLength(), resultStorage.getBusyServers());&#10;        drawArrow(gc, resultX + 60, startY, resultX + 80, startY);&#10;&#10;        gc.fillText(&quot;Exit&quot;, resultX + 85, startY + 5);&#10;    }&#10;&#10;    private void updateStatistics() {&#10;        if (controller.getEngine() == null) return;&#10;&#10;        SimulationEngine engine = controller.getEngine();&#10;        SimulationResults results = engine.getResults();&#10;&#10;        StringBuilder stats = new StringBuilder();&#10;        stats.append(&quot;=== SIMULATION STATISTICS ===\n\n&quot;);&#10;&#10;        stats.append(&quot;Current Time: &quot;).append(String.format(&quot;%.2f&quot;, controller.getCurrentTime())).append(&quot; s\n\n&quot;);&#10;&#10;        stats.append(&quot;--- Task Statistics ---\n&quot;);&#10;        stats.append(&quot;Tasks Arrived: &quot;).append(results.getTotalTasksArrived()).append(&quot;\n&quot;);&#10;        stats.append(&quot;Tasks Completed: &quot;).append(results.getTotalTasksCompleted()).append(&quot;\n&quot;);&#10;        stats.append(&quot;CPU Tasks: &quot;).append(results.getCpuTasksCompleted()).append(&quot;\n&quot;);&#10;        stats.append(&quot;GPU Tasks: &quot;).append(results.getGpuTasksCompleted()).append(&quot;\n\n&quot;);&#10;&#10;        stats.append(&quot;--- User Type Statistics ---\n&quot;);&#10;        stats.append(&quot;Normal Users: &quot;).append(results.getNormalUserTasksCompleted()).append(&quot;\n&quot;);&#10;        stats.append(&quot;Personal VIP: &quot;).append(results.getPersonalVipTasksCompleted()).append(&quot;\n&quot;);&#10;        stats.append(&quot;Enterprise VIP: &quot;).append(results.getEnterpriseVipTasksCompleted()).append(&quot;\n\n&quot;);&#10;&#10;        stats.append(&quot;--- Performance Metrics ---\n&quot;);&#10;        stats.append(&quot;Avg System Time: &quot;).append(String.format(&quot;%.2f&quot;, results.getAverageSystemTime())).append(&quot; s\n&quot;);&#10;        stats.append(&quot;Min System Time: &quot;).append(String.format(&quot;%.2f&quot;, results.getMinSystemTime())).append(&quot; s\n&quot;);&#10;        stats.append(&quot;Max System Time: &quot;).append(String.format(&quot;%.2f&quot;, results.getMaxSystemTime())).append(&quot; s\n&quot;);&#10;        stats.append(&quot;Throughput: &quot;).append(String.format(&quot;%.4f&quot;, results.getThroughput(controller.getCurrentTime()))).append(&quot; tasks/s\n\n&quot;);&#10;&#10;        stats.append(&quot;--- Service Point Statistics ---\n&quot;);&#10;        addServicePointStats(stats, &quot;Data Storage&quot;, engine.getDataStorage());&#10;        addServicePointStats(stats, &quot;Classification&quot;, engine.getClassification());&#10;        addServicePointStats(stats, &quot;CPU Compute&quot;, engine.getCpuCompute());&#10;        addServicePointStats(stats, &quot;GPU Compute&quot;, engine.getGpuCompute());&#10;        addServicePointStats(stats, &quot;Result Storage&quot;, engine.getResultStorage());&#10;&#10;        statsArea.setText(stats.toString());&#10;    }&#10;&#10;    private void addServicePointStats(StringBuilder stats, String name, ServicePoint sp) {&#10;        stats.append(name).append(&quot;:\n&quot;);&#10;        stats.append(&quot;  Queue Length: &quot;).append(sp.getQueueLength()).append(&quot;\n&quot;);&#10;        stats.append(&quot;  Max Queue: &quot;).append(sp.getMaxQueueLength()).append(&quot;\n&quot;);&#10;        stats.append(&quot;  Tasks Served: &quot;).append(sp.getTasksServed()).append(&quot;\n&quot;);&#10;        stats.append(&quot;  Avg Queue Time: &quot;).append(String.format(&quot;%.2f&quot;, sp.getAverageQueueTime())).append(&quot; s\n&quot;);&#10;        stats.append(&quot;  Utilization: &quot;).append(String.format(&quot;%.2f%%&quot;, sp.getUtilization(controller.getCurrentTime()) * 100)).append(&quot;\n\n&quot;);&#10;    }&#10;&#10;    private void updateSimulationListener() {&#10;        controller.setSimulationListener(new SimulationEngine.SimulationListener() {&#10;            @Override&#10;            public void onTimeUpdate(double time) {&#10;                Platform.runLater(() -&gt; {&#10;                    timeLabel.setText(String.format(&quot;Time: %.2fs&quot;, time));&#10;                    updateVisualization();&#10;                    updateStatistics();&#10;                });&#10;            }&#10;&#10;            @Override&#10;            public void onSimulationComplete() {&#10;                Platform.runLater(() -&gt; {&#10;                    updateVisualization();&#10;                    updateStatistics();&#10;                    startButton.setDisable(true);&#10;                    pauseButton.setDisable(true);&#10;                    stepButton.setDisable(true);&#10;                    stopButton.setDisable(true);&#10;&#10;                    Alert alert = new Alert(Alert.AlertType.INFORMATION);&#10;                    alert.setTitle(&quot;Simulation Complete&quot;);&#10;                    alert.setHeaderText(&quot;Simulation has finished&quot;);&#10;                    alert.setContentText(&quot;The simulation has completed. Check the statistics for results.&quot;);&#10;                    alert.showAndWait();&#10;                });&#10;            }&#10;        });&#10;    }&#10;&#10;    private void startSimulation() {&#10;        applyConfiguration();&#10;        controller.initializeSimulation();&#10;        updateSimulationListener();&#10;        controller.startSimulation();&#10;&#10;        startButton.setDisable(true);&#10;        pauseButton.setDisable(false);&#10;        stopButton.setDisable(false);&#10;    }&#10;&#10;    private void pauseSimulation() {&#10;        if (controller.getEngine().isPaused()) {&#10;            controller.resumeSimulation();&#10;            pauseButton.setText(&quot;Pause&quot;);&#10;        } else {&#10;            controller.pauseSimulation();&#10;            pauseButton.setText(&quot;Resume&quot;);&#10;        }&#10;    }&#10;&#10;    private void stepSimulation() {&#10;        controller.stepSimulation();&#10;    }&#10;&#10;    private void stopSimulation() {&#10;        controller.stopSimulation();&#10;        startButton.setDisable(false);&#10;        pauseButton.setDisable(true);&#10;        stopButton.setDisable(true);&#10;    }&#10;&#10;    private void resetSimulation() {&#10;        controller.stopSimulation();&#10;        controller.initializeSimulation();&#10;        updateSimulationListener();&#10;&#10;        timeLabel.setText(&quot;Time: 0.00s&quot;);&#10;        drawInitialState();&#10;        statsArea.clear();&#10;&#10;        startButton.setDisable(false);&#10;        pauseButton.setDisable(true);&#10;        pauseButton.setText(&quot;Pause&quot;);&#10;        stepButton.setDisable(false);&#10;        stopButton.setDisable(true);&#10;    }&#10;&#10;    private void applyConfiguration() {&#10;        try {&#10;            SimulationConfig config = controller.getConfig();&#10;            config.setMeanArrivalInterval(Double.parseDouble(arrivalIntervalField.getText()));&#10;            config.setNumCpuNodes(Integer.parseInt(cpuNodesField.getText()));&#10;            config.setNumGpuNodes(Integer.parseInt(gpuNodesField.getText()));&#10;            config.setSimulationTime(Double.parseDouble(simulationTimeField.getText()));&#10;        } catch (NumberFormatException e) {&#10;            Alert alert = new Alert(Alert.AlertType.ERROR);&#10;            alert.setTitle(&quot;Invalid Input&quot;);&#10;            alert.setHeaderText(&quot;Configuration Error&quot;);&#10;            alert.setContentText(&quot;Please enter valid numbers for all configuration fields.&quot;);&#10;            alert.showAndWait();&#10;        }&#10;    }&#10;}&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>