<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/simulation/model/SimulationEngine.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/simulation/model/SimulationEngine.java" />
              <option name="originalContent" value="package com.simulation.model;&#10;import com.simulation.util.RandomGenerator;&#10;&#10;/**&#10; * Core discrete-event simulation engine for cloud computing service queue simulation.&#10; * &#10; * &lt;p&gt;This class extends {@link Thread} and implements a discrete-event simulation (DES)&#10; * engine that models a cloud computing service provider. The simulation processes tasks&#10; * through a series of service points:&#10; * &lt;ol&gt;&#10; *   &lt;li&gt;Data Storage&lt;/li&gt;&#10; *   &lt;li&gt;Classification&lt;/li&gt;&#10; *   &lt;li&gt;CPU/GPU Queue&lt;/li&gt;&#10; *   &lt;li&gt;CPU/GPU Compute&lt;/li&gt;&#10; *   &lt;li&gt;Result Storage&lt;/li&gt;&#10; * &lt;/ol&gt;&#10; * &#10; * &lt;p&gt;The engine uses an event-driven approach where events are scheduled and processed&#10; * in chronological order. Tasks flow through the system based on their type (CPU/GPU)&#10; * and user priority (Normal/Personal VIP/Enterprise VIP).&#10; * &#10; * &lt;p&gt;Thread Safety: This class is thread-safe for concurrent access from UI thread.&#10; * The simulation runs in its own thread and uses synchronized methods in ServicePoint&#10; * and SimulationResults for thread-safe data access.&#10; * &#10; * @author Cloud Simulation Team&#10; * @version 2.0&#10; * @see SimulationConfig&#10; * @see SimulationResults&#10; * @see ServicePoint&#10; * @see Task&#10; * @see Event&#10; */&#10;public class SimulationEngine extends Thread {&#10;    private final SimulationConfig config;&#10;    private final SimulationResults results;&#10;    private final EventList eventList;&#10;    private final Clock clock;&#10;    private ServicePoint dataStorage, classification, cpuQueue, gpuQueue, cpuCompute, gpuCompute, resultStorage;&#10;    private volatile boolean running, paused;&#10;    private volatile double speedMultiplier = 1.0;&#10;    private final Object pauseLock = new Object();&#10;    private SimulationListener listener;&#10;    /**&#10;     * Listener interface for simulation events.&#10;     * &#10;     * &lt;p&gt;Implementations of this interface receive notifications when simulation&#10;     * time updates or when the simulation completes. Used to update UI components&#10;     * in real-time during simulation execution.&#10;     * &#10;     * @since 2.0&#10;     */&#10;    public interface SimulationListener {&#10;        /**&#10;         * Called when simulation time advances.&#10;         * &#10;         * @param time the current simulation time&#10;         */&#10;        void onTimeUpdate(double time);&#10;        &#10;        /**&#10;         * Called when simulation completes normally or is stopped.&#10;         */&#10;        void onSimulationComplete();&#10;        &#10;        /**&#10;         * Default implementation that calls onTimeUpdate with current clock time.&#10;         */&#10;        default void onSimulationUpdate() {&#10;            onTimeUpdate(Clock.getInstance().getTime());&#10;        }&#10;    }&#10;    /**&#10;     * Constructs a new SimulationEngine with the given configuration.&#10;     * &#10;     * @param config the simulation configuration parameters&#10;     * @throws NullPointerException if config is null&#10;     */&#10;    public SimulationEngine(SimulationConfig config) {&#10;        this.config = config;&#10;        this.results = new SimulationResults();&#10;        this.eventList = new EventList();&#10;        this.clock = Clock.getInstance();&#10;        initializeServicePoints();&#10;    }&#10;    private void initializeServicePoints() {&#10;        dataStorage = new ServicePoint(&quot;Data Storage&quot;, 1, config.getDataStorageServiceTime(), false);&#10;        classification = new ServicePoint(&quot;Classification&quot;, 1, config.getClassificationServiceTime(), false);&#10;        cpuQueue = new ServicePoint(&quot;CPU Queue&quot;, Integer.MAX_VALUE, 0, true);&#10;        gpuQueue = new ServicePoint(&quot;GPU Queue&quot;, Integer.MAX_VALUE, 0, true);&#10;        cpuCompute = new ServicePoint(&quot;CPU Compute&quot;, config.getNumCpuNodes(), config.getCpuComputeServiceTime(), false);&#10;        gpuCompute = new ServicePoint(&quot;GPU Compute&quot;, config.getNumGpuNodes(), config.getGpuComputeServiceTime(), false);&#10;        resultStorage = new ServicePoint(&quot;Result Storage&quot;, 1, config.getResultStorageServiceTime(), false);&#10;    }&#10;    /**&#10;     * Sets the listener for simulation events.&#10;     * &#10;     * @param listener the listener to receive simulation updates, or null to remove listener&#10;     */&#10;    public void setListener(SimulationListener listener) {&#10;        this.listener = listener;&#10;    }&#10;    &#10;    /**&#10;     * Sets the simulation speed multiplier.&#10;     * &#10;     * &lt;p&gt;The speed multiplier controls how fast simulation time advances relative&#10;     * to real time. A value of 1.0 means 1 simulation second = 1 real second.&#10;     * A value of 2.0 means simulation runs twice as fast.&#10;     * &#10;     * @param speed the speed multiplier (clamped between 0.1 and 100.0)&#10;     */&#10;    public void setSpeed(double speed) {&#10;        this.speedMultiplier = Math.max(0.1, Math.min(100.0, speed));&#10;    }&#10;    &#10;    /**&#10;     * Initializes the simulation engine.&#10;     * &#10;     * &lt;p&gt;This method resets the clock, clears all events, resets statistics,&#10;     * and schedules the first arrival event. Must be called before starting&#10;     * the simulation.&#10;     */&#10;    public void initialize() {&#10;        clock.reset();&#10;        eventList.clear();&#10;        results.reset();&#10;        dataStorage.reset();&#10;        classification.reset();&#10;        cpuCompute.reset();&#10;        gpuCompute.reset();&#10;        resultStorage.reset();&#10;        scheduleNextArrival();&#10;    }&#10;    private void scheduleNextArrival() {&#10;        double arrivalTime = clock.getTime() + RandomGenerator.exponential(config.getMeanArrivalInterval());&#10;        if (arrivalTime &lt;= config.getSimulationTime()) {&#10;            TaskType taskType = RandomGenerator.bernoulli(config.getCpuTaskProbability()) ? TaskType.CPU : TaskType.GPU;&#10;            UserType userType = generateUserType();&#10;            Task task = new Task(taskType, userType, arrivalTime);&#10;            eventList.addEvent(new Event(EventType.ARRIVAL, arrivalTime, task));&#10;        }&#10;    }&#10;    private UserType generateUserType() {&#10;        double rand = Math.random();&#10;        if (rand &lt; config.getNormalUserProbability()) return UserType.NORMAL;&#10;        else if (rand &lt; config.getNormalUserProbability() + config.getPersonalVipProbability()) return UserType.PERSONAL_VIP;&#10;        else return UserType.ENTERPRISE_VIP;&#10;    }&#10;    @Override&#10;    public void run() {&#10;        running = true;&#10;        double previousTime = 0.0;&#10;&#10;        while (running &amp;&amp; eventList.hasEvents() &amp;&amp; clock.getTime() &lt;= config.getSimulationTime()) {&#10;            synchronized (pauseLock) {&#10;                while (paused &amp;&amp; running) {&#10;                    try { pauseLock.wait(); } catch (InterruptedException e) { return; }&#10;                }&#10;            }&#10;            if (!running) break;&#10;            Event event = eventList.getNextEvent();&#10;            if (event != null) {&#10;                double targetTime = event.getTime();&#10;                double timeElapsed = targetTime - previousTime;&#10;&#10;                // Sleep proportional to simulated time elapsed, but break into small chunks&#10;                // for smooth time display updates&#10;                // At 1x speed: 1 simulated second = 1 real second (1000ms)&#10;                // At 2x speed: 1 simulated second = 0.5 real seconds (500ms)&#10;                if (timeElapsed &gt; 0) {&#10;                    // Capture current speed to avoid inconsistency if slider is adjusted during sleep&#10;                    double currentSpeed = speedMultiplier;&#10;                    long totalSleepTime = (long)(timeElapsed * 1000.0 / currentSpeed);&#10;                    long sleepChunk = 50; // Update UI every 50ms for smooth display&#10;                    long initialSleepTime = totalSleepTime;&#10;&#10;                    // Break the sleep into small chunks and update time progressively&#10;                    while (totalSleepTime &gt; 0 &amp;&amp; running &amp;&amp; !paused) {&#10;                        long currentSleep = Math.min(sleepChunk, totalSleepTime);&#10;                        try {&#10;                            Thread.sleep(currentSleep);&#10;                        } catch (InterruptedException e) {&#10;                            return;&#10;                        }&#10;&#10;                        // Update clock progressively for smooth display&#10;                        // Use initial sleep time to calculate consistent progress&#10;                        double progress = (double)(initialSleepTime - totalSleepTime + currentSleep) / initialSleepTime;&#10;                        double intermediateTime = previousTime + (timeElapsed * progress);&#10;                        clock.setTime(intermediateTime);&#10;&#10;                        if (listener != null) listener.onTimeUpdate(clock.getTime());&#10;&#10;                        totalSleepTime -= currentSleep;&#10;                    }&#10;                }&#10;&#10;                clock.setTime(targetTime);&#10;                processEvent(event);&#10;                previousTime = targetTime;&#10;&#10;                if (listener != null) listener.onTimeUpdate(clock.getTime());&#10;            }&#10;        }&#10;        running = false;&#10;        results.setTotalSimulationTime(clock.getTime());&#10;        if (listener != null) listener.onSimulationComplete();&#10;    }&#10;    private void processEvent(Event event) {&#10;        Task task = event.getTask();&#10;        switch (event.getType()) {&#10;            case ARRIVAL: handleArrival(task); break;&#10;            case DEP_DATA_STORAGE: handleDepartureDataStorage(task); break;&#10;            case DEP_CLASSIFICATION: handleDepartureClassification(task); break;&#10;            case DEP_CPU_COMPUTE: handleDepartureCpuCompute(task); break;&#10;            case DEP_GPU_COMPUTE: handleDepartureGpuCompute(task); break;&#10;            case DEP_RESULT_STORAGE: handleDepartureResultStorage(task); break;&#10;        }&#10;    }&#10;    private void handleArrival(Task task) {&#10;        results.recordArrival();&#10;        dataStorage.addToQueue(task);&#10;        if (dataStorage.isAvailable()) startServiceDataStorage();&#10;        scheduleNextArrival();&#10;    }&#10;    private void startServiceDataStorage() {&#10;        Task task = dataStorage.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = dataStorage.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_DATA_STORAGE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureDataStorage(Task task) {&#10;        dataStorage.endService(clock.getTime());&#10;        classification.addToQueue(task);&#10;        if (classification.isAvailable()) startServiceClassification();&#10;        if (dataStorage.isAvailable() &amp;&amp; !dataStorage.isQueueEmpty()) startServiceDataStorage();&#10;    }&#10;    private void startServiceClassification() {&#10;        Task task = classification.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = classification.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_CLASSIFICATION, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureClassification(Task task) {&#10;        classification.endService(clock.getTime());&#10;        // Add task directly to CPU/GPU compute service point (which now has its own queue)&#10;        if (task.getTaskType() == TaskType.CPU) {&#10;            cpuCompute.addToQueue(task);&#10;            if (cpuCompute.isAvailable()) startServiceCpuCompute();&#10;        } else {&#10;            gpuCompute.addToQueue(task);&#10;            if (gpuCompute.isAvailable()) startServiceGpuCompute();&#10;        }&#10;        if (classification.isAvailable() &amp;&amp; !classification.isQueueEmpty()) startServiceClassification();&#10;    }&#10;&#10;    private void startServiceCpuCompute() {&#10;        Task task = cpuCompute.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = cpuCompute.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_CPU_COMPUTE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;&#10;    private void startServiceGpuCompute() {&#10;        Task task = gpuCompute.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = gpuCompute.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_GPU_COMPUTE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;&#10;    private void handleDepartureCpuCompute(Task task) {&#10;        cpuCompute.endService(clock.getTime());&#10;        resultStorage.addToQueue(task);&#10;        if (resultStorage.isAvailable()) startServiceResultStorage();&#10;        if (cpuCompute.isAvailable() &amp;&amp; !cpuCompute.isQueueEmpty()) startServiceCpuCompute();&#10;    }&#10;&#10;    private void handleDepartureGpuCompute(Task task) {&#10;        gpuCompute.endService(clock.getTime());&#10;        resultStorage.addToQueue(task);&#10;        if (resultStorage.isAvailable()) startServiceResultStorage();&#10;        if (gpuCompute.isAvailable() &amp;&amp; !gpuCompute.isQueueEmpty()) startServiceGpuCompute();&#10;    }&#10;    private void startServiceResultStorage() {&#10;        Task task = resultStorage.beginService(clock.getTime());&#10;        if (task != null) {&#10;            double serviceTime = resultStorage.getServiceTime();&#10;            eventList.addEvent(new Event(EventType.DEP_RESULT_STORAGE, clock.getTime() + serviceTime, task));&#10;        }&#10;    }&#10;    private void handleDepartureResultStorage(Task task) {&#10;        resultStorage.endService(clock.getTime());&#10;        task.setCompletionTime(clock.getTime());&#10;        results.recordCompletion(task);&#10;        if (resultStorage.isAvailable() &amp;&amp; !resultStorage.isQueueEmpty()) startServiceResultStorage();&#10;    }&#10;    /**&#10;     * Checks if the simulation is currently running.&#10;     * &#10;     * @return true if simulation is running, false otherwise&#10;     */&#10;    public boolean isRunning() {&#10;        return running;&#10;    }&#10;&#10;    /**&#10;     * Checks if the simulation is currently paused.&#10;     * &#10;     * @return true if simulation is paused, false otherwise&#10;     */&#10;    public boolean isPaused() {&#10;        return paused;&#10;    }&#10;&#10;    /**&#10;     * Pauses the simulation execution.&#10;     * &#10;     * &lt;p&gt;The simulation thread will wait until {@link #resumeSimulation()} is called.&#10;     */&#10;    public void pauseSimulation() {&#10;        paused = true;&#10;    }&#10;&#10;    /**&#10;     * Resumes a paused simulation.&#10;     * &#10;     * &lt;p&gt;This method wakes up the simulation thread if it's waiting due to pause.&#10;     */&#10;    public void resumeSimulation() {&#10;        synchronized (pauseLock) {&#10;            paused = false;&#10;            pauseLock.notifyAll();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Stops the simulation execution.&#10;     * &#10;     * &lt;p&gt;The simulation will finish processing the current event and then stop.&#10;     * The thread will exit after completing current operations.&#10;     */&#10;    public void stopSimulation() {&#10;        running = false;&#10;        synchronized (pauseLock) {&#10;            pauseLock.notifyAll();&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Executes a single simulation step when paused.&#10;     * &#10;     * &lt;p&gt;This method processes the next event in the queue. Only works when&#10;     * simulation is paused. Useful for debugging or step-by-step execution.&#10;     */&#10;    public void stepForward() {&#10;        if (paused &amp;&amp; eventList.hasEvents()) {&#10;            Event event = eventList.getNextEvent();&#10;            if (event != null) {&#10;                clock.setTime(event.getTime());&#10;                processEvent(event);&#10;                if (listener != null) listener.onTimeUpdate(clock.getTime());&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Gets the simulation results.&#10;     * &#10;     * @return the SimulationResults object containing all statistics&#10;     */&#10;    public SimulationResults getResults() {&#10;        return results;&#10;    }&#10;    &#10;    /**&#10;     * Gets the Data Storage service point.&#10;     * &#10;     * @return the Data Storage ServicePoint&#10;     */&#10;    public ServicePoint getDataStorage() { return dataStorage; }&#10;    &#10;    /**&#10;     * Gets the Classification service point.&#10;     * &#10;     * @return the Classification ServicePoint&#10;     */&#10;    public ServicePoint getClassification() { return classification; }&#10;    &#10;    /**&#10;     * Gets the CPU Compute service point.&#10;     * &#10;     * @return the CPU Compute ServicePoint&#10;     */&#10;    public ServicePoint getCpuCompute() { return cpuCompute; }&#10;    &#10;    /**&#10;     * Gets the GPU Compute service point.&#10;     * &#10;     * @return the GPU Compute ServicePoint&#10;     */&#10;    public ServicePoint getGpuCompute() { return gpuCompute; }&#10;    &#10;    /**&#10;     * Gets the Result Storage service point.&#10;     * &#10;     * @return the Result Storage ServicePoint&#10;     */&#10;    public ServicePoint getResultStorage() { return resultStorage; }&#10;}&#10;" />
              <option name="updatedContent" value="package com.simulation.model;&#13;&#10;import com.simulation.util.RandomGenerator;&#13;&#10;&#13;&#10;/**&#13;&#10; * Core discrete-event simulation engine for cloud computing service queue simulation.&#13;&#10; * &#13;&#10; * &lt;p&gt;This class extends {@link Thread} and implements a discrete-event simulation (DES)&#13;&#10; * engine that models a cloud computing service provider. The simulation processes tasks&#13;&#10; * through a series of service points:&#13;&#10; * &lt;ol&gt;&#13;&#10; *   &lt;li&gt;Data Storage&lt;/li&gt;&#13;&#10; *   &lt;li&gt;Classification&lt;/li&gt;&#13;&#10; *   &lt;li&gt;CPU/GPU Queue&lt;/li&gt;&#13;&#10; *   &lt;li&gt;CPU/GPU Compute&lt;/li&gt;&#13;&#10; *   &lt;li&gt;Result Storage&lt;/li&gt;&#13;&#10; * &lt;/ol&gt;&#13;&#10; * &#13;&#10; * &lt;p&gt;The engine uses an event-driven approach where events are scheduled and processed&#13;&#10; * in chronological order. Tasks flow through the system based on their type (CPU/GPU)&#13;&#10; * and user priority (Normal/Personal VIP/Enterprise VIP).&#13;&#10; * &#13;&#10; * &lt;p&gt;Thread Safety: This class is thread-safe for concurrent access from UI thread.&#13;&#10; * The simulation runs in its own thread and uses synchronized methods in ServicePoint&#13;&#10; * and SimulationResults for thread-safe data access.&#13;&#10; * &#13;&#10; * @author Cloud Simulation Team&#13;&#10; * @version 2.0&#13;&#10; * @see SimulationConfig&#13;&#10; * @see SimulationResults&#13;&#10; * @see ServicePoint&#13;&#10; * @see Task&#13;&#10; * @see Event&#13;&#10; */&#13;&#10;public class SimulationEngine extends Thread {&#13;&#10;    private final SimulationConfig config;&#13;&#10;    private final SimulationResults results;&#13;&#10;    private final EventList eventList;&#13;&#10;    private final Clock clock;&#13;&#10;    private ServicePoint dataStorage, classification, cpuQueue, gpuQueue, cpuCompute, gpuCompute, resultStorage;&#13;&#10;    private volatile boolean running, paused;&#13;&#10;    private volatile double speedMultiplier = 1.0;&#13;&#10;    private final Object pauseLock = new Object();&#13;&#10;    private SimulationListener listener;&#13;&#10;    /**&#13;&#10;     * Listener interface for simulation events.&#13;&#10;     * &#13;&#10;     * &lt;p&gt;Implementations of this interface receive notifications when simulation&#13;&#10;     * time updates or when the simulation completes. Used to update UI components&#13;&#10;     * in real-time during simulation execution.&#13;&#10;     * &#13;&#10;     * @since 2.0&#13;&#10;     */&#13;&#10;    public interface SimulationListener {&#13;&#10;        /**&#13;&#10;         * Called when simulation time advances.&#13;&#10;         * &#13;&#10;         * @param time the current simulation time&#13;&#10;         */&#13;&#10;        void onTimeUpdate(double time);&#13;&#10;        &#13;&#10;        /**&#13;&#10;         * Called when simulation completes normally or is stopped.&#13;&#10;         */&#13;&#10;        void onSimulationComplete();&#13;&#10;        &#13;&#10;        /**&#13;&#10;         * Default implementation that calls onTimeUpdate with current clock time.&#13;&#10;         */&#13;&#10;        default void onSimulationUpdate() {&#13;&#10;            onTimeUpdate(Clock.getInstance().getTime());&#13;&#10;        }&#13;&#10;    }&#13;&#10;    /**&#13;&#10;     * Constructs a new SimulationEngine with the given configuration.&#13;&#10;     * &#13;&#10;     * @param config the simulation configuration parameters&#13;&#10;     * @throws NullPointerException if config is null&#13;&#10;     */&#13;&#10;    public SimulationEngine(SimulationConfig config) {&#13;&#10;        this.config = config;&#13;&#10;        this.results = new SimulationResults();&#13;&#10;        this.eventList = new EventList();&#13;&#10;        this.clock = Clock.getInstance();&#13;&#10;        initializeServicePoints();&#13;&#10;    }&#13;&#10;    private void initializeServicePoints() {&#10;        dataStorage = new ServicePoint(&quot;Data Storage&quot;, 1, config.getDataStorageServiceTime(), true);&#10;        classification = new ServicePoint(&quot;Classification&quot;, 1, config.getClassificationServiceTime(), true);&#10;        cpuQueue = new ServicePoint(&quot;CPU Queue&quot;, Integer.MAX_VALUE, 0, true);&#10;        gpuQueue = new ServicePoint(&quot;GPU Queue&quot;, Integer.MAX_VALUE, 0, true);&#10;        cpuCompute = new ServicePoint(&quot;CPU Compute&quot;, config.getNumCpuNodes(), config.getCpuComputeServiceTime(), true);&#10;        gpuCompute = new ServicePoint(&quot;GPU Compute&quot;, config.getNumGpuNodes(), config.getGpuComputeServiceTime(), true);&#10;        resultStorage = new ServicePoint(&quot;Result Storage&quot;, 1, config.getResultStorageServiceTime(), true);&#10;    }&#13;&#10;    /**&#13;&#10;     * Sets the listener for simulation events.&#13;&#10;     * &#13;&#10;     * @param listener the listener to receive simulation updates, or null to remove listener&#13;&#10;     */&#13;&#10;    public void setListener(SimulationListener listener) {&#13;&#10;        this.listener = listener;&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Sets the simulation speed multiplier.&#13;&#10;     * &#13;&#10;     * &lt;p&gt;The speed multiplier controls how fast simulation time advances relative&#13;&#10;     * to real time. A value of 1.0 means 1 simulation second = 1 real second.&#13;&#10;     * A value of 2.0 means simulation runs twice as fast.&#13;&#10;     * &#13;&#10;     * @param speed the speed multiplier (clamped between 0.1 and 100.0)&#13;&#10;     */&#13;&#10;    public void setSpeed(double speed) {&#13;&#10;        this.speedMultiplier = Math.max(0.1, Math.min(100.0, speed));&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Initializes the simulation engine.&#13;&#10;     * &#13;&#10;     * &lt;p&gt;This method resets the clock, clears all events, resets statistics,&#13;&#10;     * and schedules the first arrival event. Must be called before starting&#13;&#10;     * the simulation.&#13;&#10;     */&#13;&#10;    public void initialize() {&#13;&#10;        clock.reset();&#13;&#10;        eventList.clear();&#13;&#10;        results.reset();&#13;&#10;        dataStorage.reset();&#13;&#10;        classification.reset();&#13;&#10;        cpuCompute.reset();&#13;&#10;        gpuCompute.reset();&#13;&#10;        resultStorage.reset();&#13;&#10;        scheduleNextArrival();&#13;&#10;    }&#13;&#10;    private void scheduleNextArrival() {&#13;&#10;        double arrivalTime = clock.getTime() + RandomGenerator.exponential(config.getMeanArrivalInterval());&#13;&#10;        if (arrivalTime &lt;= config.getSimulationTime()) {&#13;&#10;            TaskType taskType = RandomGenerator.bernoulli(config.getCpuTaskProbability()) ? TaskType.CPU : TaskType.GPU;&#13;&#10;            UserType userType = generateUserType();&#13;&#10;            Task task = new Task(taskType, userType, arrivalTime);&#13;&#10;            eventList.addEvent(new Event(EventType.ARRIVAL, arrivalTime, task));&#13;&#10;        }&#13;&#10;    }&#13;&#10;    private UserType generateUserType() {&#13;&#10;        double rand = Math.random();&#13;&#10;        if (rand &lt; config.getNormalUserProbability()) return UserType.NORMAL;&#13;&#10;        else if (rand &lt; config.getNormalUserProbability() + config.getPersonalVipProbability()) return UserType.PERSONAL_VIP;&#13;&#10;        else return UserType.ENTERPRISE_VIP;&#13;&#10;    }&#13;&#10;    @Override&#13;&#10;    public void run() {&#13;&#10;        running = true;&#13;&#10;        double previousTime = 0.0;&#13;&#10;&#13;&#10;        while (running &amp;&amp; eventList.hasEvents() &amp;&amp; clock.getTime() &lt;= config.getSimulationTime()) {&#13;&#10;            synchronized (pauseLock) {&#13;&#10;                while (paused &amp;&amp; running) {&#13;&#10;                    try { pauseLock.wait(); } catch (InterruptedException e) { return; }&#13;&#10;                }&#13;&#10;            }&#13;&#10;            if (!running) break;&#13;&#10;            Event event = eventList.getNextEvent();&#13;&#10;            if (event != null) {&#13;&#10;                double targetTime = event.getTime();&#13;&#10;                double timeElapsed = targetTime - previousTime;&#13;&#10;&#13;&#10;                // Sleep proportional to simulated time elapsed, but break into small chunks&#13;&#10;                // for smooth time display updates&#13;&#10;                // At 1x speed: 1 simulated second = 1 real second (1000ms)&#13;&#10;                // At 2x speed: 1 simulated second = 0.5 real seconds (500ms)&#13;&#10;                if (timeElapsed &gt; 0) {&#13;&#10;                    // Capture current speed to avoid inconsistency if slider is adjusted during sleep&#13;&#10;                    double currentSpeed = speedMultiplier;&#13;&#10;                    long totalSleepTime = (long)(timeElapsed * 1000.0 / currentSpeed);&#13;&#10;                    long sleepChunk = 50; // Update UI every 50ms for smooth display&#13;&#10;                    long initialSleepTime = totalSleepTime;&#13;&#10;&#13;&#10;                    // Break the sleep into small chunks and update time progressively&#13;&#10;                    while (totalSleepTime &gt; 0 &amp;&amp; running &amp;&amp; !paused) {&#13;&#10;                        long currentSleep = Math.min(sleepChunk, totalSleepTime);&#13;&#10;                        try {&#13;&#10;                            Thread.sleep(currentSleep);&#13;&#10;                        } catch (InterruptedException e) {&#13;&#10;                            return;&#13;&#10;                        }&#13;&#10;&#13;&#10;                        // Update clock progressively for smooth display&#13;&#10;                        // Use initial sleep time to calculate consistent progress&#13;&#10;                        double progress = (double)(initialSleepTime - totalSleepTime + currentSleep) / initialSleepTime;&#13;&#10;                        double intermediateTime = previousTime + (timeElapsed * progress);&#13;&#10;                        clock.setTime(intermediateTime);&#13;&#10;&#13;&#10;                        if (listener != null) listener.onTimeUpdate(clock.getTime());&#13;&#10;&#13;&#10;                        totalSleepTime -= currentSleep;&#13;&#10;                    }&#13;&#10;                }&#13;&#10;&#13;&#10;                clock.setTime(targetTime);&#13;&#10;                processEvent(event);&#13;&#10;                previousTime = targetTime;&#13;&#10;&#13;&#10;                if (listener != null) listener.onTimeUpdate(clock.getTime());&#13;&#10;            }&#13;&#10;        }&#13;&#10;        running = false;&#13;&#10;        results.setTotalSimulationTime(clock.getTime());&#13;&#10;        if (listener != null) listener.onSimulationComplete();&#13;&#10;    }&#13;&#10;    private void processEvent(Event event) {&#13;&#10;        Task task = event.getTask();&#13;&#10;        switch (event.getType()) {&#13;&#10;            case ARRIVAL: handleArrival(task); break;&#13;&#10;            case DEP_DATA_STORAGE: handleDepartureDataStorage(task); break;&#13;&#10;            case DEP_CLASSIFICATION: handleDepartureClassification(task); break;&#13;&#10;            case DEP_CPU_COMPUTE: handleDepartureCpuCompute(task); break;&#13;&#10;            case DEP_GPU_COMPUTE: handleDepartureGpuCompute(task); break;&#13;&#10;            case DEP_RESULT_STORAGE: handleDepartureResultStorage(task); break;&#13;&#10;        }&#13;&#10;    }&#13;&#10;    private void handleArrival(Task task) {&#13;&#10;        results.recordArrival();&#13;&#10;        dataStorage.addToQueue(task);&#13;&#10;        if (dataStorage.isAvailable()) startServiceDataStorage();&#13;&#10;        scheduleNextArrival();&#13;&#10;    }&#13;&#10;    private void startServiceDataStorage() {&#13;&#10;        Task task = dataStorage.beginService(clock.getTime());&#13;&#10;        if (task != null) {&#13;&#10;            double serviceTime = dataStorage.getServiceTime();&#13;&#10;            eventList.addEvent(new Event(EventType.DEP_DATA_STORAGE, clock.getTime() + serviceTime, task));&#13;&#10;        }&#13;&#10;    }&#13;&#10;    private void handleDepartureDataStorage(Task task) {&#13;&#10;        dataStorage.endService(clock.getTime());&#13;&#10;        classification.addToQueue(task);&#13;&#10;        if (classification.isAvailable()) startServiceClassification();&#13;&#10;        if (dataStorage.isAvailable() &amp;&amp; !dataStorage.isQueueEmpty()) startServiceDataStorage();&#13;&#10;    }&#13;&#10;    private void startServiceClassification() {&#13;&#10;        Task task = classification.beginService(clock.getTime());&#13;&#10;        if (task != null) {&#13;&#10;            double serviceTime = classification.getServiceTime();&#13;&#10;            eventList.addEvent(new Event(EventType.DEP_CLASSIFICATION, clock.getTime() + serviceTime, task));&#13;&#10;        }&#13;&#10;    }&#13;&#10;    private void handleDepartureClassification(Task task) {&#13;&#10;        classification.endService(clock.getTime());&#13;&#10;        // Add task directly to CPU/GPU compute service point (which now has its own queue)&#13;&#10;        if (task.getTaskType() == TaskType.CPU) {&#13;&#10;            cpuCompute.addToQueue(task);&#13;&#10;            if (cpuCompute.isAvailable()) startServiceCpuCompute();&#13;&#10;        } else {&#13;&#10;            gpuCompute.addToQueue(task);&#13;&#10;            if (gpuCompute.isAvailable()) startServiceGpuCompute();&#13;&#10;        }&#13;&#10;        if (classification.isAvailable() &amp;&amp; !classification.isQueueEmpty()) startServiceClassification();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void startServiceCpuCompute() {&#13;&#10;        Task task = cpuCompute.beginService(clock.getTime());&#13;&#10;        if (task != null) {&#13;&#10;            double serviceTime = cpuCompute.getServiceTime();&#13;&#10;            eventList.addEvent(new Event(EventType.DEP_CPU_COMPUTE, clock.getTime() + serviceTime, task));&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void startServiceGpuCompute() {&#13;&#10;        Task task = gpuCompute.beginService(clock.getTime());&#13;&#10;        if (task != null) {&#13;&#10;            double serviceTime = gpuCompute.getServiceTime();&#13;&#10;            eventList.addEvent(new Event(EventType.DEP_GPU_COMPUTE, clock.getTime() + serviceTime, task));&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private void handleDepartureCpuCompute(Task task) {&#13;&#10;        cpuCompute.endService(clock.getTime());&#13;&#10;        resultStorage.addToQueue(task);&#13;&#10;        if (resultStorage.isAvailable()) startServiceResultStorage();&#13;&#10;        if (cpuCompute.isAvailable() &amp;&amp; !cpuCompute.isQueueEmpty()) startServiceCpuCompute();&#13;&#10;    }&#13;&#10;&#13;&#10;    private void handleDepartureGpuCompute(Task task) {&#13;&#10;        gpuCompute.endService(clock.getTime());&#13;&#10;        resultStorage.addToQueue(task);&#13;&#10;        if (resultStorage.isAvailable()) startServiceResultStorage();&#13;&#10;        if (gpuCompute.isAvailable() &amp;&amp; !gpuCompute.isQueueEmpty()) startServiceGpuCompute();&#13;&#10;    }&#13;&#10;    private void startServiceResultStorage() {&#13;&#10;        Task task = resultStorage.beginService(clock.getTime());&#13;&#10;        if (task != null) {&#13;&#10;            double serviceTime = resultStorage.getServiceTime();&#13;&#10;            eventList.addEvent(new Event(EventType.DEP_RESULT_STORAGE, clock.getTime() + serviceTime, task));&#13;&#10;        }&#13;&#10;    }&#13;&#10;    private void handleDepartureResultStorage(Task task) {&#13;&#10;        resultStorage.endService(clock.getTime());&#13;&#10;        task.setCompletionTime(clock.getTime());&#13;&#10;        results.recordCompletion(task);&#13;&#10;        if (resultStorage.isAvailable() &amp;&amp; !resultStorage.isQueueEmpty()) startServiceResultStorage();&#13;&#10;    }&#13;&#10;    /**&#13;&#10;     * Checks if the simulation is currently running.&#13;&#10;     * &#13;&#10;     * @return true if simulation is running, false otherwise&#13;&#10;     */&#13;&#10;    public boolean isRunning() {&#13;&#10;        return running;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Checks if the simulation is currently paused.&#13;&#10;     * &#13;&#10;     * @return true if simulation is paused, false otherwise&#13;&#10;     */&#13;&#10;    public boolean isPaused() {&#13;&#10;        return paused;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Pauses the simulation execution.&#13;&#10;     * &#13;&#10;     * &lt;p&gt;The simulation thread will wait until {@link #resumeSimulation()} is called.&#13;&#10;     */&#13;&#10;    public void pauseSimulation() {&#13;&#10;        paused = true;&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Resumes a paused simulation.&#13;&#10;     * &#13;&#10;     * &lt;p&gt;This method wakes up the simulation thread if it's waiting due to pause.&#13;&#10;     */&#13;&#10;    public void resumeSimulation() {&#13;&#10;        synchronized (pauseLock) {&#13;&#10;            paused = false;&#13;&#10;            pauseLock.notifyAll();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Stops the simulation execution.&#13;&#10;     * &#13;&#10;     * &lt;p&gt;The simulation will finish processing the current event and then stop.&#13;&#10;     * The thread will exit after completing current operations.&#13;&#10;     */&#13;&#10;    public void stopSimulation() {&#13;&#10;        running = false;&#13;&#10;        synchronized (pauseLock) {&#13;&#10;            pauseLock.notifyAll();&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Executes a single simulation step when paused.&#13;&#10;     * &#13;&#10;     * &lt;p&gt;This method processes the next event in the queue. Only works when&#13;&#10;     * simulation is paused. Useful for debugging or step-by-step execution.&#13;&#10;     */&#13;&#10;    public void stepForward() {&#13;&#10;        if (paused &amp;&amp; eventList.hasEvents()) {&#13;&#10;            Event event = eventList.getNextEvent();&#13;&#10;            if (event != null) {&#13;&#10;                clock.setTime(event.getTime());&#13;&#10;                processEvent(event);&#13;&#10;                if (listener != null) listener.onTimeUpdate(clock.getTime());&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Gets the simulation results.&#13;&#10;     * &#13;&#10;     * @return the SimulationResults object containing all statistics&#13;&#10;     */&#13;&#10;    public SimulationResults getResults() {&#13;&#10;        return results;&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Gets the Data Storage service point.&#13;&#10;     * &#13;&#10;     * @return the Data Storage ServicePoint&#13;&#10;     */&#13;&#10;    public ServicePoint getDataStorage() { return dataStorage; }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Gets the Classification service point.&#13;&#10;     * &#13;&#10;     * @return the Classification ServicePoint&#13;&#10;     */&#13;&#10;    public ServicePoint getClassification() { return classification; }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Gets the CPU Compute service point.&#13;&#10;     * &#13;&#10;     * @return the CPU Compute ServicePoint&#13;&#10;     */&#13;&#10;    public ServicePoint getCpuCompute() { return cpuCompute; }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Gets the GPU Compute service point.&#13;&#10;     * &#13;&#10;     * @return the GPU Compute ServicePoint&#13;&#10;     */&#13;&#10;    public ServicePoint getGpuCompute() { return gpuCompute; }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Gets the Result Storage service point.&#13;&#10;     * &#13;&#10;     * @return the Result Storage ServicePoint&#13;&#10;     */&#13;&#10;    public ServicePoint getResultStorage() { return resultStorage; }&#13;&#10;}&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>